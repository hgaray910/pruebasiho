Attribute VB_Name = "modProcedimientos"
'-------------------------------------------------------------------------------------
'| Nombre del Proyecto      : Todos
'| Nombre del Módulo        : modProcedimientos.bas
'-------------------------------------------------------------------------------------
'| Objetivo: Guarda los procedimientos que serán re-utilizados en el proyecto
'-------------------------------------------------------------------------------------
'| Análisis y Diseño        :
'| Autor                    :
'| Fecha de Creación        :
'| Modificó                 : Jose Torres
'| Fecha última modificación: 21/05/2004
'| Modificacion para unificar este modulo
'-------------------------------------------------------------------------------------

Option Explicit
'|  Declaración para el uso de APIs
Private Const BIF_RETURNONLYFSDIRS = 1
Private Const BIF_DONTGOBELOWDOMAIN = 2
Private Const MAX_PATH = 260
Global Const SW_SHOWNORMAL = 1
Global Const SW_HIDE = &H0

Public Type FoliosPrevias
    chrfoliofactura As String
End Type

Public aFoliosPrevios() As FoliosPrevias

Private Const CP_UTF8 = 65001
Private Declare Function MultiByteToWideChar Lib "kernel32" ( _
   ByVal CodePage As Long, ByVal dwFlags As Long, _
   ByVal lpMultiByteStr As Long, ByVal cchMultiByte As Long, _
   ByVal lpWideCharStr As Long, ByVal cchWideChar As Long) As Long

'Declaración de la DLL para generar QR Codes en CFDi (CBB - Código de Barras Bidimensional)
Public Declare Sub FastQRCode Lib "QRCodeLib.dll" (ByVal Texto As String, ByVal FileName As String)
Public Declare Function QRCodeLibVer Lib "QRCodeLib.dll" () As String

Private Declare Function MakeSureDirectoryPathExists Lib "imagehlp.dll" (ByVal lpPath As String) As Long

Public vgstrvarcodigodebarras As String

Private Declare Function shellexecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long

Private Declare Function SHBrowseForFolder Lib "SHELL32" _
                                  (lpbi As BrowseInfo) As Long

Private Declare Function SHGetPathFromIDList Lib "SHELL32" _
                                  (ByVal pidList As Long, _
                                  ByVal lpBuffer As String) As Long

Private Declare Function lstrcat Lib "kernel32" Alias "lstrcatA" _
                                  (ByVal lpString1 As String, ByVal _
                                  lpString2 As String) As Long

Private Type BrowseInfo
   hWndOwner      As Long
   
   pIDLRoot       As Long
   pszDisplayName As Long
   lpszTitle      As Long
   ulFlags        As Long
   lpfnCallback   As Long
   lParam         As Long
   iImage         As Long
End Type

'-------------------------------------------------
'13/01/2008 Tipo de dato para un monto de Factura
Private Type MontoFormateado
    lngX As Long
    lngY As Long
    strPorImprimir As String
End Type
'-------------------------------------------------
'13/01/2008 Arreglo para manejar los montos de los
'conceptos de facturación y totales (Factura)
Dim aMontos() As MontoFormateado
'-------------------------------------------------

Declare Function IsWindowEnabled Lib "user32" (ByVal hwnd As Long) As Long

Public Const INADDR_NONE = &HFFFF
Public Const SOCKET_ERROR = -1
Public Const WSABASEERR = 10000
Public Const WSAEFAULT = (WSABASEERR + 14)
Public Const WSAEINVAL = (WSABASEERR + 22)
Public Const WSAEINPROGRESS = (WSABASEERR + 50)
Public Const WSAENETDOWN = (WSABASEERR + 50)
Public Const WSASYSNOTREADY = (WSABASEERR + 91)
Public Const WSAVERNOTSUPPORTED = (WSABASEERR + 92)
Public Const WSANOTINITIALISED = (WSABASEERR + 93)
Public Const WSAHOST_NOT_FOUND = 11001
Public Const WSADESCRIPTION_LEN = 257
Public Const WSASYS_STATUS_LEN = 129
Public Const WSATRY_AGAIN = 11002
Public Const WSANO_RECOVERY = 11003
Public Const WSANO_DATA = 11004

Public Type WSADATA
    wVersion       As Integer
    wHighVersion   As Integer
    szDescription  As String * WSADESCRIPTION_LEN
    szSystemStatus As String * WSASYS_STATUS_LEN
    iMaxSockets    As Integer
    iMaxUdpDg      As Integer
    lpVendorInfo   As Long
End Type

Public Type HOSTENT
    hName     As Long
    hAliases  As Long
    hAddrType As Integer
    hLength   As Integer
    hAddrList As Long
End Type

Public Type servent
    s_name    As Long
    s_aliases As Long
    s_port    As Integer
    s_proto   As Long
End Type

Public Type protoent
    p_name    As String 'Official name of the protocol
    p_aliases As Long 'Null-terminated array of alternate names
    p_proto   As Long 'Protocol number, in host byte order
End Type

Public Declare Function WSAStartup _
    Lib "ws2_32.dll" (ByVal wVR As Long, lpWSAD As WSADATA) As Long

Public Declare Function WSACleanup Lib "ws2_32.dll" () As Long

Public Declare Function gethostbyaddr _
    Lib "ws2_32.dll" (addr As Long, ByVal addr_len As Long, _
                      ByVal addr_type As Long) As Long

Public Declare Function gethostbyname _
    Lib "ws2_32.dll" (ByVal host_name As String) As Long

Public Declare Function gethostname _
    Lib "ws2_32.dll" (ByVal host_name As String, _
                      ByVal namelen As Long) As Long

Public Declare Function getservbyname _
    Lib "ws2_32.dll" (ByVal serv_name As String, _
                      ByVal proto As String) As Long

Public Declare Function getprotobynumber _
    Lib "ws2_32.dll" (ByVal proto As Long) As Long

Public Declare Function getprotobyname _
    Lib "ws2_32.dll" (ByVal proto_name As String) As Long

Public Declare Function getservbyport _
    Lib "ws2_32.dll" (ByVal port As Integer, ByVal proto As Long) As Long

Public Declare Function inet_addr _
    Lib "ws2_32.dll" (ByVal CP As String) As Long

Public Declare Function inet_ntoa _
    Lib "ws2_32.dll" (ByVal inn As Long) As Long

Public Declare Function htons _
    Lib "ws2_32.dll" (ByVal hostshort As Integer) As Integer

Public Declare Function htonl _
    Lib "ws2_32.dll" (ByVal hostlong As Long) As Long

Public Declare Function ntohl _
    Lib "ws2_32.dll" (ByVal netlong As Long) As Long

Public Declare Function ntohs _
    Lib "ws2_32.dll" (ByVal netshort As Integer) As Integer

Public Declare Sub RtlMoveMemory _
    Lib "kernel32" (hpvDest As Any, _
                    ByVal hpvSource As Long, _
                    ByVal cbCopy As Long)

Public Declare Function lstrcpy _
    Lib "kernel32" Alias "lstrcpyA" (ByVal lpString1 As String, _
                                    ByVal lpString2 As Long) As Long

Public Declare Function lstrlen _
    Lib "kernel32" Alias "lstrlenA" (ByVal lpString As Any) As Long

Public Declare Function GetUserName Lib "advapi32.dll" _
    Alias "GetUserNameA" (ByVal lpBuffer As String, nSize As Long) As Long

'Public Declare Function GetComputerName Lib "kernel32" _
'    Alias "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long

Public Declare Function GetProfileString Lib "kernel32.dll" Alias "GetProfileStringA" (ByVal lpAppName As String, ByVal lpKeyName As String, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long) As Long


Private Const OFFSET_4 = 4294967296#
Private Const MAXINT_4 = 2147483647
Private Const OFFSET_2 = 65536
Private Const MAXINT_2 = 32767

'Obtener el temp folder path
Public Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

'Para esperar al shell de exportación de crystal reports
Public Const INFINITE = &HFFFFFFFF
Public Const SYNCHRONIZE = &H100000
Public Const PROCESS_QUERY_INFORMATION = &H400&

Public Declare Function CloseHandle Lib "kernel32" ( _
    ByVal hObject As Long) As Long

Public Declare Function GetExitCodeProcess Lib "kernel32" ( _
    ByVal hProcess As Long, _
    lpExitCode As Long) As Long

Public Declare Function OpenProcess Lib "kernel32" ( _
    ByVal dwDesiredAccess As Long, _
    ByVal bInheritHandle As Long, _
    ByVal dwProcessId As Long) As Long

Public Declare Function WaitForSingleObject Lib "kernel32" ( _
    ByVal hHandle As Long, _
    ByVal dwMilliseconds As Long) As Long

Declare Function GetDefaultPrinterA Lib "winspool.drv" (ByVal sPrinterName As String, lPrinterNameBufferSize As Long) As Long
Declare Function WriteProfileString Lib "kernel32" Alias "WriteProfileStringA" (ByVal lpszSection As String, ByVal lpszKeyName As String, ByVal lpszString As String) As Long
Declare Function SendMessage Lib "user32.dll" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByRef lParam As Any) As Long
Private Declare Function WTSEnumerateProcesses Lib "wtsapi32.dll" Alias "WTSEnumerateProcessesA" (ByVal hServer As Long, ByVal reserved As Long, ByVal Version As Long, ByRef ppProcessInfo As Long, ByRef pCount As Long) As Long
Private Declare Sub WTSFreeMemory Lib "wtsapi32.dll" (ByVal pMemory As Long)

Public vglngTerminalServerSessionId As Long

Private Type WTS_PROCESS_INFO
    SessionID As Long
    ProcessId As Long
    pProcessName As Long
    pUserSid As Long
End Type


Private Const HWND_BROADCAST = &HFFFF
Private Const WM_WININICHANGE = &H1A

'Manejo de lotes en Recibos , AjustesInventarios, Otras e/s y DevolucionProveedor
Public Type varLotes
    Articulo As String
    lote As String
    fechaCaducidad As Date
    CantidadUM As Long
    CantidadUV As Long
    CantidadUMInicio As Long
    CantidadUVInicio As Long
    Borrado As String
    Movimiento As Long          'Se usa unicamente para las devoluciones de requisiciones de cargo a paciente, para poder diferenciar el mismo articulo pero en diferentes requisiciones
    Devolucion As Long          'Se usa unicamente para las devoluciones de requisiciones de cargo a paciente, para poder diferenciar el mismo articulo pero en diferentes requisiciones para diferentes devoluciones
    TablaRelacion As String
    TipoAccion As Integer       'Se usa unicamente para la captura fisica de inventario: 1 = Entrada UV, 2 = Entrada UM, 3 = Salida UV y 4 = Salida UM
    CodBar As String            ' Codigo de barras para la trazabilidad
End Type
Public agLotes() As varLotes

Public vgstrNombreEquipo As String
Public vgstrUsuarioWindows As String
Public vgstrNombreIP As String
Public vglngSesion As Long

Public vgstrNombreCarpeta As String
Global vgblnVieneError As Boolean
Public rsSesionUnica As New ADODB.Recordset
Public cnn1 As New ADODB.Connection

'Para los parámetros del módulo de almacén (IvParametro)
Public glngCveDepartamentoPapeleria As Long
Public gstrConfiguracionActivo As String
Public gstrConfiguracionCosto As String
Public gstrConfiguracionGasto As String
Public gstrFormatoCveArticulo As String
Public gintBonificacionCostoCero As Integer
Public gstrTipoCuentaAjuste As String
Public gintAutorizaReqReubica As Integer
Public gintMuestraCodBar As Integer
Public gintInventarioFisicoDUMMY As Integer
Public gintCopiaReqSurtida As Integer
Public gstrTipoCuentaReubicacionStock As String
Public glngCtaIVACobrado As Long 'Para la cuenta contable de IVA cobrado, se usa en pCargarVarPrmGnrl
Public glngCtaIVANoCobrado As Long 'Para la cuenta contable de IVA no cobrado, se usa en pCargarVarPrmGnrl
Public glngCtaIVAPagado As Long 'Para la cuenta contable de IVA pagado, se usa en pCargarVarPrmGnrl
Public glngCtaIVANoPagado As Long 'Para la cuenta contable de IVA no pagado, se usa en pCargarVarPrmGnrl
Public glngCtaIVAArrendamiento As Long 'Para la cuenta contable de IVA de recibos de arrendamiento, se usa en pCargarVarPrmGnr1
Public glngCtaISRArrendamiento As Long 'Para la cuenta contable de ISR de recibos de arrendamiento Retencion, se usa en pCargarVarPrmGnr1
Public glngCtaISRRetenidoArrendamiento As Long 'Para la cuenta contable de ISR de recibos de arrendamiento Retencion, se usa en pCargarVarPrmGnr1
Public glngCtaISRProvisArrendamiento As Long 'Para la cuenta contable de ISR de recibos de arrendamiento Provisionado, se usa en pCargarVarPrmGnr1
Public glngctaIEPSCobrado As Long 'Para la cuenta contable de IEPS cobrado, se usa en pCargarVarPrmGnrl
Public glngctaIEPSNoCobrado As Long 'Para la cuenta contable de IEPS no cobrado, se usa en pCargarVarPrmGnrl
Public glngctaIEPSPagado As Long 'Para la cuenta contable de IEPS pagado, se usa en pCargarVarPrmGnrl
Public glngctaIEPSNoPagado As Long 'Para la cuenta contable de IEPS no pagado, se usa en pCargarVarPrmGnrl
Public glngCtaRetencionISR As Long 'Para el movimiento contable de retención de ISR
Public glngCtaProvisionISR As Long 'Para el movimiento contable de provisión de ISR
Public glngCtaRetencionIVA As Long 'Para el movimiento contable de retención de IVA
Public glngCveImpuesto As Long 'Clave del impuesto con el que factura el hospital, se usa en pCargarVarPrmGnrl
Public gdblPorcentajeRetIVA As Double '% de retención de IVA para honorarios
Public gdblPorcentajeRetFletes As Double '% de retención de IVA para fletes
Public gblnCatCentralizados As Boolean 'Toma el parámetro de la tabla Parametros
Public gstrRFCFisicaInicial As String 'Parte inicial del RFC de una persona física
Public gstrRFCFisicaFecha As String 'Fecha del RFC de una persona física
Public gstrRFCFisicaHomoclave As String 'Homoclave del RFC de una persona física
Public gstrRFCMoralInicial As String 'Parte inicial del RFC de una persona moral
Public gstrRFCMoralFecha As String 'Fecha del RFC de una persona moral
Public gstrRFCMoralHomoclave As String 'Homoclave del RFC de una persona moral
Public gintDesglosarIVA As Integer 'Indica si se desglosa IVA en facturación para personas que no cuentan con homoclave
Public gbitNewEncrypt As Integer 'Para el modo de encriptación
Public vgstrEdad As String                  'Edad del paciente
Public vgintEdadNumero As Integer           'Edad del paciente en numeros enteros
Public vgdtmFechaNacimiento As Date         'Fecha de nacimiento del paciente
Public vgstrDiagnosticoActual As String     'Variable para guardar el diagnostico actual de cada paciente
Public vglngnCtaRetencionFletes As Long     'Número de cuenta contable que se utiliza para contabilizar la retención por fletes.
Public vglngCtaDescuentosCompra As Long     'Número de cuenta contable que se utiliza para contabilizar los descuentos sobre compra.
Public vglngCtaPerdidaCambiaria As Long     'Número de cuenta contable que se utiliza para contabilizar la pérdida cambiaria.
Public vglngCtaUtilidadCambiaria As Long    'Número de cuenta contable que se utiliza para contabilizar la utilidad cambiaria.
Public vglngCtaInteresvencimientos As Long  'Número de cuenta contable que se utiliza para contabilizar los intereses vencidos.
Public vgIntDigitoVerificador As Integer        'Clave del digito verificador del IMSS
Global vgblnInterfazSurfing As Boolean      ' Si la empresa va a utilizar la interfaz von Surfing
Public vgintClaveexamen As Integer          ' Localizacion de clave en caja
Public rsExamencaja As New ADODB.Recordset
Public intSelectExam As Integer             ' Selecciona el tipo, examen o grupo de examen
Public vgintNumeroDepartamentoRecibe As Integer
Public vlblnConsulta As Boolean             ' Consulta de kardex
Public vlintempleadorecibekar As Long       ' Empleado recibe medicamento, consulta de kardex
Public vlbnlActivaPacienterecibe As Boolean  'Activar para visualizar empleado recibe
Public glngctaProvServClientes As Long          'cuenta provisión clientes
Public glngctaRetenServClientes As Long         'cuenta retención clientes
Public glngctaISRretenHonorario As Long         'cuenta retención honorarios médicos
Public glngctaISRprovisHonorario As Long        'cuenta provisión honorarios médicos
Public glngctaProvisRetenFlete As Long              'cuenta provision de retencion flete
Public glngctaProvisRetenServicios As Long      'cuenta provision de retencion servicios
Public glngCtaRetencionRTP As Long 'Para el movimiento contable de retención de RTP
Public glngCtaProvisionRTP As Long 'Para el movimiento contable de provisión de RTP
Public glngCtaISRprovisionadoResico As Long ' Para el movimiento contable de retención de ISR provisionado en el Régimen Simplificado de Confianza (RESICO)
Public glngCtaISRretenidoResico As Long     ' Para el movimiento contable de retención de ISR retenido en el Régimen Simplificado de Confianza (RESICO)

'Variables para la identificacion de cuartos
Public vglngCveEstadoCuartoOcupado As Long 'Clave del estado de cuarto ocupado
Public gintNumeroCuartosCensablesPermitidos As Integer
Public gintNumeroCuartosCensablesActuales As Integer
Public gintNumeroCuartosNoCensablesPermitidos As Integer
Public gintNumeroCuartosNoCensablesActuales As Integer

'Parámetro de Admisión
Public vgblnAsignarPaqueteAdmision As Boolean 'bit para indicar si se van a asignar paquetes en la admision
Public vglngCveIdioma As Long                 'Clave del idioma predeterminado para el registro de pacientes
Public vgstrObservacionesIngreso As String 'Variable que contiene las observaciones globales de siempre
Public vglngDiasIngresoPrevio As Integer 'Variable que contiene la duracion de los registros en ingreso previo
Public vglngCveReligionPredeterminada As Long 'Clave de la religión predeterminada
Public vgstrPaternoDesconocido As String 'Dato en apellido paterno para el paciente desconocido
Public vgstrMaternoDesconocido As String 'Dato en apellido materno para el paciente desconocido
Public vgstrNombreDesconocido As String 'Dato en nombre para el paciente desconocido
Public vglngCveEstadoCuartoDisponible As Long 'Clave del estado de cuarto disponible

'bandera para la identificacion num predial
Public vgblnhaynumpredial As Boolean
Public VGLNUMPREDIAL As String

Public vgblRazonSocial As String 'variable agregada para que al generarse una nota de credito tome los datos de el catalogo la razon social actual

' para frmRequisicionCargoPac
Public vglngCvePaciente As Long
Public vgintCveDeptoCargo As Integer
Public vgstrEstatusPaciente As String
Public vgstrArea As String
Public vgstrMedicoEnfermera As String           'Indica si el documento de expediente lo pueden grabar
                                                'médicos, enfermeras o ambos "E" = Enfermeras, "M" = Médicos, "A" = Ambos
                                                'Se usa en frmTratamiento para llamar 'el procedimiento pPersonaGraba
                                                
Public vgblnMenuNomina As Boolean               'Para que no se vuelva a mostrar la forna de tipo de nómina al hacer clic en el fonfo en módulo de nómina
'---------------------------------------------------------------------------------------------------
'Para el procedimiento pImprimirCheques
Public Type aCheque
    Columna As Integer
    renglon As Integer
    Cadena As String
End Type
Dim aCadenas() As aCheque
'---------------------------------------------------------------------------------------------------

'---------------------------------------------------------------------------------------------------
Public vgcolParametrosModulo As Collection 'Colección para los parámetros de cada módulo
Public vgblnBanderaParametrosRegistrados As Boolean 'Bandera para saber si ya se han registrado los parámetros del módulo
'---------------------------------------------------------------------------------------------------
'###################### Variables para codificar y decodificar la vigencia ######################

Private Const clOneMask = 16515072          '000000 111111 111111 111111
Private Const clTwoMask = 258048            '111111 000000 111111 111111
Private Const clThreeMask = 4032            '111111 111111 000000 111111
Private Const clFourMask = 63               '111111 111111 111111 000000

Private Const clHighMask = 16711680         '11111111 00000000 00000000
Private Const clMidMask = 65280             '00000000 11111111 00000000
Private Const clLowMask = 255               '00000000 00000000 11111111

Private Const cl2Exp18 = 262144             '2 to the 18th power
Private Const cl2Exp12 = 4096               '2 to the 12th
Private Const cl2Exp6 = 64                  '2 to the 6th
Private Const cl2Exp8 = 256                 '2 to the 8th
Private Const cl2Exp16 = 65536              '2 to the 16th

Public vgblnForzarLoteYCaduc As Boolean        'Indica si se forzará la captura del lote y la caducidad
Public vgblnCapturoLoteYCaduc As Boolean    'Variable que se usa para determinar el estado de la captura de lotes y caducidades

Public vgLngTotalLotesxMov As Long


Public Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
Public Declare Function GetIpAddrTable Lib "IPHlpApi" (pIPAdrTable As Byte, pdwSize As Long, ByVal Sort As Long) As Long
Public Const MAX_COMPUTERNAME_LENGTH As Long = 31
Public Declare Function GetComputerName Lib "kernel32" Alias "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare Function GetCurrentProcessId Lib "kernel32" () As Long

Const MAX_IP = 5
Type IPINFO
dwAddr As Long
dwIndex As Long
dwMask As Long
dwBCastAddr As Long
dwReasmSize As Long
unused1 As Integer
unused2 As Integer
End Type
Type MIB_IPADDRTABLE
dEntrys As Long
mIPInfo(MAX_IP) As IPINFO
End Type
Type IP_Array
mBuffer As MIB_IPADDRTABLE
BufferLen As Long
End Type

Public vgstrNumeroIP As String
Public vgstrNombreMaquina As String
'------------------------------------
Public vlobjDOMXML As DOMDocument
Public vgintTipoXMLCXP As Integer '1 = CFDI, 2 = CFD
Public vgstrUUIDXMLCXP As String
Public vgstrRFCXMLCXP As String
Public vgdblMontoXMLCXP As Double
Public vgstrMonedaXMLCXP As String
Public vgdblTipoCambioXMLCXP As Double
Public vgstrSerieCXP As String
Public vgstrNumFolioCXP As String
Public vgstrNumFactExtCXP As String
Public vgstrTaxIDExtCXP As String
Public vgstrXMLCXP As String
Public vgstrRFCReceptorXMLCXP As String
Public vgstrVersionCFDI As String
Public vgblnNuevoEsquemaCancelacion As String

'--------------------------------------------------------------------------------------------------------------------------------------CORTE
Public Type typCorteMov
    vllngCorte As Long            'cortepoliza,detallecorte,canceladoctocorte
    vllngPersonaGraba As Long     'detallecorte
    vlstrFolioDocumento As String 'cortepoliza,detallecorte,canceladoctocorte
    vlstrTipoDocumento As String  'cortepoliza,detallecorte,canceladoctocorte
    vllngCuentaContable As Long   'cortepoliza
    vldblCantidad As Double       'cortepoliza,detallecorte
    vlblnCargo As Boolean         'cortepoliza
    vlStrFechaHora As String      'detallecorte
    vlintFormaPago As Integer      'detallecorte
    vldblTipoCambio As Double     'detallecorte
    vlstrfolioCheque As String    'detallecorte
    vllngCorteDocto As Long       'detallecorte,canceladoctocorte
    vlintTipoOperacion As Integer    '0 = inicializa el arreglo, 1 = inserta en pvdetallecorte, 2= inserta en pvcortepoliza,3 = cancela doc en el corte
    vlblnSeExcluye As Boolean 'se utiliza para saber si se debe o no realizar la operacion, de inicio debe esta en False
    vlstrFolioDocOriginaMov As String 'folio documento que origina el movimiento en el corte
    vlstrTipoDocOriginaMov As String 'tipo de documento que origina el movimiento en el corte
    
    vlbolEsCredito As Boolean
    vlstrRFC As String
    vlstrBancoSAT As String
    vlstrBancoExtranjero As String
    vlstrCuentaBancaria As String
    vldtmFecha As Date
    vlstrTipoMovimiento As String
End Type
Public vlarrMovCorte() As typCorteMov
Public vlintElementosMovCorte As Integer 'Cantidad de elementos que tiene vlarrMovCorte

Public vlarrMovCorteIngresos() As typCorteMov   'Arreglo que almacena movimientos referentes a movimientos de ingresos
Public vlintElementosMovCorteIng As Integer     'Cantidad de elementos que tiene vlarrMovCorteIngresos

Public vgIntBanderaTImbradoPendiente As Integer '0 = timbrado OK,1 = no hay timbre(ERROR no controlado el timbre queda pendiente),2 = No hay timbrado (Error Controlado no queda pendiente el timbre),3=error antes de que se intente el timbre
Public blnNOMensajeErrorPAC As Boolean

'Manejo de errores en el proceso de timbrado---------------------------------------------
Public CFDiblnHaytimbre As Boolean         'indica si se timbro el CFDi
Public CFDistrProcesoError As String       'indica el proceso donde ocurrio el error
Public CFDiblnBanError As Boolean          'indica que si hay de error
Public CFDiintLineaError As Integer        'indica la linea en la que se produjo el error
Public CFDilngNumError As Long             'número del error
Public CFDistrDescripError As String       'indica la descripcion del error
Public CFDiintResultadoTimbrado As Integer 'Resultado de si queda o no queda el timbre pendiente
Public CFDiMostrarMensajeError As Boolean  'true = se debe mostrar el mensaje de error, False = ya fué mostrado
Dim intTipoCFDmodP As Integer
Public intBitCuentaPuenteBanco As Long      'Parámetro que indica si se utiliza cuenta puente para abonos a cuentas de banco por cancelación y/o re facturación
Public lngCuentaPuenteBanco As Long         'Cuenta puente para abonos a cuentas de banco por cancelación y/o re facturación, en lugar de las cuentas relacionadas con bancos
'Public vlstrTipoMovimientoPoliza As String  'Indica el tipo de movimiento en pvcortepoliza (CB=comision bancaria, PA=pago automático)
Public intBitCuentaPuenteIngresos As Long   'Parámetro que indica si se utiliza cuenta puente para asientos contables cuando se realice o se cancele un ticket, en lugar de las cuentas relacionadas con ingresos
Public lngCuentaPuenteIngresos As Long      'Cuenta puente para sustitui cuentas de ingresos al realizar y/o cancelar ticket, en lugar de las cuentas relacionadas con ingresos
Public vglngCveEmpresaPaciente As Long      'Clave empresa alta expacienteingreso
Public vgchMotivoIngreso As String          'Actualizacion de motivo ingreso

Public Type Arreglo_DescuentosporTasaIVA
    PorcentajeIVA As Double
    ImporteDescuento As Double
    CuentaDescuento As Long
    Configurado As String
End Type
Public DescuentosporTasaIVA() As Arreglo_DescuentosporTasaIVA

Public vlblnCuentaDescuentoValida As Boolean

Public vgblnCapturaraDatosBanco As Boolean

Public vgstrPersonaqueGrabaEmpleadoMedico As String
Public vstrRequisicion As String
Public vlstrErrorLister As Integer 'En esta variable almacenamos el codi

Public vgMotivoCancelacion As String
Public vgstrFolioFiscalSustituye As String

Public vgstrTipoNotaSig As String 'Vamos a usar esto en el Where para insertar el CP y regimen en la tabla GNCOMPROBANTEFISCALDIGITAL
Public vglngIdComprobanteSig As Long 'Vamos a usar esto en el Where para insertar el CP y regimen en la tabla GNCOMPROBANTEFISCALDIGITAL
Public vgstrCodigoPostalSig As String
Public vgstrRegimenFiscalSig As String
Public vgStrPeriodicidad As String
Public vgStrMesesGlobal As String
Public vgStrAñoGlobal As String
Public vlblnExcluirPaciente As Boolean
Private Type ConfigConceptoPoliza
    tipo As String
    Texto As String
End Type
Public ConceptosPoliza() As ConfigConceptoPoliza
Public vg_intIndiceConceptoPoliza As Integer
Public lstrConceptoPoliza As String           'Variable para traer el concepto de la póliza de corte
Public lstrConceptoDetallePoliza As String    'Variable para agregar el concepto en el detalle de la póliza

'Variable para la trazabilidad
Public vgblnTrazabilidad As Boolean
Public vlblnUsarRazonSocial As Boolean


Public Function flngCartaDefault(lngNumCuentaPaciente As Long) As Long
On Error GoTo NotificaError
    'Revisa si es la carta configurada por defecto'

    Dim rs As New ADODB.Recordset
    Dim lstrSentencia As String
    
    flngCartaDefault = 0
    lstrSentencia = "Select INTCVECARTA from PVCARTACONTROLSEGURO where BITDEFAULT = 1 and intNumCuenta=" & lngNumCuentaPaciente & " and chrEstatus <> 'I'"
    Set rs = frsRegresaRs(lstrSentencia, adLockOptimistic, adOpenDynamic)
    If rs.RecordCount > 0 Then
        flngCartaDefault = IIf(IsNull(rs!intCveCarta), 0, rs!intCveCarta)
    End If
                                       
    rs.Close
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & ":flngCartaDefault"))
End Function

Public Function fcurObtenerRetencionISR(lngCveProveedor As Long) As Currency
    '--------------------------------------------------------------------------------------------------------
    ' Obtiene el porcentaje de la retención del ISR según el régimen que se le haya configurado al proveedor
    '--------------------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim rsRetencion As New ADODB.Recordset
    Dim vlstrSentencia As String

    fcurObtenerRetencionISR = 0
    vlstrSentencia = "SELECT CnRegimenRetencion.intidtarifa, cnTarifaISR.numporcentaje " & _
                       "FROM CoProveedor INNER JOIN CnRegimenRetencion ON trim(CoProveedor.vchclaveregimensat) = trim(CnRegimenRetencion.chridregimen) " & _
                                        "INNER JOIN cnTarifaISR ON CnRegimenRetencion.intidtarifa = cnTarifaISR.intidtarifa " & _
                      "WHERE CoProveedor.vchtiporegimen <> 'MORAL' AND CoProveedor.intCveProveedor = " & lngCveProveedor
    
    Set rsRetencion = frsRegresaRs(vlstrSentencia)
    If rsRetencion.RecordCount <> 0 Then
        fcurObtenerRetencionISR = rsRetencion!NUMPORCENTAJE
    End If
    rsRetencion.Close
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & ":fcurObtenerRetencionISR"))
End Function

Private Sub pDesAplicarDescuentoPuntos(strFolio As String, blncontrolaseguradora As Boolean, lngCuentaPaciente As Long)
On Error GoTo NotificaError
    Dim llngRow As Long
    Dim llngPersonaGraba As Long
    Dim lstrSentencia As String
    Dim rsTabulador As New ADODB.Recordset
    Dim dblDescuentoPuntos As Double
    Dim vldblSubtotal As Double
    Dim vllngContador As Long
    Dim vldblDescuentoPuntos As Double
    Dim vldblDescuentoCargo As Double
    Dim vldblImporteFactura As Double
    Dim rs As New ADODB.Recordset
    
    ' -- 16801 --
    '---------------------------------------------
    ' Eliminar descuento por aplicación de puntos
    '---------------------------------------------
    
    lstrSentencia = "Select count(*) puntos from PvPuntosUtilizadosPaciente " & _
                   " where trim(chrFolioFactura) = trim('" & strFolio & "') "
    Set rs = frsRegresaRs(lstrSentencia, adLockReadOnly, adOpenForwardOnly)
    If rs.RecordCount > 0 Then
        If rs!puntos > 0 Then
            If blncontrolaseguradora Then
                lstrSentencia = "Delete from PvDescuento " & _
                " Where intcveafectada = " & lngCuentaPaciente & " and chrtipodescuento = 'P' and mnyDescuentoPuntos > 0 " & _
                "   and chrtipocargo = 'CF' and tnyclaveempresa = " & vgintClaveEmpresaContable & " and inttipodescuento = 0 "
                pEjecutaSentencia (lstrSentencia)
            End If
            
            ' Limpia los descuentos aplicados por puntos
            lstrSentencia = "Update PvCargo Set mnyDescuentoPuntos = 0, mnyDescuento = mnyDescuentoOriginal" & _
                            " Where chrfoliofactura = '" & Trim(strFolio) & "'"
            ' Recupera el descuento original de cada cargo antes de aplicar el descuento por puntos
            pEjecutaSentencia (lstrSentencia)
            lstrSentencia = "Update PvCargo Set mnyDescuentoOriginal = 0" & _
                            " Where chrfoliofactura = '" & Trim(strFolio) & "'"
            pEjecutaSentencia (lstrSentencia)
            ' Calcula de nuevo el monto del IVA despues de eliminar el descuento por puntos
            lstrSentencia = "Update PvCargo Set mnyIVA = ((mnyprecio * mnycantidad) - mnydescuento + mnyieps) * " & _
                                                            "(Select smyIva/100 IVA from pvConceptoFacturacion " & _
                                                              "where smiCveConcepto = PvCargo.smicveconcepto) " & _
                            " Where chrfoliofactura = '" & Trim(strFolio) & "'"
            pEjecutaSentencia (lstrSentencia)
        End If
    End If
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pDesAplicarDescuentoPuntos"))
End Sub

Public Function fblnLicenciaLealtadCliente() As Boolean
    Dim strSql As String
    Dim strEncriptado As String
    Dim rsTemp As ADODB.Recordset
    
    fblnLicenciaLealtadCliente = False
    
    strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC, TRIM(SIPARAMETRO.VCHVALOR) AS VALOR " & _
        "FROM SIPARAMETRO,CNEMPRESACONTABLE WHERE " & _
        "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable & " AND SIPARAMETRO.VCHNOMBRE = 'VCHLICENCIALEALTADCLIENTE' AND SIPARAMETRO.INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable
    Set rsTemp = frsRegresaRs(strSql)
    If Not rsTemp.EOF Then
        strEncriptado = fstrEncrypt(rsTemp!RFC, "LEALTADCLIENTESIHO041099")
        fblnLicenciaLealtadCliente = IIf(rsTemp!Valor = strEncriptado, True, False)
    End If
End Function

Public Function flngGrabaConsignacionMaestro(vlngNumConsecutivo As Long, vstrNaturaleza As String, vstrTipoEntSal As String, vllngNumReferencia As Long, vlintCveAlmacen As Integer, vllngNumEmpleado As Long) As Long
On Error GoTo NotificaError
    
    Dim rsConsignaMaestro As New ADODB.Recordset
    Dim vlstrx As String
    
    'vstrTipoEntSal (Tipo de entrada o salida):
    '1 = Salida para surtir cargo a paciente, 2 = Entrada de devolución por separación de cargos, 3 = Entrada por reposición de medicamentos
    
    flngGrabaConsignacionMaestro = 0
    
    vlstrx = "SELECT * FROM IvEntradaSalidaConsignaMaestro " & _
             "WHERE numReferencia = " & vllngNumReferencia & " AND smiCveAlmacenConsignacion = " & vlintCveAlmacen & _
             " AND chrNaturaleza = '" & vstrNaturaleza & "' AND chrTipoEntradaSalida = " & vstrTipoEntSal

    Set rsConsignaMaestro = frsRegresaRs(vlstrx, adLockOptimistic, adOpenDynamic)
    
    If rsConsignaMaestro.RecordCount = 0 Then
        With rsConsignaMaestro
            .AddNew
            !chrNaturaleza = vstrNaturaleza
            !chrTipoEntradaSalida = vstrTipoEntSal
            !numReferencia = vllngNumReferencia
            !smiCveAlmacenConsignacion = vlintCveAlmacen
            !intCveEmpleado = vllngNumEmpleado
            !dtmFechahora = fdtmServerFechaHora
            .Update
            flngGrabaConsignacionMaestro = flngObtieneIdentity("SEC_IVENTSALCONSIGNAMAESTRO", !NUMENTRADASALIDACONSIGNACION)
            .Close
        End With
    Else
        flngGrabaConsignacionMaestro = rsConsignaMaestro!NUMENTRADASALIDACONSIGNACION
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngGrabaConsignacionMaestro"))
End Function

Public Sub pGrabaConsignaDetalle(vllngNumEntradaSalida As Long, vllngIdArticulo As Long, vlstrCveArticulo As String, vllngCantidad As Long, vlstrUnidad As String, vldblCostoPromedio As Double, ldblPrecioProveedor As Double, vlintEmpleadoRecibe As Integer)
On Error GoTo NotificaError
        
    Dim rsConsignaDetalle As New ADODB.Recordset
    Dim vlstrx As String
    
    vlstrx = "SELECT * FROM IvEntradaSalidaConsignaDetalle WHERE NUMENTRADASALIDACONSIGNACION = -1"
    Set rsConsignaDetalle = frsRegresaRs(vlstrx, adLockOptimistic, adOpenDynamic)
     
    With rsConsignaDetalle
        .AddNew
        !NUMENTRADASALIDACONSIGNACION = vllngNumEntradaSalida
        !intIdArticulo = vllngIdArticulo
        !chrcvearticulo = vlstrCveArticulo
        !intCantidad = vllngCantidad
        !CHRUNIDADCONTROL = vlstrUnidad
        !mnycostopromedio = vldblCostoPromedio
        !mnyprecioproveedor = ldblPrecioProveedor
        !intcveempleadorecibe = IIf(Trim(vlintEmpleadoRecibe) <> 0, Trim(vlintEmpleadoRecibe), Null)
        .Update
    End With
        
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pGrabaConsignaDetalle"))
End Sub


Public Function fblnLicenciaVitamedica()

    Dim strSql As String
    Dim strEncriptado As String
    Dim rsTemp As ADODB.Recordset
    
    fblnLicenciaVitamedica = False
    
    strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC, TRIM(SIPARAMETRO.VCHVALOR) AS VALOR " & _
        "FROM SIPARAMETRO,CNEMPRESACONTABLE WHERE " & _
        "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable & " AND SIPARAMETRO.VCHNOMBRE = 'VCHLICENCIAVITAMEDICA'"
    Set rsTemp = frsRegresaRs(strSql)
    Do While Not rsTemp.EOF
        strEncriptado = fstrEncrypt(rsTemp!RFC, "VITAMEDICASIHO670308CTAPACIENTE")
        fblnLicenciaVitamedica = IIf(rsTemp!Valor = strEncriptado, True, False)
        If fblnLicenciaVitamedica Then Exit Do
        rsTemp.MoveNext
    Loop


End Function
Public Function fblnValidaCuentaPuenteIngresos(intEmpresa As Integer) As Boolean
On Error GoTo NotificaError

    Dim rs As ADODB.Recordset
    Dim strSql As String
    Dim rsTemp As ADODB.Recordset
    '---------------------------------------------------------------------------------'
    ' Valida parámetros para usar la cuenta puente para sustituir cuentas de ingresos '
    '---------------------------------------------------------------------------------'
    
    fblnValidaCuentaPuenteIngresos = True
    
    ' Regresa bit para validar cuenta puente a ingresos
    intBitCuentaPuenteIngresos = 1
    frsEjecuta_SP CStr(intEmpresa) & "|" & "bitUtilizaCuentaPuenteIngresos", "FN_PVSELBITPARAMETRO", True, intBitCuentaPuenteIngresos
    
    If intBitCuentaPuenteIngresos = 1 Then
        ' Regresa valor de parámetro que indica la cuenta puente a ingresos
        If fblnValidaCuentaPuenteIngresos Then
            lngCuentaPuenteIngresos = 0
            Set rsTemp = frsSelParametros("CN", vgintClaveEmpresaContable, "INTNUMCUENTAPUENTEINGRESOS")
            If rsTemp.EOF Then
                'No se ha registrado la "Cuenta puente para sustituir cuenta de ingresos al realizar y/o cancelar ticket".
                MsgBox SIHOMsg(1397), vbOKOnly + vbInformation, "Mensaje"
                fblnValidaCuentaPuenteIngresos = False
            Else
                lngCuentaPuenteIngresos = IIf(IsNull(rsTemp!Valor), 0, CLng(rsTemp!Valor))
                If lngCuentaPuenteIngresos = 0 Then
                    'No se ha registrado la "Cuenta puente para sustituir cuenta de ingresos al realizar y/o cancelar ticket".
                    MsgBox SIHOMsg(1397), vbOKOnly + vbInformation, "Mensaje"
                    fblnValidaCuentaPuenteIngresos = False
                End If
            End If
            rsTemp.Close
        End If
               
        ' Regresa valores de la cuenta puente para sustituir cuentas de ingresos
        If fblnValidaCuentaPuenteIngresos Then
            Set rsTemp = frsEjecuta_SP(CStr(lngCuentaPuenteIngresos), "Sp_CnSelCuentaContable")
            If rsTemp.RecordCount > 0 Then
                If IsNull(rsTemp!bitEstatusActiva) Or rsTemp!bitEstatusActiva = 0 Then
                    'La cuenta puente para sustituir cuenta de ingresos al realizar y/o cancelar ticket no está activa.
                    MsgBox SIHOMsg(1398), vbOKOnly + vbInformation, "Mensaje"
                    fblnValidaCuentaPuenteIngresos = False
                Else
                    If IsNull(rsTemp!Bitestatusmovimientos) Or rsTemp!Bitestatusmovimientos = 0 Then
                        'La cuenta puente para sustituir cuenta de ingresos al realizar y/o cancelar ticket no acepta movimientos.
                        MsgBox SIHOMsg(1399), vbOKOnly + vbInformation, "Mensaje"
                        fblnValidaCuentaPuenteIngresos = False
                    End If
                End If
            End If
            rsTemp.Close
        End If
   Else
       If intBitCuentaPuenteIngresos = -1 Then
           MsgBox "El parámetro 'Utilizar cuenta puente en sustitución de cuentas de ingresos al realizar y/o cancelar tickets' no existe", vbOKOnly + vbInformation, "Mensaje"
           fblnValidaCuentaPuenteIngresos = False
        End If
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnValidaCuentaPuenteIngresos"))
End Function

Public Sub pAgregarMovArregloCorteIngresos(vllngCorte As Long, vllngPersonaGraba As Long, vlstrFolioDocumento As String, vlstrTipoDocumento As String, vllngCuentaContable As Long, vldblCantidad As Double, vlblnCargo As Boolean, vlStrFechaHora As String, vlintFormaPago As Long, vldblTipoCambio As Double, vlstrfolioCheque As String, vllngCorteDocto As Long, vlintTipoOperacion As Integer, vlstrFolioDocOriginaMov As String, vlstrTipoDocOriginaMov As String, Optional vlbolEsCredito As Boolean, Optional vlstrRFC As String, Optional vlstrBancoSAT As String, Optional vlstrBancoExtranjero As String, Optional vlstrCuentaBancaria As String, Optional vldtmFecha As Date, Optional vlstrTipoMovimientoPoliza As String)
    If vlintTipoOperacion = 0 Then
       'Reiniciamos el arreglo cuando la operación  = 0
       vlintElementosMovCorteIng = 0
       ReDim vlarrMovCorteIngresos(vlintElementosMovCorteIng)
    Else
       'procedimiento para agregar registros al arreglo de movimientos del corte
        ReDim Preserve vlarrMovCorteIngresos(vlintElementosMovCorteIng)
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vllngCorte = vllngCorte
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vllngPersonaGraba = vllngPersonaGraba
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrFolioDocumento = vlstrFolioDocumento
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrTipoDocumento = vlstrTipoDocumento
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vllngCuentaContable = vllngCuentaContable
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vldblCantidad = vldblCantidad
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlblnCargo = vlblnCargo
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlStrFechaHora = vlStrFechaHora
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlintFormaPago = vlintFormaPago
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vldblTipoCambio = vldblTipoCambio
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrfolioCheque = vlstrfolioCheque
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vllngCorteDocto = vllngCorteDocto
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlintTipoOperacion = vlintTipoOperacion
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlblnSeExcluye = False 'por default al agregar se coloca en false
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrFolioDocOriginaMov = vlstrFolioDocOriginaMov
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrTipoDocOriginaMov = vlstrTipoDocOriginaMov

        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlbolEsCredito = vlbolEsCredito
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrRFC = vlstrRFC
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrBancoSAT = vlstrBancoSAT
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrBancoExtranjero = vlstrBancoExtranjero
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrCuentaBancaria = vlstrCuentaBancaria
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vldtmFecha = vldtmFecha
        vlarrMovCorteIngresos(vlintElementosMovCorteIng).vlstrTipoMovimiento = vlstrTipoMovimientoPoliza
    
        vlintElementosMovCorteIng = vlintElementosMovCorteIng + 1
    End If
    
End Sub

Public Sub pLlenaPolizaDescuento(vlintNumeroProceso As Integer, vlrelivaentrada As Double, vlsmiCantidadRecep As Integer, vlmnyCostoEntrada As Double, vlrelDescuentoEnt As Double, vlmnyDescuento As Double, vlintEmpresa As Integer)
    Dim i As Integer
    Dim vllngCtaDescuentosCompra As Long
    Dim vlblnAgregarTasa As Boolean
    Dim vlblnEstaCuenta As Boolean
    Dim vlintTamaño As Integer
    Dim vlintPosicion As Integer

    ' Este procedimiento agrega a arreglo de movimientos contables relacionados con descuentos sobre compra,
    ' desglosados por departamento y tasa de IVA
    
    vlblnCuentaDescuentoValida = True
    vlblnAgregarTasa = True
    For i = 0 To UBound(DescuentosporTasaIVA())
        ' Si ya existe la tasa de IVA en el arreglo, acumula el descuento
        If DescuentosporTasaIVA(i).PorcentajeIVA = vlrelivaentrada And DescuentosporTasaIVA(i).Configurado = "S" Then
            DescuentosporTasaIVA(i).ImporteDescuento = DescuentosporTasaIVA(i).ImporteDescuento + vlmnyDescuento
            vlblnAgregarTasa = False
            Exit For
        End If
    Next i
    
    If vlblnAgregarTasa Then
        ' Busca la cuenta de descuento sobre compra que corresponde al número de proceso, departamento y tasa de IVA
        vllngCtaDescuentosCompra = 1
        frsEjecuta_SP vlintNumeroProceso & "|" & vgintNumeroDepartamento & "|" & vlrelivaentrada & "|" & vlintEmpresa, "FN_CnSelCuentaDescuentoCompra", True, vllngCtaDescuentosCompra
    
        vlblnEstaCuenta = False
        vlintTamaño = UBound(DescuentosporTasaIVA())
        For i = 0 To vlintTamaño
            ' Si la cuenta de descuento ya existe en el arreglo, aunque sea de otro departamento y/o tasa de IVA
            ' se acumula en el mismo movimiento contable
            If DescuentosporTasaIVA(i).CuentaDescuento = vllngCtaDescuentosCompra And vllngCtaDescuentosCompra <> 0 Then
                vlblnEstaCuenta = True
                vlintPosicion = i
            End If
        Next i
        If vlblnEstaCuenta Then
            DescuentosporTasaIVA(vlintPosicion).ImporteDescuento = DescuentosporTasaIVA(vlintPosicion).ImporteDescuento + vlmnyDescuento
        Else
            i = UBound(DescuentosporTasaIVA()) + 1
            ReDim Preserve DescuentosporTasaIVA(i)
            DescuentosporTasaIVA(i).PorcentajeIVA = vlrelivaentrada
            DescuentosporTasaIVA(i).ImporteDescuento = DescuentosporTasaIVA(i).ImporteDescuento + vlmnyDescuento
            If vllngCtaDescuentosCompra = 0 Then
                '¡No está registrada la cuenta para contabilizar los descuentos sobre compra!
                'MsgBox "No existe configurada para el departamento " & vgintNumeroDepartamento & " la cuenta contable para descuentos sobre compra "
                MsgBox SIHOMsg(846), vbOKOnly + vbExclamation, "Mensaje"
                vlblnCuentaDescuentoValida = False
                Exit Sub
            Else
                If Not fblnCuentaAfectable(fstrCuentaContable(vllngCtaDescuentosCompra), vlintEmpresa) Then
                    'La cuenta de descuentos no está activa.
                    MsgBox SIHOMsg(444), vbOKOnly + vbInformation, "Mensaje"
                    vlblnCuentaDescuentoValida = False
                    Exit Sub
                Else
                    DescuentosporTasaIVA(i).CuentaDescuento = vllngCtaDescuentosCompra
                    DescuentosporTasaIVA(i).Configurado = "S"
                End If
            End If
        End If
    End If

End Sub

Public Sub pRegresaDatosFacturaAnterior( _
      vlstrFacturaAnterior As String _
    , vlstrFacturaNueva As String _
    , vglngCveFacturaAnterior As Long _
    , vllngCveFacturaNueva As Long _
    , blnFacturaAutomatica As Boolean _
    , lngPersonaGraba As Long _
    , strTipoPacienteFactura As String _
    , vlintmovpaciente As Long _
    , vllngFormatoaUsar As Long _
    , intTipoDetalleFactura As Integer _
    , vgstrFacturaPacienteEmpresa As String _
    , lblnCalcularEnBaseACargos As Boolean _
    , optTipoPaciente0 As Boolean _
    , optTipoPaciente1 As Boolean _
    , txtMovimientoPaciente As String _
    , Optional QuitarPendienteTimbre As Boolean = True _
    , Optional Mostrarmensaje As Boolean = True _
    , Optional blnRefacturacion As Boolean = False _
    , Optional strError As String)

    Dim vlstrSentencia As String
    Dim vlintEstadoFacturado As Integer
    Dim rsTemp As New ADODB.Recordset
    Dim rsTemp2 As New ADODB.Recordset
    Dim intlineaGoto As Integer
    
    On Error GoTo NotificaError:
    
        '------------------------------------------------------------------------------------'
        '- Regresamos la información a la factura anterior, la factura nueva será cancelada -'
        '------------------------------------------------------------------------------------'
        
        'If Not optTipoPaciente(0).Value And Not optTipoPaciente(1).Value Then
        '   vlstrSentencia = "UPDATE PvFacturacionConsolidada SET chrFolioFactura = '" & Trim(Me.vlstrfacturaanterior) & "' WHERE INTCVEGRUPO = " & txtMovimientoPaciente.Text
        '   pEjecutaSentencia vlstrSentencia
        'End If
1        vlstrSentencia = "UPDATE PvCargoExcedente SET chrfoliofactura = '" & Trim(vlstrFacturaAnterior) & "'" & " WHERE chrfoliofactura = '" & vlstrFacturaNueva & "'"
2        pEjecutaSentencia vlstrSentencia
                            
3        vlstrSentencia = "UPDATE PvFacturaParcialEmpresa SET intFacturaEmpresa = '" & CStr(vglngCveFacturaAnterior) & "' "
4        vlstrSentencia = vlstrSentencia & "WHERE PvFacturaParcialEmpresa.intFacturaEmpresa = " & CStr(vllngCveFacturaNueva)
5        pEjecutaSentencia (vlstrSentencia)
                            
6        vlstrSentencia = "UPDATE PvFacturaPacienteConcepto SET chrFolioFactura = '" & Trim(vlstrFacturaAnterior)
7        vlstrSentencia = vlstrSentencia & "' WHERE PvFacturaPacienteConcepto.chrFolioFactura = '" & vlstrFacturaNueva & "'"
8        pEjecutaSentencia (vlstrSentencia)
                            
        '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        '||  A C T U A L I Z A   L A   F A C T U R A   D E   F A C T U R A S   P A R C I A L E S  ||'
        '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
9        vlstrSentencia = " SELECT PvFacturasParciales.INTFACTURABASE FROM PvFacturasParciales "
10       vlstrSentencia = vlstrSentencia & " WHERE PvFacturasParciales.INTFACTURABASE = " & vllngCveFacturaNueva
11       Set rsTemp = frsRegresaRs(vlstrSentencia)
        If rsTemp.RecordCount > 0 Then
            'Si es factura base
12            vlstrSentencia = " UPDATE PvFacturasParciales SET PvFacturasParciales.INTFACTURABASE = " & vglngCveFacturaAnterior & _
                             " WHERE PvFacturasParciales.INTFACTURABASE = " & vllngCveFacturaNueva
13            pEjecutaSentencia vlstrSentencia
        Else
14            vlstrSentencia = " SELECT PvFacturasParciales.INTFACTURAPARCIAL FROM PvFacturasParciales "
15            vlstrSentencia = vlstrSentencia & " WHERE PvFacturasParciales.INTFACTURAPARCIAL = " & vllngCveFacturaNueva
16            Set rsTemp = frsRegresaRs(vlstrSentencia)
            If rsTemp.RecordCount > 0 Then
               'Si es factura parcial
17               vlstrSentencia = " UPDATE PvFacturaParcialEmpresa SET PvFacturaParcialEmpresa.INTFACTURAPARCIAL = " & vglngCveFacturaAnterior & _
                                " WHERE PvFacturaParcialEmpresa.INTFACTURAPARCIAL =" & vllngCveFacturaNueva
18               pEjecutaSentencia vlstrSentencia
                    
19               vlstrSentencia = " UPDATE PvFacturasParciales SET PvFacturasParciales.INTFACTURAPARCIAL = " & vglngCveFacturaAnterior & _
                      " WHERE PvFacturasParciales.INTFACTURAPARCIAL = " & vllngCveFacturaNueva
20               pEjecutaSentencia vlstrSentencia
            End If
        End If
                            
21        vlstrSentencia = "UPDATE PvPago SET chrFolioFactura = '" & Trim(vlstrFacturaAnterior) & "' WHERE chrFolioFactura = '" & vlstrFacturaNueva & "'"
22        pEjecutaSentencia (vlstrSentencia)
                            
23        vlstrSentencia = "UPDATE PvSalidaDinero SET chrFolioFactura = '" & Trim(vlstrFacturaAnterior) & "' WHERE chrFolioFactura = '" & vlstrFacturaNueva & "'"
24        pEjecutaSentencia (vlstrSentencia)
                            
        If blnFacturaAutomatica Then
25           vlstrSentencia = "UPDATE PvVentaPublico SET bitFacturaAutomatica = 1 WHERE chrFolioFactura = '" & vlstrFacturaNueva & "' And chrTipoRecivo = 'T'"
26           pEjecutaSentencia vlstrSentencia
        End If
27        vlstrSentencia = "UPDATE PvVentaPublico SET CHRFOLIOTICKET = '" & Trim(vlstrFacturaAnterior) & "', chrFolioFactura = '" & Trim(vlstrFacturaAnterior) & "'" & _
                         " WHERE chrFolioFactura = '" & vlstrFacturaNueva & "' AND CHRTIPORECIVO = 'F'"
28        pEjecutaSentencia vlstrSentencia
29        vlstrSentencia = "UPDATE PvVentaPublico SET chrFolioFactura = '" & Trim(vlstrFacturaAnterior) & "' WHERE chrFolioFactura = '" & vlstrFacturaNueva & _
                         "' AND CHRTIPORECIVO = 'T'"
30        pEjecutaSentencia vlstrSentencia
                            
31        vlstrSentencia = "UPDATE CCMOVIMIENTOCREDITO SET BITCANCELADO = 0,DTMFECHACANCELACION = null Where Trim(CCMOVIMIENTOCREDITO.CHRFOLIOREFERENCIA) ='" & Trim(vlstrFacturaAnterior) & "' AND TRIM(CCMOVIMIENTOCREDITO.CHRTIPOREFERENCIA) = 'FA'"
32        pEjecutaSentencia vlstrSentencia
                            
33        vlstrSentencia = "UPDATE PvCargo SET chrFolioFactura = '" & RTrim(vlstrFacturaAnterior) & "' WHERE chrFolioFactura = '" & vlstrFacturaNueva & "'"
34        pEjecutaSentencia vlstrSentencia
        If vgstrFacturaPacienteEmpresa = "P" And lblnCalcularEnBaseACargos Then
35           vlstrSentencia = "UPDATE PvCargo SET chrFolioFacturaPaciente = '" & RTrim(vlstrFacturaAnterior) & "' WHERE chrFolioFacturaPaciente = '" & vlstrFacturaNueva & "'"
36           pEjecutaSentencia vlstrSentencia
        End If
                            
37        vlstrSentencia = _
               "UPDATE PVCONTROLASEGURADORA SET " & _
                   "CHRFOLIOFACTURADEDUCIBLE = CASE WHEN TRIM(CHRFOLIOFACTURADEDUCIBLE) = '" & vlstrFacturaNueva & "' THEN '" & Trim(vlstrFacturaAnterior) & "' ELSE CHRFOLIOFACTURADEDUCIBLE END " & _
                   ",CHRFOLIOFACTURACOASEGURO = CASE WHEN TRIM(CHRFOLIOFACTURACOASEGURO) = '" & vlstrFacturaNueva & "' THEN '" & Trim(vlstrFacturaAnterior) & "' ELSE CHRFOLIOFACTURACOASEGURO END " & _
                   ",CHRFOLIOFACTURACOPAGO = CASE WHEN TRIM(CHRFOLIOFACTURACOPAGO) = '" & vlstrFacturaNueva & "' THEN '" & Trim(vlstrFacturaAnterior) & "' ELSE CHRFOLIOFACTURACOPAGO END " & _
                   ",CHRFOLIOFACTURAEXCEDENTE = CASE WHEN TRIM(CHRFOLIOFACTURAEXCEDENTE) = '" & vlstrFacturaNueva & "' THEN '" & Trim(vlstrFacturaAnterior) & "' ELSE CHRFOLIOFACTURAEXCEDENTE END " & _
                   ",CHRFOLIOFACTURAEMPRESA = CASE WHEN TRIM(CHRFOLIOFACTURAEMPRESA) = '" & vlstrFacturaNueva & "' THEN '" & Trim(vlstrFacturaAnterior) & "' ELSE CHRFOLIOFACTURAEMPRESA END " & _
                   ",CHRFOLIOFACTURACOASEGUROADICI = CASE WHEN TRIM(CHRFOLIOFACTURACOASEGUROADICI) = '" & vlstrFacturaNueva & "' THEN '" & Trim(vlstrFacturaAnterior) & "' ELSE CHRFOLIOFACTURACOASEGUROADICI END " & _
               "WHERE " & _
                   "TRIM(CHRFOLIOFACTURADEDUCIBLE) = '" & vlstrFacturaNueva & "' OR TRIM(CHRFOLIOFACTURACOASEGURO) = '" & vlstrFacturaNueva & "' OR TRIM(CHRFOLIOFACTURACOPAGO) = '" & vlstrFacturaNueva & "' OR TRIM(CHRFOLIOFACTURAEXCEDENTE) = '" & vlstrFacturaNueva & "' OR TRIM(CHRFOLIOFACTURAEMPRESA) = '" & vlstrFacturaNueva & "'" & " OR TRIM(CHRFOLIOFACTURACOASEGUROADICI) = '" & vlstrFacturaNueva & "'"
38        pEjecutaSentencia vlstrSentencia
                            
39        vlstrSentencia = "Update CcNota Set vchFacturaImpresion = '" & Trim(vlstrFacturaAnterior) & "' Where vchFacturaImpresion = '" & vlstrFacturaNueva & "'"
40        pEjecutaSentencia (vlstrSentencia)
41        vlstrSentencia = "Update CcNotaFactura Set chrFolioFactura = '" & Trim(vlstrFacturaAnterior) & "' Where chrFolioFactura = '" & vlstrFacturaNueva & "'"
42        pEjecutaSentencia (vlstrSentencia)
43        vlstrSentencia = "Update CcNotaDetalle Set chrFolioFactura = '" & Trim(vlstrFacturaAnterior) & "' Where chrFolioFactura = '" & vlstrFacturaNueva & "'"
44        pEjecutaSentencia (vlstrSentencia)
                            
        '|______________________________________________________________________________________________________________________________________________|
        
        'pCancelarFactura Trim(vlstrFacturaNueva), lngPersonaGraba, "frmConsultaFactura", True, False, True
45        pCancelarFactura Trim(vlstrFacturaNueva), lngPersonaGraba, "frmConsultaFactura", QuitarPendienteTimbre, Mostrarmensaje, blnRefacturacion, Trim(vlstrFacturaAnterior)
        If Not optTipoPaciente0 And Not optTipoPaciente1 Then
46           vlstrSentencia = "UPDATE PvFacturacionConsolidada SET chrFolioFactura = '" & Trim(vlstrFacturaAnterior) & "' WHERE INTCVEGRUPO = " & txtMovimientoPaciente
47           pEjecutaSentencia vlstrSentencia
        End If
                                               
        'volvemos a poner la cuenta como facturada
        If strTipoPacienteFactura = "I" Or strTipoPacienteFactura = "E" Then
           '-----------------------------------------------------------'
           ' Contabilizar el numero de cargos sin factura en la cuenta '
           '-----------------------------------------------------------'
48           vlstrSentencia = "SELECT Count(intNumcargo) Cargos FROM PvCargo " & _
                         " WHERE intMovPaciente = " & vlintmovpaciente & _
                         " AND chrTipoPaciente = '" & strTipoPacienteFactura & "'" & _
                         " AND chrFolioFactura Is Null "
49           Set rsTemp = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
           If rsTemp!Cargos = 0 Then
              vlintEstadoFacturado = 1
           Else
              vlintEstadoFacturado = 0
           End If
           'Factura de una cuenta:
50           vgstrParametrosSP = vlintmovpaciente & "|" & strTipoPacienteFactura & "|" & vlintEstadoFacturado
51           frsEjecuta_SP vgstrParametrosSP, "SP_PVUPDCUENTAFACTURADA"
        Else
           If strTipoPacienteFactura = "G" Then
               'Factura de un grupo
52                Set rsTemp = frsEjecuta_SP(CStr(vlintmovpaciente), "SP_PVSELCUENTAGRUPO")
                Do While Not rsTemp.EOF
                   '-----------------------------------------------------------'
                   'Contabilizar el numero de cargos sin factura en la cuenta '
                   '-----------------------------------------------------------'
53                   vlstrSentencia = "SELECT Count(intNumcargo) Cargos FROM PvCargo " & _
                                    " WHERE intMovPaciente = " & rsTemp!INTMOVPACIENTE & _
                                    " AND chrTipoPaciente = '" & rsTemp!CHRTIPOPACIENTE & "'" & _
                                    " AND chrFolioFactura Is Null "
54                   Set rsTemp2 = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
                   If rsTemp2!Cargos = 0 Then
                      vlintEstadoFacturado = 1
                   Else
                      vlintEstadoFacturado = 0
                   End If
55                   vgstrParametrosSP = rsTemp!INTMOVPACIENTE & "|" & rsTemp!CHRTIPOPACIENTE & "|" & vlintEstadoFacturado
56                   frsEjecuta_SP vgstrParametrosSP, "SP_PVUPDCUENTAFACTURADA"
                   rsTemp.MoveNext
                Loop
           End If
        End If
        'Imprimimos la factura cancelada
57        fblnImprimeComprobanteDigital vllngCveFacturaNueva, "FA", "I", vllngFormatoaUsar, intTipoDetalleFactura
                  
58     intlineaGoto = 58  ' El mensaje de error se recibe por en el parámetro strError
       GoTo NotificaError
    
Exit Sub
NotificaError:
    If Err.Number <> 0 Then 'error de código
       If Erl() > 1 And Erl() < 57 Then 'hacer el rollback
          Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pRegresaDatosFacturaAnterior"), "Linea:" & Erl() & "|" & Left("(Se origina porque: " & strError & ", Factura: " & Trim(vlstrFacturaAnterior) & " por:" & Trim(vlstrFacturaNueva), 500) & ")", False)
       Else 'no hacer rollback
          frsEjecuta_SP Err.Number & "|" & Left(Err.Description, 200) & "|" & cgstrModulo & "|" & "pRegresaDatosFacturaAnterior" & " Linea:" & Erl() & "|" & "", "SP_GNINSREGISTROERRORES", True
       End If
    Else 'viene de un goto
          frsEjecuta_SP -1 & "|" & Left("No se puede completar la refacturación porque: " & strError, 200) & "|" & cgstrModulo & "|" & "pRegresaDatosFacturaAnterior" & " Linea:" & intlineaGoto & " Factura: " & Trim(vlstrFacturaAnterior) & " por:" & Trim(vlstrFacturaNueva) & "|" & "", "SP_GNINSREGISTROERRORES", True
    End If
    
End Sub

Public Function fblnObtenerConfigPolizanva(blnEsConceptoPoliza As Integer, strTipoChequeConfig As String, forma As String, Optional strValorMsgconfig As String) As Boolean
On Error GoTo NotificaError
    Dim rsConfigPoliza As ADODB.Recordset
    Dim intIndex As Integer
        
    fblnObtenerConfigPolizanva = True
    ReDim ConceptosPoliza(intIndex)
    
    Set rsConfigPoliza = frsRegresaRs("select * from CPConfigConceptoPoliza where chrTipocheque = '" & Trim(strTipoChequeConfig) & _
        "' and bitIncluirConceptoDetalle = " & blnEsConceptoPoliza & " order by intOrden")

    If Not rsConfigPoliza.EOF Then
        Do Until rsConfigPoliza.EOF
            ReDim Preserve ConceptosPoliza(intIndex)
            ConceptosPoliza(intIndex).tipo = rsConfigPoliza!vchCampo
            ConceptosPoliza(intIndex).Texto = IIf(IsNull(rsConfigPoliza!vchTexto), "", rsConfigPoliza!vchTexto)
            intIndex = intIndex + 1
            rsConfigPoliza.MoveNext
        Loop
    Else
        If blnEsConceptoPoliza = 0 Then
            If Left(SIHOMsg(1673), 30) <> "No se ha registrado el mensaje" Then
                fblnObtenerConfigPolizanva = False
                If forma = "frmCorte" Then
                    MsgBox IIf(Left(SIHOMsg(1673), 8) = "No se ha", SIHOMsg(1673) & "", SIHOMsg(1673) & "l corte de " & Trim(LCase(strValorMsgconfig)) & "."), vbExclamation, "Mensaje"
                End If
                If forma = "frmTransferencia" Then
                    MsgBox SIHOMsg(1673) & " transferencias a bancos.", vbExclamation, "Mensaje"
                End If
                If forma = "frmNotas" Then
                    MsgBox SIHOMsg(1673) & IIf(Trim(strTipoChequeConfig) = "W", " la nota de cargo al cliente.", IIf(strValorMsgconfig = True, " la nota de crédito al cliente.", " la nota de crédito al paciente.")), vbExclamation, "Mensaje"
                End If
            Else
                MsgBox SIHOMsg(1673), vbExclamation, "Mensaje"
                fblnObtenerConfigPolizanva = False
            End If
        Else
            If blnEsConceptoPoliza <> 1 And blnEsConceptoPoliza <> 2 Then
                MsgBox "no existe mensaje"
            Else
                fblnObtenerConfigPolizanva = False
            End If
        End If
    End If
    rsConfigPoliza.Close
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & ":fblnObtenerConfigPolizanva"))
End Function

Public Function fblnValidaCuentaPuenteBanco(intEmpresa As Integer) As Boolean
On Error GoTo NotificaError

    Dim rs As ADODB.Recordset
    Dim strSql As String
    Dim rsTemp As ADODB.Recordset
    Dim vlstrNombreConceptoPago As String
    '-----------------------------------------------------------------------------'
    ' Valida parámetros para usar la cuenta puente para abonos a cuentas de banco '
    '-----------------------------------------------------------------------------'
    
    fblnValidaCuentaPuenteBanco = True
    
    ' Regresa bit para validar cuenta puente a banco
    intBitCuentaPuenteBanco = 1
    frsEjecuta_SP CStr(intEmpresa) & "|" & "bitUtilizaCuentaPuenteBanco", "FN_PVSELBITPARAMETRO", True, intBitCuentaPuenteBanco
    ' Si intBitCuentaPuenteBanco = 0, no se usará la cuenta puente para abonos a cuentas de banco y se registrará la póliza de la cancelación como normalmente se hace
    ' Si intBitCuentaPuenteBanco = 1, si se usará la cuenta puente para abonos a cuentas de banco y enseguida se validan otros valores para su uso
    
    If intBitCuentaPuenteBanco = 1 Then
        ' Regresa valor de parámetro que indica la cuenta puente a banco
        If fblnValidaCuentaPuenteBanco Then
            lngCuentaPuenteBanco = 0
            Set rsTemp = frsSelParametros("CN", vgintClaveEmpresaContable, "INTNUMCUENTAPUENTEBANCO")
            If rsTemp.EOF Then
                'No se ha registrado la "Cuenta puente para abonos a cuentas de banco por cancelación y/o re facturación".
                MsgBox SIHOMsg(1327), vbOKOnly + vbInformation, "Mensaje"
                fblnValidaCuentaPuenteBanco = False
            Else
                lngCuentaPuenteBanco = IIf(IsNull(rsTemp!Valor), 0, CLng(rsTemp!Valor))
                If lngCuentaPuenteBanco = 0 Then
                    'No se ha registrado la "Cuenta puente para sustituir cuenta de banco al cancelar y/o re facturar".
                    MsgBox SIHOMsg(1327), vbOKOnly + vbInformation, "Mensaje"
                    fblnValidaCuentaPuenteBanco = False
                End If
            End If
            rsTemp.Close
        End If
        
        ' Verifica el estatus del concepto de pago que se generará automáticamente por la cancelación de la factura
        If fblnValidaCuentaPuenteBanco Then
            strSql = "select pvconceptopago.bitestatusactivo From pvconceptopago Where pvconceptopago.bitpagocancelafactura = 1"
            Set rsTemp = frsRegresaRs(strSql, adLockReadOnly, adOpenForwardOnly)
            If rsTemp.RecordCount > 0 Then
                If IsNull(rsTemp!bitestatusactivo) Or rsTemp!bitestatusactivo = 0 Then
                    'El concepto para generar pagos automáticos al cancelar facturas no está activo.
                    MsgBox SIHOMsg(1330), vbOKOnly + vbInformation, "Mensaje"
                    fblnValidaCuentaPuenteBanco = False
                End If
            Else
               'El concepto para generar pagos automáticos al cancelar facturas no está activo.
               MsgBox Replace(SIHOMsg(1330), "activo", "configurado"), vbOKOnly + vbInformation, "Mensaje"
               fblnValidaCuentaPuenteBanco = False
            End If
            rsTemp.Close
        End If
        
        ' Verifica la cuenta contable del concepto de pago que se generará automáticamente por la cancelación de la factura
        If fblnValidaCuentaPuenteBanco Then
            vlstrNombreConceptoPago = ""
            strSql = "select * From PvConceptoPago Where pvconceptopago.bitpagocancelafactura = 1"
            Set rsTemp = frsRegresaRs(strSql)
            If rsTemp.RecordCount <> 0 Then
                vlstrNombreConceptoPago = Trim(rsTemp!chrDescripcion)
            End If
            rsTemp.Close
        
            strSql = "select pvconceptopago.intnumconcepto, pvconceptopago.bitdesglosaiva, pvconceptopagoempresa.intnumerocuenta" & _
                      " From pvconceptopago, pvconceptopagoempresa Where pvconceptopago.bitpagocancelafactura = 1 " & _
                      "  and pvconceptopago.intnumconcepto = pvconceptopagoempresa.intnumconcepto and pvconceptopagoempresa.intcveempresa = " & intEmpresa
           
            Set rs = frsRegresaRs(strSql, adLockReadOnly, adOpenForwardOnly)
            If rs.RecordCount > 0 Then
                Set rsTemp = frsEjecuta_SP(CStr(rs!intNumeroCuenta), "Sp_CnSelCuentaContable")
                If rsTemp.RecordCount > 0 Then
                    If IsNull(rsTemp!bitEstatusActiva) Or rsTemp!bitEstatusActiva = 0 Then
                        'La cuenta contable para el concepto de pago X que se generará automáticamente al cancelar y/o re facturar, no está activa.
                        MsgBox "La cuenta contable para el concepto de pago " & vlstrNombreConceptoPago & " que se generará automáticamente al cancelar y/o re facturar, no está activa.", vbOKOnly + vbInformation, "Mensaje"
                        fblnValidaCuentaPuenteBanco = False
                    Else
                        If IsNull(rsTemp!Bitestatusmovimientos) Or rsTemp!Bitestatusmovimientos = 0 Then
                            'La cuenta contable para el concepto de pago X que se generará automáticamente al cancelar y/o re facturar, no acepta movimientos.
                            MsgBox "La cuenta contable para el concepto de pago " & vlstrNombreConceptoPago & ", que se generará automáticamente al cancelar y/o re facturar, no acepta movimientos.", vbOKOnly + vbInformation, "Mensaje"
                            fblnValidaCuentaPuenteBanco = False
                        End If
                    End If
                End If
                rsTemp.Close
            Else
                'No se ha registrado la cuenta contable para el concepto "X" el cuál se usará para generar el pago automático en favor del paciente
                MsgBox "No se ha registrado la cuenta contable para el concepto " & vlstrNombreConceptoPago & " el cuál se usará para generar el pago automático en favor del paciente.", vbInformation, "Mensaje"
                fblnValidaCuentaPuenteBanco = False
            End If
            rs.Close
        End If
        
        ' Regresa valores de la cuenta puente para abonos a cuentas de bancos
        If fblnValidaCuentaPuenteBanco Then
            Set rsTemp = frsEjecuta_SP(CStr(lngCuentaPuenteBanco), "Sp_CnSelCuentaContable")
            If rsTemp.RecordCount > 0 Then
                If IsNull(rsTemp!bitEstatusActiva) Or rsTemp!bitEstatusActiva = 0 Then
                    'La cuenta puente para sustituir cuenta de banco al cancelar y/o re facturar no está activa.
                    MsgBox SIHOMsg(1328), vbOKOnly + vbInformation, "Mensaje"
                    fblnValidaCuentaPuenteBanco = False
                Else
                    If IsNull(rsTemp!Bitestatusmovimientos) Or rsTemp!Bitestatusmovimientos = 0 Then
                        'La cuenta puente para sustituir cuenta de banco al cancelar y/o re facturar no acepta movimientos.
                        MsgBox SIHOMsg(1329), vbOKOnly + vbInformation, "Mensaje"
                        fblnValidaCuentaPuenteBanco = False
                    End If
                End If
            End If
            rsTemp.Close
        End If
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnValidaCuentaPuenteBanco"))
End Function


Public Function fblnCuentaRelacionadaConBancos(lngCuenta As Long) As Boolean
On Error GoTo NotificaError

    Dim rs As ADODB.Recordset
    Dim strSql As String
    
    '----------------------------------------------------------------'
    ' Verifica si la cuenta se encuentra relacionada con algún banco '
    '----------------------------------------------------------------'
    
    fblnCuentaRelacionadaConBancos = False
             
    If intBitCuentaPuenteBanco = 1 Then
        strSql = "select cncuenta.intnumerocuenta from cncuenta, cpbanco " & _
                 "where cncuenta.intNumeroCuenta = cpbanco.intNumeroCuenta and cncuenta.intnumerocuenta = " & lngCuenta
        Set rs = frsRegresaRs(strSql)
        If rs.RecordCount <> 0 Then
            fblnCuentaRelacionadaConBancos = True
        End If
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnCuentaRelacionadaConBancos"))
End Function


Public Function fintTipoAgrupacionFactura(lngConsecutivoFactura As Long) As Integer
Dim ObjRS As New ADODB.Recordset
Dim rsFactura As New ADODB.Recordset
Dim rsTipoPaciente As New ADODB.Recordset
Dim objSTR As String
Dim intTipoAgrupacionFactura As Integer
Dim intTipoPaciente As Integer
Dim lngCveFormato As Long
Dim llngFormatoaUsar As Long
Dim intTipoEmisionComprobante As Integer
Dim intTipoCFDFactura As Integer
Dim lngCveEmpresaPac As Integer

On Error GoTo NotificaError
'Procedimiento para obtener la agrupación de una factura que esta pendiente de timbre
    
    objSTR = "Select * from PVFACTURA where INTCONSECUTIVO =" & lngConsecutivoFactura
    Set rsFactura = frsRegresaRs(objSTR, adLockOptimistic)
    
    If rsFactura.RecordCount > 0 Then
       fintTipoAgrupacionFactura = IIf(IsNull(rsFactura!intTipoDetalleFactura), 0, rsFactura!intTipoDetalleFactura)
    Else
       fintTipoAgrupacionFactura = 0
    End If

    If fintTipoAgrupacionFactura = 0 Then ' NO SE ENCONTRO EL TIPO DEL DETALLE DE LA FACTURA, LO BUSCAMOS EN GNCOMPROBANTEFISCALDIGITAL
       
       objSTR = "Select INTTIPODETALLEFACTURA from gncomprobantefiscaldigital where INTCOMPROBANTE = " & lngConsecutivoFactura & " and CHRTIPOCOMPROBANTE ='FA'"
       Set ObjRS = frsRegresaRs(objSTR, adLockOptimistic)
       
       If ObjRS.RecordCount > 0 Then
          fintTipoAgrupacionFactura = ObjRS!intTipoDetalleFactura
       Else
          fintTipoAgrupacionFactura = 0
       End If
       
       If fintTipoAgrupacionFactura = 0 Then 'TRAEMOS EL PREDETERMINADO(Es un tiro)
          lngCveFormato = 1
          Select Case rsFactura!CHRTIPOPACIENTE
                Case "I", "E"
                    Set rsTipoPaciente = frsEjecuta_SP(rsFactura!INTMOVPACIENTE & "|0|" & rsFactura!CHRTIPOPACIENTE & "|" & vgintClaveEmpresaContable, "sp_PvSelDatosPaciente")
                    If Not rsTipoPaciente.EOF Then
                       intTipoPaciente = IIf(IsNull(rsTipoPaciente!tnyCveTipoPaciente), 0, rsTipoPaciente!tnyCveTipoPaciente)
                       lngCveEmpresaPac = IIf(IsNull(rsTipoPaciente!intcveempresa), 0, rsTipoPaciente!intcveempresa)
                       If rsFactura!chrTipoFactura = "P" Then
                          If lngCveEmpresaPac = 0 Then
                             frsEjecuta_SP vgintNumeroDepartamento & "|0|" & intTipoPaciente & "|" & rsFactura!CHRTIPOPACIENTE, "fn_PVSelFormatoFactura", True, lngCveFormato
                          Else
                             frsEjecuta_SP vgintNumeroDepartamento & "|" & lngCveEmpresaPac & "|" & intTipoPaciente & "|" & rsFactura!CHRTIPOPACIENTE, "fn_PVSelFormatoFactura2", True, lngCveFormato
                          End If
                       ElseIf rsFactura!chrTipoFactura = "E" Then
                            frsEjecuta_SP vgintNumeroDepartamento & "|" & rsFactura!intcveempresa & "|" & intTipoPaciente & "|" & rsFactura!CHRTIPOPACIENTE, "fn_PVSelFormatoFactura", True, lngCveFormato
                       Else
                           lngCveFormato = 0
                       End If
                    Else
                        lngCveFormato = 0
                    End If
                    rsTipoPaciente.Close
                Case "G"
                    frsEjecuta_SP vgintNumeroDepartamento & "|" & rsFactura!intcveempresa & "|0|G", "fn_PVSelFormatoFactura", True, lngCveFormato
                Case "V"
                    frsEjecuta_SP vgintNumeroDepartamento & "|0|0|E", "fn_PVSelFormatoFactura", True, lngCveFormato
                Case "C"
                    lngCveFormato = flngFormatoDepto(vgintNumeroDepartamento, 9, "*")
          End Select
          llngFormatoaUsar = lngCveFormato
               
          'Se valida en caso de no haber formato activo mostrar mensaje y cancelar transacción
          If llngFormatoaUsar = 0 Then
             'No se encontró un formato válido de factura.
             MsgBox SIHOMsg(373), vbCritical, "Mensaje"
             intTipoAgrupacionFactura = 0
             Exit Function
          End If

          'Se compara el tipo de folio con el tipo de formato a utilizar con la fn "fintTipoEmisionComprobante"
          '(intTipoEmisionComprobante: 0 = Error, 1 = Físico, 2 = Digital)
          intTipoEmisionComprobante = fintTipoEmisionComprobante("FA", llngFormatoaUsar)
          If intTipoEmisionComprobante = 1 Then        'FISICO
             'No se encontró un formato válido de factura.
              MsgBox SIHOMsg(373), vbCritical, "Mensaje"
              fintTipoAgrupacionFactura = 0
              Exit Function
          ElseIf intTipoEmisionComprobante = 2 Then    'DIGITAL
              'Se revisa el tipo de CFD de la Factura (0 = CFD, 1 = CFDi, 2 = Físico, 3 = Error)
               intTipoCFDFactura = fintTipoCFD("FA", llngFormatoaUsar)
               'Si aparece un error terminar la transacción
               If intTipoCFDFactura = 3 Then   'ERROR
                   'No se encontró un formato válido de factura.
                   MsgBox SIHOMsg(373), vbCritical, "Mensaje"
                   fintTipoAgrupacionFactura = 0
                   Exit Function
                End If
                
                'si es digital se cargan las opciones de agrupamiento predeterminadas
                'y se desactivan las que no tienen un archivo de Crystal Report activo
                objSTR = "select intTipoAgrupaDigital, vchDescripcionAgrupa1, vchDescripcionAgrupa2,vchDescripcionAgrupa3 from FORMATO where intNumeroFormato = " & llngFormatoaUsar
                Set ObjRS = frsRegresaRs(objSTR)
                
                If ObjRS.RecordCount > 0 Then
                   fintTipoAgrupacionFactura = IIf(IsNull(ObjRS!intTipoAgrupaDigital), 0, ObjRS!intTipoAgrupaDigital)
                Else
                   'No se encontró un formato válido de factura.
                   MsgBox SIHOMsg(373), vbCritical, "Mensaje"
                   fintTipoAgrupacionFactura = 0
                End If
          Else
            'No se encontró un formato válido de factura.
            MsgBox SIHOMsg(373), vbCritical, "Mensaje"
            fintTipoAgrupacionFactura = 0
          End If
       End If
    End If
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintTipoAgrupacionFactura"))
    
    fintTipoAgrupacionFactura = 0
End Function

Public Sub pAgregarMovArregloCorte(vllngCorte As Long, vllngPersonaGraba As Long, vlstrFolioDocumento As String, vlstrTipoDocumento As String, vllngCuentaContable As Long, vldblCantidad As Double, vlblnCargo As Boolean, vlStrFechaHora As String, vlintFormaPago As Long, vldblTipoCambio As Double, vlstrfolioCheque As String, vllngCorteDocto As Long, vlintTipoOperacion As Integer, vlstrFolioDocOriginaMov As String, vlstrTipoDocOriginaMov As String, Optional vlbolEsCredito As Boolean, Optional vlstrRFC As String, Optional vlstrBancoSAT As String, Optional vlstrBancoExtranjero As String, Optional vlstrCuentaBancaria As String, Optional vldtmFecha As Date, Optional vlstrTipoMovimientoPoliza As String)
    If vlintTipoOperacion = 0 Then
       'Reiniciamos el arreglo cuando la operación  = 0
       vlintElementosMovCorte = 0
       ReDim vlarrMovCorte(vlintElementosMovCorte)
    Else
       'procedimiento para agregar registros al arreglo de movimientos del corte
        ReDim Preserve vlarrMovCorte(vlintElementosMovCorte)
        vlarrMovCorte(vlintElementosMovCorte).vllngCorte = vllngCorte
        vlarrMovCorte(vlintElementosMovCorte).vllngPersonaGraba = vllngPersonaGraba
        vlarrMovCorte(vlintElementosMovCorte).vlstrFolioDocumento = vlstrFolioDocumento
        vlarrMovCorte(vlintElementosMovCorte).vlstrTipoDocumento = vlstrTipoDocumento
        vlarrMovCorte(vlintElementosMovCorte).vllngCuentaContable = vllngCuentaContable
        vlarrMovCorte(vlintElementosMovCorte).vldblCantidad = Round(vldblCantidad, 2)
        vlarrMovCorte(vlintElementosMovCorte).vlblnCargo = vlblnCargo
        vlarrMovCorte(vlintElementosMovCorte).vlStrFechaHora = vlStrFechaHora
        vlarrMovCorte(vlintElementosMovCorte).vlintFormaPago = vlintFormaPago
        vlarrMovCorte(vlintElementosMovCorte).vldblTipoCambio = vldblTipoCambio
        vlarrMovCorte(vlintElementosMovCorte).vlstrfolioCheque = vlstrfolioCheque
        vlarrMovCorte(vlintElementosMovCorte).vllngCorteDocto = vllngCorteDocto
        vlarrMovCorte(vlintElementosMovCorte).vlintTipoOperacion = vlintTipoOperacion
        vlarrMovCorte(vlintElementosMovCorte).vlblnSeExcluye = False 'por default al agregar se coloca en false
        vlarrMovCorte(vlintElementosMovCorte).vlstrFolioDocOriginaMov = vlstrFolioDocOriginaMov
        vlarrMovCorte(vlintElementosMovCorte).vlstrTipoDocOriginaMov = vlstrTipoDocOriginaMov

        vlarrMovCorte(vlintElementosMovCorte).vlbolEsCredito = vlbolEsCredito
        vlarrMovCorte(vlintElementosMovCorte).vlstrRFC = vlstrRFC
        vlarrMovCorte(vlintElementosMovCorte).vlstrBancoSAT = vlstrBancoSAT
        vlarrMovCorte(vlintElementosMovCorte).vlstrBancoExtranjero = vlstrBancoExtranjero
        vlarrMovCorte(vlintElementosMovCorte).vlstrCuentaBancaria = vlstrCuentaBancaria
        vlarrMovCorte(vlintElementosMovCorte).vldtmFecha = vldtmFecha
        vlarrMovCorte(vlintElementosMovCorte).vlstrTipoMovimiento = vlstrTipoMovimientoPoliza
    
        vlintElementosMovCorte = vlintElementosMovCorte + 1
    End If
End Sub

Public Sub pExcluirMovArregloCorte(vlstrFolioDocumento As String, vlstrTipoDocumento As String)
Dim contador As Integer
For contador = 0 To vlintElementosMovCorte - 1
    If vlarrMovCorte(contador).vlstrFolioDocOriginaMov = vlstrFolioDocumento _
   And vlarrMovCorte(contador).vlstrTipoDocOriginaMov = vlstrTipoDocumento _
   And vlarrMovCorte(contador).vlblnSeExcluye = False Then
       
       vlarrMovCorte(contador).vlblnSeExcluye = True
   
   End If
Next contador
End Sub

Public Sub pCambioFacturaTicket(vlstrFolioTicket As String)
''este procedimiento cambia los movimientos del corte referente a la factura automatica por los movimientos del un ticket
    Dim vlintcontador As Integer
    For vlintcontador = 0 To vlintElementosMovCorte - 1
        vlarrMovCorte(vlintcontador).vlstrFolioDocOriginaMov = vlstrFolioTicket
        vlarrMovCorte(vlintcontador).vlstrFolioDocumento = vlstrFolioTicket
        vlarrMovCorte(vlintcontador).vlstrTipoDocOriginaMov = "TI"
        vlarrMovCorte(vlintcontador).vlstrTipoDocumento = "TI"
    Next vlintcontador
End Sub

Public Function fRegistrarMovArregloCorte(vllngCorte As Long, Optional vlblnRegistraInfoExtra As Boolean) As Long
    Dim vlintcontador As Integer
    Dim vlstrParametros As String
    Dim vlrsDetalleCorte As New ADODB.Recordset
    Dim rs As New ADODB.Recordset
    Dim blnrsDetalleCorteBan As Boolean 'para indicar que el recordset ya fue inicializado
    Dim vllngCorteGrabando As Long
    Dim vllngCorteActual As Long
    Dim vllngCorteAUsar As Long 'este es el corte que debemos usar para guardar los movimientos
    Dim banblnCambiodeCorte As Boolean
    Dim strFolioDocumento As String 'para manejar el cambio del corte
    Dim vllngNumDetalleCorte As Long

On Error GoTo NotificaError
    
    fRegistrarMovArregloCorte = 0
    '--------------------------
    'Obtenemos el corte Actual
    '--------------------------
    vllngCorteActual = 1
    frsEjecuta_SP CStr(vgintNumeroDepartamento) & "|" & CStr(vglngNumeroEmpleado) & "|" & Trim("P"), "SP_GNSELNUMEROCORTE", True, vllngCorteActual
    '-------------------------------
    'Obtenemos el corte que usaremos
    '-------------------------------
    vllngCorteAUsar = IIf(vllngCorteActual <> vllngCorte, vllngCorteActual, vllngCorte)
    If vllngCorteActual <> vllngCorte Then banblnCambiodeCorte = True
    '-------------------
    'Bloqueamos el corte
    '-------------------
    vllngCorteGrabando = 1
    frsEjecuta_SP CStr(vllngCorteAUsar) & "|Grabando", "Sp_PvUpdEstatusCorte", 1, vllngCorteGrabando
    If vllngCorteGrabando <> 2 Then

       Exit Function
    End If
       
     strFolioDocumento = ""
     blnrsDetalleCorteBan = False
    '--------------------------------------------------
    'Recorremos el arreglo de los movmimentos del corte
    '--------------------------------------------------
    For vlintcontador = 0 To vlintElementosMovCorte - 1
        If vlarrMovCorte(vlintcontador).vlblnSeExcluye = False Then 'sólo los que no fueron excluidos
           Select Case vlarrMovCorte(vlintcontador).vlintTipoOperacion
                         '-------------------------------
                  Case 1 'inserta en el detalle del corte
                         '-------------------------------
                         '--------------------------------------------
                         'Iniciamos el recordset del detalle del corte
                         '--------------------------------------------
                         If Not blnrsDetalleCorteBan Then
                            Set vlrsDetalleCorte = frsRegresaRs("Select * from PVDetalleCorte where intConsecutivo = -1", adLockOptimistic, adOpenDynamic)
                                blnrsDetalleCorteBan = True
                         End If
                         '--------------------------------------------
                         'Agregamos el movimiento al detalle del corte
                         '--------------------------------------------
                         With vlrsDetalleCorte
                              .AddNew
                              !intNumCorte = vllngCorteAUsar
                              !intCveEmpleado = vlarrMovCorte(vlintcontador).vllngPersonaGraba
                              !dtmFechahora = Replace(vlarrMovCorte(vlintcontador).vlStrFechaHora, "'", "")
                              !chrFolioDocumento = vlarrMovCorte(vlintcontador).vlstrFolioDocumento
                              !chrTipoDocumento = vlarrMovCorte(vlintcontador).vlstrTipoDocumento
                              !intFormaPago = vlarrMovCorte(vlintcontador).vlintFormaPago
                              !mnyCantidadPagada = vlarrMovCorte(vlintcontador).vldblCantidad
                              !mnytipocambio = vlarrMovCorte(vlintcontador).vldblTipoCambio
                              !intfoliocheque = vlarrMovCorte(vlintcontador).vlstrfolioCheque
                              !intNumCorteDocumento = vlarrMovCorte(vlintcontador).vllngCorteDocto
                              .Update
                              
                              If vlblnRegistraInfoExtra Then
                                  vllngNumDetalleCorte = flngObtieneIdentity("SEC_PVDETALLECORTE", vlrsDetalleCorte!intConsecutivo)
                                                      
                                  If Not vlarrMovCorte(vlintcontador).vlbolEsCredito Then
                                      If Trim(vlarrMovCorte(vlintcontador).vlstrRFC) <> "" And Trim(vlarrMovCorte(vlintcontador).vlstrBancoSAT) <> "" Then
                                          frsEjecuta_SP vlarrMovCorte(vlintcontador).vllngCorteDocto & "|" & vllngNumDetalleCorte & "|'" & Trim(vlarrMovCorte(vlintcontador).vlstrRFC) & "'|'" & Trim(vlarrMovCorte(vlintcontador).vlstrBancoSAT) & "'|'" & Trim(vlarrMovCorte(vlintcontador).vlstrCuentaBancaria) & "'|'" & IIf(Trim(vlarrMovCorte(vlintcontador).vlstrCuentaBancaria) = "", Null, fstrFechaSQL(Trim(vlarrMovCorte(vlintcontador).vldtmFecha))) & "'|'" & Trim(vlarrMovCorte(vlintcontador).vlstrBancoExtranjero) & "'", "SP_PVINSCORTECHEQUETRANSCTA"
                                      End If
                                  End If
                              End If
                        End With
                         '------------------------------
                  Case 2 'inserta en la poliza del corte
                         '------------------------------
                          pInsCortePoliza vllngCorteAUsar, _
                                          vlarrMovCorte(vlintcontador).vlstrFolioDocumento, _
                                          vlarrMovCorte(vlintcontador).vlstrTipoDocumento, _
                                          vlarrMovCorte(vlintcontador).vllngCuentaContable, _
                                          vlarrMovCorte(vlintcontador).vldblCantidad, _
                                          vlarrMovCorte(vlintcontador).vlblnCargo, _
                                          vlarrMovCorte(vlintcontador).vlstrTipoMovimiento
                         '-----------------------
                  Case 3 'cancela doc en el corte
                         '-----------------------
                         vlstrParametros = vlarrMovCorte(vlintcontador).vlstrFolioDocumento & "|" & _
                                           vlarrMovCorte(vlintcontador).vllngPersonaGraba & "|" & _
                                           vlarrMovCorte(vlintcontador).vlstrTipoDocumento & "|" & _
                                           vlarrMovCorte(vlintcontador).vllngCorteDocto & "|" & _
                                           vllngCorteAUsar
                         frsEjecuta_SP vlstrParametros, "sp_PvUpdCancelaDoctoCorte"
                         '-------------------------------------------------------------------------------------------------------
                  Case 4 'Inserta poliza de cancelación especificamente de una factura, se usa en la cancelacion de las facturas
                         '-------------------------------------------------------------------------------------------------------
                         frsEjecuta_SP vllngCorteAUsar & "|" & vlarrMovCorte(vlintcontador).vlstrFolioDocumento, "Sp_PvInsPolizaCancelaFactura"
                  
                  Case 5 '-------------------------------------------'
                         ' Creación de la nueva factura, SOLO POLIZA refacturación'
                         '-------------------------------------------'
                         frsEjecuta_SP vlarrMovCorte(vlintcontador).vlstrFolioDocOriginaMov & "|" & vlarrMovCorte(vlintcontador).vlstrFolioDocumento & "|" & vllngCorteAUsar, "SP_PVINSPOLIZAFACTURA"
                  
                  Case 6 '----------------------------------------'
                         ' Cancelación de la factura, SOLO POLIZA '
                         '----------------------------------------'
                         frsEjecuta_SP vllngCorteAUsar & "|" & vlarrMovCorte(vlintcontador).vlstrFolioDocumento & "|" & vlarrMovCorte(vlintcontador).vlstrFolioDocOriginaMov & "|" & vlarrMovCorte(vlintcontador).vlstrTipoDocumento, "Sp_PvInsPolizaCancelaFactura"
           End Select
        End If
    Next vlintcontador
    
    If blnrsDetalleCorteBan Then
       vlrsDetalleCorte.Close 'por si las moscas
    End If
    
    'libera el corte
    pLiberaCorte (vllngCorteAUsar)
    
    fRegistrarMovArregloCorte = vllngCorteAUsar
         
Exit Function
NotificaError:
    'libera el corte
    pLiberaCorte (vllngCorteAUsar)
    fRegistrarMovArregloCorte = 0
    
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fRegistrarMovArregloCorte"))
End Function

Public Sub pMarcarPendienteTimbre(lngIdComprobante As Long, strTipoComprobante As String, intNoDepartamento As Integer)
On Error GoTo NotificaError
    Dim strSentencia As String
1    strSentencia = "Insert into GNPENDIENTESTIMBREFISCAL (INTCOMPROBANTE,CHRTIPOCOMPROBANTE,SMICVEDEPARTAMENTO,DTMFECHAHORA) " & _
                    "Values (" & lngIdComprobante & ",'" & strTipoComprobante & "'," & intNoDepartamento & "," & fstrFechaSQL(fdtmServerFecha, fdtmServerHora, False) & ")"
2    pEjecutaSentencia strSentencia
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEliminarPendientesTimbre" & " Linea:" & Erl()), strSentencia, False)
    Err.Clear
End Sub

Public Function flngRegistroFolio(vlstrTipoDocto As String, vllngIdDocto As Long) As Long
    Dim strSql As String
    Dim rsTemp As Recordset
 On Error GoTo NotificaError
    strSql = ""
    flngRegistroFolio = 0
    If vlstrTipoDocto = "FA" Then
       strSql = "SELECT nvl(INTCVEREGISTRO,0) REG " & _
                "FROM PVFACTURA INNER JOIN REGISTROFOLIO ON (TRIM(REGISTROFOLIO.CHRCVEDOCUMENTO) = PVFACTURA.VCHSERIE) " & _
                "AND (PVFACTURA.INTFOLIO BETWEEN REGISTROFOLIO.INTNUMEROINICIAL AND REGISTROFOLIO.INTNUMEROFINAL) " & _
                "AND (REGISTROFOLIO.SMIDEPARTAMENTO = PVFACTURA.SMIDEPARTAMENTO) " & _
                "WHERE CHRTIPODOCUMENTO = 'FA' AND PVFACTURA.INTCONSECUTIVO = " & vllngIdDocto
    ElseIf vlstrTipoDocto = "CA" Or vlstrTipoDocto = "CR" Then
        strSql = "SELECT nvl(INTCVEREGISTRO,0) REG " & _
                "FROM CCNOTA INNER JOIN REGISTROFOLIO ON (TRIM(REGISTROFOLIO.CHRCVEDOCUMENTO) = TRIM(CCNOTA.CHRSERIE)) " & _
                "AND (TO_NUMBER(CCNOTA.CHRFOLIO) BETWEEN REGISTROFOLIO.INTNUMEROINICIAL AND REGISTROFOLIO.INTNUMEROFINAL) " & _
                "AND (REGISTROFOLIO.SMIDEPARTAMENTO = CCNOTA.SMICVEDEPARTAMENTO) " & _
                "WHERE CHRTIPODOCUMENTO = CASE WHEN CCNOTA.CHRTIPO='CA' THEN 'NA' ELSE 'NC' END AND CCNOTA.INTCONSECUTIVO  =" & vllngIdDocto
    ElseIf vlstrTipoDocto = "DO" Then
        strSql = "SELECT nvl(INTCVEREGISTRO,0) REG " & _
                 "FROM GNCOMPROBANTEFISCALDIGITAL " & _
                 "INNER JOIN REGISTROFOLIO ON (TRIM(REGISTROFOLIO.CHRCVEDOCUMENTO) = TRIM(GNCOMPROBANTEFISCALDIGITAL.VCHSERIECOMPROBANTE)) " & _
                 "AND (TO_NUMBER(GNCOMPROBANTEFISCALDIGITAL.VCHFOLIOCOMPROBANTE) BETWEEN REGISTROFOLIO.INTNUMEROINICIAL AND REGISTROFOLIO.INTNUMEROFINAL) " & _
                 "AND REGISTROFOLIO.CHRTIPODOCUMENTO = 'DO'" & _
                 "WHERE GNCOMPROBANTEFISCALDIGITAL.INTIDCOMPROBANTE = " & vllngIdDocto
    End If
    
    If strSql <> "" Then
       Set rsTemp = frsRegresaRs(strSql, adLockOptimistic)
       If rsTemp.RecordCount > 0 Then
          flngRegistroFolio = rsTemp!REG
        End If
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngRegistroFolio"))
    
    flngRegistroFolio = 0
End Function

Public Function fintAnoAprobacion(vlngRegistro As Long) As Integer
Dim ObjRS As New ADODB.Recordset
On Error GoTo NotificaError
    fintAnoAprobacion = 0
    Set ObjRS = frsRegresaRs("Select NVL(to_char(DTMFECHAAPROBACION, 'yyyy'), 0) ANOAPROBACION from REGISTROFOLIO where INTCVEREGISTRO = " & vlngRegistro, adLockOptimistic)
    If ObjRS.RecordCount > 0 Then
       If Not IsNull(ObjRS!ANOAPROBACION) Then
          fintAnoAprobacion = CInt(ObjRS!ANOAPROBACION)
       End If
    End If
    Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintAnoAprobacion"))
    
    fintAnoAprobacion = 0
End Function

Public Function fStrNumeroAprobacion(vlngRegistro As Long) As String
Dim ObjRS As New ADODB.Recordset
On Error GoTo NotificaError
    fStrNumeroAprobacion = ""
    Set ObjRS = frsRegresaRs("Select NVL(trim(VCHNUMAPROBACION),' ') NUMAPROBACION from REGISTROFOLIO where INTCVEREGISTRO = " & vlngRegistro, adLockOptimistic)
    If ObjRS.RecordCount > 0 Then
       If Not IsNull(ObjRS!NUMAPROBACION) Then
          fStrNumeroAprobacion = ObjRS!NUMAPROBACION
       End If
    End If
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fStrNumeroAprobacion"))
    
    fStrNumeroAprobacion = ""
End Function

Public Function fblnTCFDi(vlngRegistro As Long) As Boolean
Dim ObjRS As New ADODB.Recordset
On Error GoTo NotificaError
    fblnTCFDi = True
    Set ObjRS = frsRegresaRs("Select BITCFDI from REGISTROFOLIO where INTCVEREGISTRO = " & vlngRegistro, adLockOptimistic)
    If ObjRS.RecordCount > 0 Then
       If Not IsNull(ObjRS!BitCFDi) Then
          fblnTCFDi = IIf(ObjRS!BitCFDi = 1, True, False)
       End If
    End If
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnTCFDi"))
    
    fblnTCFDi = True 'lo dejamos marcado como CFDI
End Function

Public Function fstrErrorFirmaSAT(lngErrorFirmaSAT As Long) As String

Dim lngError As Long

lngError = lngErrorFirmaSAT * -1

fstrErrorFirmaSAT = ""

    Select Case lngError
        Case 1
            fstrErrorFirmaSAT = "No se puede abrir el archivo de entrada"
        Case 2
            fstrErrorFirmaSAT = "No se puede crear el archivo de salida"
        Case 3
            fstrErrorFirmaSAT = "Error de lectura del archivo"
        Case 4
            fstrErrorFirmaSAT = "Error de escritura del archivo"
        Case 5
            fstrErrorFirmaSAT = "No hay suficiente memoria"
        Case 6
            fstrErrorFirmaSAT = "Parametro es incorrecto o faltante"
        Case 7
            fstrErrorFirmaSAT = "El formato de los datos es incorrecto"
        Case 8
            fstrErrorFirmaSAT = "La información no es valida"
        Case 9
            fstrErrorFirmaSAT = "Fin inesperado del archivo encontrado"
        Case 15
            fstrErrorFirmaSAT = "Error de descifrado, revise el archivo de la llave .KEY y la contraseña de descifrado"
        Case 16
            fstrErrorFirmaSAT = "Falta datos requeridos"
        Case 17
            fstrErrorFirmaSAT = "Opción no válida"
        Case 19
            fstrErrorFirmaSAT = "Algoritmo o la versión no soportada"
        Case 20
            fstrErrorFirmaSAT = "No se han encontrado datos para procesar"
        Case 21
            fstrErrorFirmaSAT = "Error de descifrado, revise el archivo del certificado .CER de descifrado"
        Case 22
            fstrErrorFirmaSAT = "Sello inválido o faltante"
        Case 23
            fstrErrorFirmaSAT = "Error en la auto-prueba de integridad"
        Case 26
            fstrErrorFirmaSAT = "Error de longitud de dato(s)"
        Case 27
            fstrErrorFirmaSAT = "Formato inválido de XML"
        Case 28
            fstrErrorFirmaSAT = "Restricción violada en el archivo XML"
        Case 29
            fstrErrorFirmaSAT = "Error al ejecutar una consulta del complemento de sellado"
        Case 30
            fstrErrorFirmaSAT = "Insuficiencia del buffer de salida"
        Case 101
            fstrErrorFirmaSAT = "Certificado X.509 inválido"
        Case 102
            fstrErrorFirmaSAT = "Error interno del analizador del XML"
        Case 103
            fstrErrorFirmaSAT = "Error interno del validador del XML"
        Case 104
            fstrErrorFirmaSAT = "Archivo .DTD inválido"
        Case 9999
            fstrErrorFirmaSAT = "Error no controlado por el complemento de sellado de XML"
    End Select

    'Si no se cachó ningún error...
    If fstrErrorFirmaSAT = "" Then
        fstrErrorFirmaSAT = satErrorLookup(lngErrorFirmaSAT) 'Errores no controlados por esta función
    End If

    'Si no se encontró nada, mostrar error genérico
    If fstrErrorFirmaSAT = "" Then
        fstrErrorFirmaSAT = "Error no controlado"
    Else
        If Trim(satLastError) <> "" Then
            fstrErrorFirmaSAT = fstrErrorFirmaSAT & Chr(13) & Chr(13) & "Error FirmaSAT:" & Chr(13) & satLastError
        End If
    End If
End Function

Public Function ConvertAddressToString(longAddr As Long) As String
Dim myByte(3) As Byte
Dim Cnt As Long
CopyMemory myByte(0), longAddr, 4
For Cnt = 0 To 3
ConvertAddressToString = ConvertAddressToString + CStr(myByte(Cnt)) + "."
Next Cnt
ConvertAddressToString = Left$(ConvertAddressToString, Len(ConvertAddressToString) - 1)
End Function

Public Function GetWanIP() As String
Dim ret As Long, Tel As Long
Dim bBytes() As Byte
Dim TempList() As String
Dim TempIP As String
Dim Tempi As Long
Dim Listing As MIB_IPADDRTABLE
Dim L3 As String
On Error GoTo END1
GetIpAddrTable ByVal 0&, ret, True
If ret <= 0 Then Exit Function
ReDim bBytes(0 To ret - 1) As Byte
ReDim TempList(0 To ret - 1) As String
GetIpAddrTable bBytes(0), ret, False
CopyMemory Listing.dEntrys, bBytes(0), 4
For Tel = 0 To Listing.dEntrys - 1
CopyMemory Listing.mIPInfo(Tel), bBytes(4 + (Tel * Len(Listing.mIPInfo(0)))), Len(Listing.mIPInfo(Tel))
TempList(Tel) = ConvertAddressToString(Listing.mIPInfo(Tel).dwAddr)
Next Tel
TempIP = TempList(0)
For Tempi = 0 To Listing.dEntrys - 1
L3 = Left(TempList(Tempi), 3)
If L3 <> "169" And L3 <> "127" And L3 <> "192" Then
TempIP = TempList(Tempi)
End If
Next Tempi
GetWanIP = TempIP
Exit Function
END1:
GetWanIP = ""
End Function

Public Sub ObtenerPCIP()

Dim dwLen As Long
Dim strString As String

dwLen = MAX_COMPUTERNAME_LENGTH + 1
strString = String(dwLen, "X")
GetComputerName strString, dwLen
strString = Left(strString, dwLen)
vgstrNombreMaquina = strString
vgstrNumeroIP = GetWanIP

End Sub

Public Sub pErrorGeneraCFD(intErrorDefault As Integer, strError As String, blnMostrarMsj As Boolean)

    If blnMostrarMsj Then
        MsgBox SIHOMsg(1) & "." & vbNewLine & vbNewLine & SIHOMsg(intErrorDefault) & IIf(strError = "", "", vbNewLine & vbNewLine & "- " & strError & "."), vbCritical, "Mensaje"
    End If
    
End Sub

Public Sub pEstatusReqMaestro(vllngNumReq As Long)
    '---------------------------------------------------------------------------------
    ' Procedimiento para actualizar el estatus de la requisicion en la tabla
    ' IvRequisicionMaestro, según los estatus de los artículos en IvRequisicionDetalle
    '---------------------------------------------------------------------------------
    Dim vlstrx As String
    Dim EstatusMaestro As String
    Dim TipoRequisicion As String
    Dim TotArtRequis As Integer
    Dim TotArtRequisCancelados As Integer
    Dim TotArtRequisPendientes As Integer
    Dim TotArtRequisSurtidos As Integer
    Dim TotArtRequisSurtidosParcial As Integer
    Dim TotArtRequisAutorizados As Integer
    Dim TotArtRequisNoAutorizados As Integer
    Dim TotArtRequisCotizados As Integer
    Dim TotArtRequisOrdenados As Integer
    Dim TotArtRequisOrdenadosParcial As Integer
    Dim TotArtRequisRecibidos As Integer
    Dim TotArtRequisRecibidosParcial As Integer
    Dim rsTemp As Recordset

    EstatusMaestro = " "

    
    vlstrx = "select chrDestino from IvRequisicionMaestro where numNumRequisicion=" & str(vllngNumReq)
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TipoRequisicion = rsTemp.Fields(0)
    End If
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq)
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequis = rsTemp.Fields(0)
    End If
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion= " & str(vllngNumReq) & " and vchEstatusDetRequis='CANCELADA'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisCancelados = rsTemp.Fields(0)
    End If
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='PENDIENTE'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisPendientes = rsTemp.Fields(0)
    End If
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='SURTIDA'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisSurtidos = rsTemp.Fields(0)
    End If
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='SURTIDA PARCIAL'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisSurtidosParcial = rsTemp.Fields(0)
    End If
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='AUTORIZADA' "
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisAutorizados = rsTemp.Fields(0)
    End If
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='NO AUTORIZADA'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisNoAutorizados = rsTemp.Fields(0)
    End If
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='COTIZADA'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisCotizados = rsTemp.Fields(0)
    End If
    

    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='ORDENADA'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisOrdenados = rsTemp.Fields(0)
    End If
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='ORDENADA PARCIAL'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisOrdenadosParcial = rsTemp.Fields(0)
    End If
    
    
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='RECIBIDA'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisRecibidos = rsTemp.Fields(0)
    End If
       
    vlstrx = " select count(*) from IvRequisicionDetalle where numNumRequisicion=" & str(vllngNumReq) & " and vchEstatusDetRequis='RECIBIDA PARCIAL'"
    Set rsTemp = frsRegresaRs(vlstrx, adLockReadOnly, adOpenDynamic)
    If Not rsTemp.BOF And Not rsTemp.EOF Then
        TotArtRequisRecibidosParcial = rsTemp.Fields(0)
    End If
    
    
    
    If TotArtRequis = TotArtRequisCancelados Then
            EstatusMaestro = "CANCELADA"
    Else
        If TotArtRequis = TotArtRequisPendientes + TotArtRequisCancelados Then
            EstatusMaestro = "PENDIENTE"
        Else
            If TotArtRequis = TotArtRequisNoAutorizados + TotArtRequisCancelados Then
                EstatusMaestro = "NO AUTORIZADA"
            Else
                If TotArtRequisRecibidosParcial >= 1 Then
                    EstatusMaestro = "RECIBIDA PARCIAL"
                Else
                    If TotArtRequis = TotArtRequisRecibidos + TotArtRequisCancelados + TotArtRequisNoAutorizados Then
                        EstatusMaestro = "RECIBIDA"
                    Else
                        If TotArtRequisRecibidos >= 1 Then
                            EstatusMaestro = "RECIBIDA PARCIAL"
                        Else
                            If TotArtRequis = TotArtRequisCotizados + TotArtRequisCancelados + TotArtRequisNoAutorizados Then
                                EstatusMaestro = "COTIZADA"
                            Else
                                If TotArtRequisCotizados >= 1 Then
                                    EstatusMaestro = "COTIZADA PARCIAL"
                                Else
                                    If TotArtRequis = TotArtRequisOrdenados + TotArtRequisCancelados + TotArtRequisNoAutorizados Then
                                        EstatusMaestro = "ORDENADA"
                                    Else
                                        If TotArtRequisPendientes + TotArtRequisOrdenadosParcial >= 1 Then
                                            EstatusMaestro = "ORDENADA PARCIAL"
                                        Else
                                            If TotArtRequis = TotArtRequisAutorizados + TotArtRequisCancelados Then
                                                EstatusMaestro = "AUTORIZADA"
                                            Else
                                                If TotArtRequisAutorizados >= 1 Then
                                                    EstatusMaestro = "AUTORIZADA PARCIAL"
                                                End If
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End If
    
    vlstrx = " update IvRequisicionMaestro set " & _
             " vchEstatusRequis= '" & EstatusMaestro & _
            "' Where " & _
            "numNumRequisicion= " & str(vllngNumReq)
    
    pEjecutaSentencia vlstrx
    
End Sub
Public Function fblRevisaUsoSocios() As Boolean
'-----------------------------------------------------------------------
'Función que verifica si se hace uso de socios en el sistema   |
'-----------------------------------------------------------------------

Dim strSql As String
Dim rs As New ADODB.Recordset

'Revisa el parámetro de socios para saber si utiliza socios o no
    strSql = "select vchvalor from siparametro where trim(vchnombre) = 'BITUTILIZASOCIOS'"
    Set rs = frsRegresaRs(strSql, adLockOptimistic, adOpenDynamic)
    If rs.RecordCount > 0 Then
        If rs!VCHVALOR = "1" Then
            fblRevisaUsoSocios = True
        Else
            fblRevisaUsoSocios = False
        End If
        rs.Close
    End If
    
End Function
Public Function fblVerificaSocio(strCuenta As String, strTipoPaciente As String) As Boolean
'-----------------------------------------------------------------------
'Función que verifica si se hace uso de socios en el sistema   |
'-----------------------------------------------------------------------

Dim strSql As String
Dim rs As New ADODB.Recordset

'Revisa si el paciente es un socio
    strSql = "Select ex.INTCVETIPOPACIENTE as tipo from expacienteingreso ex inner join sitipoingreso si on si.INTCVETIPOINGRESO = ex.INTCVETIPOINGRESO and trim(si.CHRTIPOINGRESO) = '" & strTipoPaciente & "' and ex.INTNUMCUENTA = " & strCuenta
    Set rs = frsRegresaRs(strSql, adLockOptimistic, adOpenDynamic)
    If rs.RecordCount > 0 Then
        If Val(rs!tipo) = flngTipoPacienteSocio Then
            fblVerificaSocio = True
        Else
            fblVerificaSocio = False
        End If
        rs.Close
    End If
    
End Function
Public Function flngTipoPacienteSocio() As Long
'-------------------------------------------------------------------------------
'Función que consulta el tipo de paciente configurado como socio   |
'-------------------------------------------------------------------------------

Dim strSql As String
Dim rs As New ADODB.Recordset

'Revisa el parámetro de socios para saber si utiliza socios o no
    strSql = "select vchvalor from siparametro where trim(vchnombre) = 'INTCVETIPOPACIENTESOCIO'"
    Set rs = frsRegresaRs(strSql, adLockOptimistic, adOpenDynamic)
    If rs.RecordCount > 0 Then
        flngTipoPacienteSocio = Val(IIf(IsNull(rs!VCHVALOR), 0, rs!VCHVALOR))
        rs.Close
    End If
    
End Function

Public Function flngExisteDatoColVsf(vsfGrid As VSFlexGrid, intColumna As Integer, strDato As String) As Long
'--------------------------------------------------------------------------------------
' Función que busca en una columna de un VSFlexGrid un dato, regresa el reglón donde fue encontrado
' -1 indica que no se encontró
'--------------------------------------------------------------------------------------
' vsfGrid       = objeto VSFlexGrid en el que se bucará
' intColumna    = Número de columna en la que se busca
' strDato       = Dato a buscar
'--------------------------------------------------------------------------------------
    Dim lngRenglon As Long

    flngExisteDatoColVsf = -1
    
    With vsfGrid
        lngRenglon = 1
        Do While lngRenglon <= vsfGrid.Rows - 1 And flngExisteDatoColVsf = -1
            If Trim(vsfGrid.TextMatrix(lngRenglon, intColumna)) = Trim(strDato) Then
                flngExisteDatoColVsf = lngRenglon
            End If
            lngRenglon = lngRenglon + 1
        Loop
    End With
    
End Function

Public Function UnsignedToLong(Value As Double) As Long
    '
    'The function takes a Double containing a value in the 
    'range of an unsigned Long and returns a Long that you 
    'can pass to an API that requires an unsigned Long
    '
    If Value < 0 Or Value >= OFFSET_4 Then Error 6 ' Overflow
    '
    If Value <= MAXINT_4 Then
        UnsignedToLong = Value
    Else
        UnsignedToLong = Value - OFFSET_4
    End If
    '
End Function

Public Function LongToUnsigned(Value As Long) As Double
    '
    'The function takes an unsigned Long from an API and 
    'converts it to a Double for display or arithmetic purposes
    '
    If Value < 0 Then
        LongToUnsigned = Value + OFFSET_4
    Else
        LongToUnsigned = Value
    End If
    '
End Function

Public Function UnsignedToInteger(Value As Long) As Integer
    '
    'The function takes a Long containing a value in the range 
    'of an unsigned Integer and returns an Integer that you 
    'can pass to an API that requires an unsigned Integer
    '
    If Value < 0 Or Value >= OFFSET_2 Then Error 6 ' Overflow
    '
    If Value <= MAXINT_2 Then
        UnsignedToInteger = Value
    Else
        UnsignedToInteger = Value - OFFSET_2
    End If
    '
End Function

Public Function IntegerToUnsigned(Value As Integer) As Long
    '
    'The function takes an unsigned Integer from and API and 
    'converts it to a Long for display or arithmetic purposes
    '
    If Value < 0 Then
        IntegerToUnsigned = Value + OFFSET_2
    Else
        IntegerToUnsigned = Value
    End If
    '
End Function

Public Function StringFromPointer(ByVal lPointer As Long) As String
    '
    Dim strTemp As String
    Dim lRetVal As Long
    '
    'prepare the strTemp buffer
    strTemp = String$(lstrlen(ByVal lPointer), 0)
    '
    'copy the string into the strTemp buffer
    lRetVal = lstrcpy(ByVal strTemp, ByVal lPointer)
    '
    'return a string
    If lRetVal Then StringFromPointer = strTemp
    '
End Function

Public Sub pEnfocaOpt(optObject As Object)
    On Error GoTo NotificaError
    Dim vllngContador As Long

    If TypeOf optObject Is OptionButton Then
      If fblnCanFocus(optObject) Then optObject.SetFocus
    Else
      For vllngContador = 0 To optObject.Count - 1
        If optObject(vllngContador).Value Then
          If fblnCanFocus(optObject(vllngContador)) Then optObject(vllngContador).SetFocus
        End If
      Next vllngContador
    End If

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEnfocaOpt"))
End Sub

Public Function fstrDameConexionSIHO() As String
Dim vlStrConexion As String
  fstrDameConexionSIHO = ""
  With EntornoSIHO.ConeccionSIHO.Properties
    .Refresh
    vlStrConexion = ""
    vlStrConexion = "DSN = " & .Item("Data Source")
    vlStrConexion = vlStrConexion & ";UID = " & .Item("User ID")
    vlStrConexion = vlStrConexion & ";PWD = " & .Item("Password")
    vlStrConexion = vlStrConexion & ";DSQ = " & .Item("Initial Catalog")
  End With
  fstrDameConexionSIHO = vlStrConexion
End Function

Public Sub pInsCortePoliza(ByVal vllngCorte As Long, ByVal vlstrFolioDocumento As String, ByVal vlstrTipoDocumento As String, ByVal vllngCuentaContable As Long, ByVal vldblCantidad As Double, ByVal vlblnCargo As Boolean, Optional ByVal vlstrTipoMovimiento As String, Optional ByVal vlstrTabla As String)
    
    vgstrParametrosSP = CStr(vllngCorte) & "|" & vlstrFolioDocumento & "|" & vlstrTipoDocumento & "|" & CStr(vllngCuentaContable) & "|" & str(vldblCantidad) & "|" & IIf(vlblnCargo, "1", "0") & "|" & vlstrTipoMovimiento & "|" & vlstrTabla
    frsEjecuta_SP vgstrParametrosSP, "Sp_Pvinspvcortepoliza"
    
End Sub

Public Function flngCuentaConceptoDepartamento(vllngConceptoFactura As Long, vlintNumeroDepartamento As Integer, vlstrTipoCuenta As String, Optional vllngCveTipoPaciente As Long) As Long
    '-----------------------------------------------------------------------------------
    'Regresa la cuenta contable del ingreso o descuento del concepto de facturación según el departamento
    '-----------------------------------------------------------------------------------
    
    On Error GoTo NotificaError
    
    Dim vlstrSentencia As String
    Dim rs As New ADODB.Recordset
    Dim vlblnEncontro As Boolean
    
    flngCuentaConceptoDepartamento = 0
    
    vlblnEncontro = False
    
    'Identifica si es socio (la clave de tipo paciente es <> 0) busca por tipo de paciente socio
    If vllngCveTipoPaciente > 0 Then 'Por tipo de paciente
        vlstrSentencia = "" & _
        "select " & _
            IIf(Trim(vlstrTipoCuenta) = "INGRESO", "intNumCuentaIngreso", "intNumCuentaDescuento") & _
        " from " & _
            "PVConceptoFactPaciente " & _
        "where " & _
            "smiCveConcepto=" & Trim(str(vllngConceptoFactura)) & " " & _
            "and smiCveTipoPaciente=" & Trim(str(vllngCveTipoPaciente))
            
        Set rs = frsRegresaRs(vlstrSentencia)
    Else
        'Si no es socio, busca por departamento
            vlstrSentencia = "" & _
            "select " & _
                IIf(Trim(vlstrTipoCuenta) = "INGRESO", "intNumCuentaIngreso", "intNumCuentaDescuento") & _
            " from " & _
                "PvConceptoFacturacionDepartame " & _
            "where " & _
                "smiCveConcepto=" & Trim(str(vllngConceptoFactura)) & " " & _
                "and smiCveDepartamento=" & Trim(str(vlintNumeroDepartamento))
        
        Set rs = frsRegresaRs(vlstrSentencia)
    End If

    Set rs = frsRegresaRs(vlstrSentencia)
    If rs.RecordCount <> 0 Then
        If rs.Fields(0) <> 0 Then
            flngCuentaConceptoDepartamento = rs.Fields(0)
            vlblnEncontro = True
        End If
    End If
    If Not vlblnEncontro And vllngCveTipoPaciente = 0 Then 'Busca por empresa como última opción cuando NO es socio
        vlstrSentencia = "" & _
        "select " & _
            IIf(Trim(vlstrTipoCuenta) = "INGRESO", "intnumctaingreso", "intnumctadescuento") & _
        " from " & _
            "PvConceptoFacturacionempresa " & _
        "where " & _
            "intcveconceptofactura = " & str(vllngConceptoFactura) & _
            " and intcveempresacontable = " & vgintClaveEmpresaContable
        Set rs = frsRegresaRs(vlstrSentencia)
        If rs.RecordCount <> 0 Then
            flngCuentaConceptoDepartamento = IIf(IsNull(rs.Fields(0)), 0, rs.Fields(0))
        End If
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngCuentaConceptoDepartamento"))
End Function

Public Sub pOrdenaGridClick(grid As MSHFlexGrid)
    'Ordena el contenido del grid
    'Este procedimiento hace uso de la variable global "vgOrden" que debe inicializarse en cada modulo
    On Error GoTo NotificaError
    
    With grid
        If .MouseRow < .FixedCols Then
            .Visible = False
            .Redraw = False
            .Col = .MouseCol
            .Sort = vgOrden
            .Row = 1
            .Redraw = True
            .Visible = True
            If .Enabled Then .SetFocus
            vgOrden = IIf(vgOrden = 1, 2, 1)
        End If
    End With

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pOrdenaGridClick" & " " & grid.Name))
End Sub



Public Sub pPreparaGridGral(ObjGrd As MSHFlexGrid, vCols As Integer, vRows As Integer, vCFix As Integer, vRFix As Integer)
'Procedimiento que prepara el grid de la consulta del Kardex
    On Error GoTo NotificaError

    With ObjGrd
        .Clear
        .ClearStructure
        .Rows = vRows
        .Cols = vCols
        .FixedCols = vCFix
        .FixedRows = vRFix
    End With

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pPreparaGridGral" & " " & ObjGrd.Name))
End Sub

Public Function fstrFechaSQL(Texto As String, Optional Hora As String, Optional SinApostrofe As Boolean) As String
'-------------------------------------------------------------------------------------
' Regresa un string tipo fecha que acepta SQL
' Modif: 26/04/02 se agrego lo del apostrofe
' Modif: 21/11/03 Formato de Fecha dependiendo de la conexión
'-------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim Y As String
    
    fstrFechaSQL = ""
    'Si Parametro SinApostrofe = Verdadero entonces no poner Comilla o Apostrofe,
    ' Falso u omisión, poner el apostrofe
    Y = IIf(SinApostrofe, "", "'")
    fstrFechaSQL = Y
    If Trim(Hora) = "" Then
      If vgstrBaseDatosUtilizada = "ORACLE" Then
        fstrFechaSQL = fstrFechaSQL & Format(Int(CDate(Texto)), "YYYY-MM-DD")
      Else
        fstrFechaSQL = fstrFechaSQL & Format(Int(CDate(Texto)), "MM/DD/YYYY")
      End If
    Else
      If vgstrBaseDatosUtilizada = "ORACLE" Then
        fstrFechaSQL = fstrFechaSQL & Format(Int(CDate(Texto)) + (CDate(Hora) - Int(CDate(Hora))), "YYYY-MM-DD HH:NN:SS")
      Else
        fstrFechaSQL = fstrFechaSQL & Format(Int(CDate(Texto)) + (CDate(Hora) - Int(CDate(Hora))), "MM/DD/YYYY HH:NN:SS")
      End If
    End If
    fstrFechaSQL = fstrFechaSQL + Y
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrFechaSQL"))

End Function

Public Function fstrNumeroJustificado(vldblNumero As Double, vllngTamaño As Long) As String
    On Error GoTo NotificaError

    fstrNumeroJustificado = Space(vllngTamaño - Len(FormatNumber(str(vldblNumero), 2))) + FormatNumber(str(vldblNumero), 2)

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrNumeroJustificado"))
End Function

Public Sub pImpDato(X As Long, Dato As Variant, Y As Long, Optional Underline As Boolean, Optional columnas As Boolean, Optional MaxY As Integer)
'Y indica el renglón
'Dato es el dato que se va a imprimir
'x indica la columna
'Underline determina si se va a subrayar el texto a imprimir
'Determina si se va a imprimir en varias columnas
'MaxX el tamaño máximo de las columnas

    If (Y <= IIf(Val(MaxY) = 0, 58, MaxY)) Then
        Printer.CurrentX = X
        Printer.CurrentY = Y
    Else
        If columnas = False Then    'Si no se manda en varias columnas
            pImpPag
            Printer.NewPage
            vlY = 0
            Printer.CurrentX = X
            Printer.CurrentY = vlY
            vSigueCol = True        'Esta en la primera
        Else
            vlY = Y
            Printer.CurrentX = X
            Printer.CurrentY = Y
        End If
    End If
    Printer.FontUnderline = Underline
    On Error Resume Next
    Printer.Print Dato
    If Err.Number <> 0 Then
        'EntornoSiho.ConeccionSiho.RollbackTrans
        Exit Sub
    End If
    Printer.FontUnderline = False
    
End Sub

Public Sub pImpPag()

    Printer.CurrentX = 85
    Printer.CurrentY = 60
    Printer.Print "Pag."
    Printer.CurrentX = 90
    Printer.CurrentY = 60
    Printer.Print Printer.Page

End Sub

Public Sub pImpVariosReng(Dato As String, XAct As Long, XIni As Long, Y As Long, Longitud As Integer)
'Procedimiento que imprime un dato en varios renglones
    Dim vlstrImp As String
    Dim vllngY As Long
    
    vllngY = Y
    
    If (Y <= 58) Then
        Printer.CurrentX = XAct
        Printer.CurrentY = vllngY
    Else
        pImpPag
        Printer.NewPage
        vlY = 3
        Printer.CurrentX = XIni
        Printer.CurrentY = vlY
        vllngY = vlY
    End If
    
    If (XAct + Len(Dato)) > Longitud Then
        If (Longitud > XAct) Then
            vlstrImp = Mid(Dato, 1, (Longitud - XAct))
        Else
            vlstrImp = Mid(Dato, 1, (XAct - Longitud))
        End If
        Printer.Print vlstrImp
        Dato = Mid(Dato, (Len(vlstrImp) + 1))
        Do While Len(Dato) > 0
            If Not (vllngY <= 58) Then
                pImpPag
                Printer.NewPage
                vlY = 3
                Printer.CurrentX = XIni
                Printer.CurrentY = vlY
                vllngY = vlY
            End If
            vllngY = vllngY + 2
            Printer.CurrentX = XIni
            Printer.CurrentY = vllngY
            vlstrImp = Mid(Dato, 1, Longitud - XIni)
            Printer.Print vlstrImp
            Dato = Mid(Dato, (Len(vlstrImp) + 1))
        Loop
    Else
        Printer.Print Dato
    End If
    vlY = vllngY

End Sub

Public Function fCenter(Center As Long, Longitud As Integer) As Integer
'Funcion que regresa la posicion del texto que se desea centrar
    
    fCenter = (Center - Longitud) / 2

End Function


Public Sub pImpresionRemota(vlstrTipoImpresion As String, vllngNumDocto As Long, vlintDeptoImprime As Integer)
'-------------------------------------------------------------------------------------------
' Procedimiento para guardar un documento en la pila de impresión remota
' Parametros
'   <vlstrTipoImpresion>
'   'RS' = Requisicion por salida a departamento
'   'RR' = Requisicion por reubicacion
'   'RC' = Requisicion por compra - pedido
'   'RP' = Requisicion con cargo a paciente
'   'SL' = Solicitud a Laboratorio
'   'SI' = Solicitud a Imagenología
'   <vllngNumDocto>
'   Consecutivo del tipo de documento anterior
'   <vlintDeptoImprime>
'   Departamento que activa la impresión remota
'   <Cuarto parametro>
'   Null Significa que está listo para la impresión remota
'   'I'  Ya está impreso, Se refleja en la pantalla del Spool de impresion
'   <Fecha en que se realizó el movimiento>
'   GetDate() Fecha de ahorititita
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlstrSentencia As String
    
    vlstrSentencia = ""
    vlstrSentencia = vlstrSentencia + "INSERT INTO ImpresionRemota (chrTipo,intClave,"
    vlstrSentencia = vlstrSentencia + "  smiCveDepartamento,chrEstatus,dtmFecha) "
    vlstrSentencia = vlstrSentencia + " VALUES('" & Trim(vlstrTipoImpresion) & "' ," & Trim(str(vllngNumDocto)) & " ,"
    vlstrSentencia = vlstrSentencia + "  " & Trim(str(vlintDeptoImprime)) & ", Null, getdate())"
    pEjecutaSentencia vlstrSentencia
    
    If vlstrTipoImpresion = "RP" Or vlstrTipoImpresion = "RR" Or vlstrTipoImpresion = "RS" Then pInsertaSubrrogados vllngNumDocto, vlstrTipoImpresion
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pImpresionRemota"))
End Sub

Public Function fSigConsecutivo(vlstrCampo As String, vlstrTabla As String) As Long
    Dim rsClave As New ADODB.Recordset
    Dim vlstrSentencia
    
    vlstrSentencia = "Select MAX(" & vlstrCampo & ") from " & vlstrTabla
    
    With rsClave
        .LockType = adLockReadOnly
        .CursorType = adOpenForwardOnly
        .ActiveConnection = EntornoSIHO.ConeccionSIHO
        .Source = vlstrSentencia
        .Open
    End With
    fSigConsecutivo = IIf(IsNull(rsClave.Fields(0).Value), 1, rsClave.Fields(0).Value + 1)
    rsClave.Close
End Function

Public Sub pLlenarCboRs2(ObjCbo As ComboBox, ObjRS As Recordset, vlintNumCampoItmData As Integer, vlintNumCampoList As String, Optional vlintNumCaso As Integer, Optional vlblnMuestraError As Boolean)
'-------------------------------------------------------------------------------------------
' Llena un combobox con datos de un recordset, pidiendo
' ObjCbo Combo Box en donde se llenaran los datos
' ObjRS Recorsed de donde se llenaran los datos
' vlintNumCampoItmData Numero de campo del RS para guardarlo en la posicion ItemData del ComboBox
' vlintNumCampoList Numero del campo del RS para guardarlos en la posicion List del ComboBox
' vlintNumCaso para llenar con Agregar o Mantenimiento segun el caso
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumCampoOrd As Long
    Dim vlintNumReg As Long
    Dim vlintseq As Long
    Dim vlstrNombreCampo As String
    Dim vlstrNomCampos As String
    Dim vlNum As Long
    Dim vlintIniciaSeq As Long
    Dim vlstrCampo As String
    Dim vlintSeqCampos As Long
    Dim vlintNum As Long
    
    vlintNumReg = ObjRS.RecordCount
    vlNum = 0
    ObjCbo.Clear
    Select Case vlintNumCaso
        Case Is = 1
                ObjCbo.AddItem " ", 0
        Case Is = 2
            If vlintNumCaso > 0 Then
                Select Case vlintNumReg
                    Case 0
                        ObjCbo.AddItem "<AGREGAR>", 0
                    Case Is > 0
                        ObjCbo.AddItem "<MANTENIMIENTO>", 0
                End Select
            End If
        Case Is = 3
                ObjCbo.AddItem "<TODOS>", 0
        Case Is = 4
                ObjCbo.AddItem "<NINGUNO(A)>", 0
        Case Is = 5
                ObjCbo.AddItem "<MANTENIMIENTO>", 0
    End Select
    
    vlintNumCampoOrd = CInt(fstrFormatTxt(vlintNumCampoList, "N", "", 20, False))
    If (vlintNumReg > 0) Then
        ObjRS.MoveFirst
        vlstrNombreCampo = ObjRS.Fields(vlintNumCampoOrd).Name
        vlstrCampo = vlstrNombreCampo & " Asc"
        ObjRS.Sort = vlstrCampo
        vlintIniciaSeq = ObjCbo.ListCount
        For vlintseq = 1 To vlintNumReg
            Select Case vlintNumCampoList
                Case Is = "*" 'En la lista suma todos los campos
                    vlstrNombreCampo = ObjRS.Fields(0).Name
                    vlstrCampo = vlstrNombreCampo & " Asc"
                    vlstrNomCampos = ""
                    For vlintSeqCampos = 0 To ObjRS.Fields.Count - 1
                        If vlintSeqCampos = ObjRS.Fields.Count - 1 Then
                            If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                vlstrNomCampos = vlstrNomCampos & ""
                            Else
                                vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos)
                            End If
                        Else
                            If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                vlstrNomCampos = vlstrNomCampos & " - "
                            Else
                                vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos) & " - "
                            End If
                        End If
                    Next vlintSeqCampos
                    ObjCbo.AddItem UCase(vlstrNomCampos), vlintIniciaSeq
                Case Is = "@" 'En la lista suma todos los campos menos el campo clave
                    vlstrNombreCampo = ObjRS.Fields(0).Name
                    vlstrCampo = vlstrNombreCampo & " Asc"
                    vlstrNomCampos = ""
                    vlintNum = vlintNumCampoItmData
                    For vlintSeqCampos = 0 To ObjRS.Fields.Count - 1
                        If vlintSeqCampos <> vlintNum Then
                            If vlintSeqCampos = ObjRS.Fields.Count - 1 Then
                                If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                    vlstrNomCampos = vlstrNomCampos & ""
                                Else
                                    vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos)
                                End If
                            Else
                                If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                    vlstrNomCampos = vlstrNomCampos & " - "
                                Else
                                    vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos) & " - "
                                End If
                            End If
                        End If
                    Next vlintSeqCampos
                    ObjCbo.AddItem UCase(vlstrNomCampos), vlintIniciaSeq
                Case Else 'En la lista va solo en campo que se envio
                    If IsNull(ObjRS.Fields(CInt(vlintNumCampoList))) Then
                        ObjCbo.AddItem "< >", vlintIniciaSeq
                    Else
                        ObjCbo.AddItem UCase(ObjRS.Fields(CInt(vlintNumCampoList))), vlintIniciaSeq
                    End If
            End Select
            
            If vlintNumCampoItmData >= 0 Then
                If IsNumeric(ObjRS.Fields(vlintNumCampoItmData).Value) = True Then
                    ObjCbo.ItemData(vlintIniciaSeq) = CDbl(ObjRS.Fields(vlintNumCampoItmData).Value)
                Else
                    ObjCbo.ItemData(vlintIniciaSeq) = 0
                End If
            Else
                ObjCbo.ItemData(vlintIniciaSeq) = ObjRS.Bookmark
            End If
            vlintIniciaSeq = vlintIniciaSeq + 1
            ObjRS.MoveNext
        Next vlintseq
        ObjRS.MoveFirst
    Else
        If vlblnMuestraError = True Then
            Call MsgBox((SIHOMsg(13) & Chr(13) & ObjCbo.ToolTipText), vbExclamation, "Mensaje") 'Toma un mensaje del módulo de mensajes y lo despliega
        End If
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLlenarCboRs2" & " " & ObjCbo.Name))
End Sub

Public Sub pValidaSoloNumero(KeyAscii As Integer)

  On Error GoTo NotificaError
  ' Solo permite números
    
    Select Case KeyAscii
        Case Asc(vbCr)
            KeyAscii = 0
        Case 8
        Case 48 To 57
        Case Else
            KeyAscii = 0
    End Select
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pValidaSoloNumero"))
End Sub

Public Function fstrFecha(Texto As String) As String
    On Error GoTo NotificaError
    
    '-------------------------------------------------------------------------------------
    ' Regresa un string tipo fecha que acepta SQL
    '-------------------------------------------------------------------------------------
    fstrFecha = IIf(Len(LTrim(str(Month(CDate(Texto))))) = 1, "0" + LTrim(str(Month(CDate(Texto)))), LTrim(str(Month(CDate(Texto))))) + "/" + IIf(Len(LTrim(str(Day(CDate(Texto))))) = 1, "0" + LTrim(str(Day(CDate(Texto)))), LTrim(str(Day(CDate(Texto))))) + "/" + LTrim(str(Year(CDate(Texto))))

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrFecha"))
End Function
Public Function fstrFechaCrystal(Texto As String) As String
    On Error GoTo NotificaError
    
    '-------------------------------------------------------------------------------------
    ' Regresa un string tipo fecha que acepta SQL
    ' mm/dd/yyyy hh:mm:ss.fff
    '-------------------------------------------------------------------------------------
    fstrFechaCrystal = IIf(Len(LTrim(str(Month(CDate(Texto))))) = 1, "0" + LTrim(str(Month(CDate(Texto)))), LTrim(str(Month(CDate(Texto))))) + "/" + IIf(Len(LTrim(str(Day(CDate(Texto))))) = 1, "0" + LTrim(str(Day(CDate(Texto)))), LTrim(str(Day(CDate(Texto))))) + "/" + LTrim(str(Year(CDate(Texto)))) + " 00:00:00.000"

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrFechaCrystal"))
End Function

Public Function flngNumeroCuenta(vlstrCuentaContable As String, vlintClaveEmpresa As Integer) As Long
'------------------------------------------------------------------------
' Regresa el identity de una cuenta contable y empresa contable dada
'------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim rsNumeroCuenta As New ADODB.Recordset
    Dim vlstrsql As String
    
    flngNumeroCuenta = 0
    
    vlstrsql = "select intNumeroCuenta from CnCuenta where vchCuentaContable='" + vlstrCuentaContable
    vlstrsql = vlstrsql + "' and tnyClaveEmpresa=" + str(vlintClaveEmpresa)

    Set rsNumeroCuenta = frsRegresaRs(vlstrsql)
    If rsNumeroCuenta.RecordCount <> 0 Then
        flngNumeroCuenta = rsNumeroCuenta.Fields(0)
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngNumeroCuenta"))
End Function
Public Function fstrCuentaCompleta(vlstrCuenta As String, Optional vllngDigitos As Long) As String
    On Error GoTo NotificaError
    '------------------------------------------------------------------------------
    ' Función que devuelve la cuenta contable completa de acuerdo a la estructura
    ' cargada en la variable vgstrEstructuraCuentaContable
    ' vlstrCuenta  = estructura de la cuenta contable
    ' vllngDigitos = cuando no se desea completar la cuenta completa se reciben aqui los dígitos a completar
    '------------------------------------------------------------------------------
    Dim vllngContador As Integer
    Dim vllngTotalDigitos As Long
    
    fstrCuentaCompleta = ""
    
    If vllngDigitos = 0 Then
        vllngTotalDigitos = Len(vgstrEstructuraCuentaContable)
    Else
        vllngTotalDigitos = vllngDigitos
    End If
    
    vllngContador = 1
    Do While vllngContador <= vllngTotalDigitos
        If Mid(vgstrEstructuraCuentaContable, vllngContador, 1) = "#" Then
            If Trim(Mid(vlstrCuenta, vllngContador, 1)) <> "" Then
                fstrCuentaCompleta = fstrCuentaCompleta + Mid(vlstrCuenta, vllngContador, 1)
            Else
                fstrCuentaCompleta = fstrCuentaCompleta + "0"
            End If
        Else
            fstrCuentaCompleta = fstrCuentaCompleta + "."
        End If
        vllngContador = vllngContador + 1
    Loop
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrCuentaCompleta"))
End Function

Public Function fstrCuentaCompletaEmpresa(vlstrCuenta As String, vlstrEstructuraCuentaContable As String, Optional vllngDigitos As Long) As String
    On Error GoTo NotificaError
    '------------------------------------------------------------------------------
    ' Función que devuelve la cuenta contable completa de acuerdo a la estructura
    ' cargada en la variable vgstrEstructuraCuentaContable
    ' vlstrCuenta  = estructura de la cuenta contable
    ' vllngDigitos = cuando no se desea completar la cuenta completa se reciben aqui los dígitos a completar
    '------------------------------------------------------------------------------
    Dim vllngContador As Integer
    Dim vllngTotalDigitos As Long
    
    fstrCuentaCompletaEmpresa = ""
    
    If vllngDigitos = 0 Then
        vllngTotalDigitos = Len(vlstrEstructuraCuentaContable)
    Else
        vllngTotalDigitos = vllngDigitos
    End If
    
    vllngContador = 1
    Do While vllngContador <= vllngTotalDigitos
        If Mid(vgstrEstructuraCuentaContable, vllngContador, 1) = "#" Then
            If Trim(Mid(vlstrCuenta, vllngContador, 1)) <> "" Then
                fstrCuentaCompletaEmpresa = fstrCuentaCompletaEmpresa + Mid(vlstrCuenta, vllngContador, 1)
            Else
                fstrCuentaCompletaEmpresa = fstrCuentaCompletaEmpresa + "0"
            End If
        Else
            fstrCuentaCompletaEmpresa = fstrCuentaCompletaEmpresa + "."
        End If
        vllngContador = vllngContador + 1
    Loop
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrCuentaCompletaEmpresa"))
End Function

Public Function fstrDescripcionCuenta(vlstrCuentaContable As String, vlintClaveEmpresa As Integer, Optional ldtmFechaPoliza As Date, Optional lblnFechaServidor As Boolean) As String
'------------------------------------------------------------------------
' Regresa la descripción de la cuenta dada la cuenta contable y la empresa
' contable
'------------------------------------------------------------------------

    On Error GoTo NotificaError
    
    Dim rsDescripcionCuenta As New ADODB.Recordset
    Dim vlstrsql As String
    If lblnFechaServidor <> True Then
        ldtmFechaPoliza = CDate(fdtmServerFecha)
    End If

    
        fstrDescripcionCuenta = ""
        vlstrsql = "select (case when CnCuentaRenombradaEjercicio.vchDescripcionCuenta is null then CnCuenta.vchDescripcionCuenta else CnCuentaRenombradaEjercicio.vchDescripcionCuenta end) from CnCuenta left join CnCuentaRenombradaEjercicio on CnCuenta.intNumeroCuenta = CnCuentaRenombradaEjercicio.intNumeroCuenta and TO_DATE(TO_CHAR(cncuentarenombradaejercicio.dtmfechahoracambio, 'DD-MM-YYYY'),'DD-MM-YYYY')> TO_DATE('" + CStr(ldtmFechaPoliza) + "','DD-MM-YYYY') where CnCuenta.vchCuentaContable='" + vlstrCuentaContable
        vlstrsql = vlstrsql + "' and tnyClaveEmpresa=" + str(vlintClaveEmpresa)
     
   
    Set rsDescripcionCuenta = frsRegresaRs(vlstrsql)
    If rsDescripcionCuenta.RecordCount <> 0 Then
        fstrDescripcionCuenta = rsDescripcionCuenta.Fields(0)
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrDescripcionCuenta"))
End Function


Public Function fstrCuentaContable(vlintNumeroCuenta As Long) As String
'------------------------------------------------------------------------
' Regresa la descripción de una cuenta contable dado el identity de la
' cuenta
'------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim rsCuentaContable As New ADODB.Recordset
    Dim vlstrsql As String
    
    fstrCuentaContable = ""
    
    vlstrsql = "select vchCuentaContable from CnCuenta where intNumeroCuenta=" + str(vlintNumeroCuenta)

    Set rsCuentaContable = frsRegresaRs(vlstrsql)
    If rsCuentaContable.RecordCount <> 0 Then
        fstrCuentaContable = rsCuentaContable.Fields(0)
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrCuentaContable"))

End Function

Public Function fstrNombreCuentaContable(vlintNumeroCuenta As Long) As String
'------------------------------------------------------------------------
' Regresa el nombre de una cuenta contable dado el identity de la
' cuenta
'------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim rsNombreCuentaContable As New ADODB.Recordset
    Dim vlstrsql As String
    
    fstrNombreCuentaContable = ""
    
    vlstrsql = "select vchdescripcioncuenta from CnCuenta where intNumeroCuenta=" + str(vlintNumeroCuenta)

    Set rsNombreCuentaContable = frsRegresaRs(vlstrsql)
    If rsNombreCuentaContable.RecordCount <> 0 Then
        fstrNombreCuentaContable = rsNombreCuentaContable.Fields(0)
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrNombreCuentaContable"))

End Function


Public Function fRegresaParametro(vlstrNombreCampo As String, vlstrNombreTabla As String, vlintNumeroMensaje As Integer)
'------------------------------------------------------------------------
' Regresa el contenido de un campo de una tabla de parametros dada
'------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim rsParametro As New ADODB.Recordset
    Dim vlstrsql  As String
    
    fRegresaParametro = ""
    
    vlstrsql = "select " + vlstrNombreCampo + " from " + vlstrNombreTabla
    If vlstrNombreTabla = "IvParametro" Or vlstrNombreTabla = "CnParametro" Or vlstrNombreTabla = "PvParametro" Then
    vlstrsql = vlstrsql + " where tnyclaveempresa = " & vgintClaveEmpresaContable
    End If
    Set rsParametro = frsRegresaRs(vlstrsql)
    If rsParametro.RecordCount <> 0 Then
        If Not IsNull(rsParametro.Fields(0)) Then
            fRegresaParametro = rsParametro.Fields(0)
        End If
    End If
    If fRegresaParametro = "" Then
        If vlintNumeroMensaje <> 0 Then
            MsgBox SIHOMsg(vlintNumeroMensaje), vbOKOnly + vbInformation, "Mensaje"
        End If
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fRegresaParametro"))
End Function
Public Function flngClavePoliza(vlintEmpresaContable As Integer, vlintEjercicio As Integer) As Long
'------------------------------------------------------------------------
' Regresa el siguiente numero de póliza dado el ejercicio y la empresa
' contable
'------------------------------------------------------------------------
    Dim rsFolioPoliza As New ADODB.Recordset
    Dim vlstrsql As String
    
    flngClavePoliza = 0
    vlstrsql = "select count(*) from CnFolioPoliza where tnyClaveEmpresa=" + str(vlintEmpresaContable) + " and smiEjercicio=" + str(vlintEjercicio)
    Set rsFolioPoliza = frsRegresaRs(vlstrsql)
    If rsFolioPoliza.Fields(0) <> 0 Then
        vlstrsql = "select intClavePoliza from CnFolioPoliza where tnyClaveEmpresa=" + str(vlintEmpresaContable) + " and smiEjercicio=" + str(vlintEjercicio)
        Set rsFolioPoliza = frsRegresaRs(vlstrsql)
        flngClavePoliza = rsFolioPoliza.Fields(0)
        vlstrsql = "update cnFolioPoliza set intClavePoliza=" + str(flngClavePoliza + 1) + " where tnyClaveEmpresa=" + str(vlintEmpresaContable) + " and smiEjercicio=" + str(vlintEjercicio)
        pEjecutaSentencia vlstrsql
    Else
        vlstrsql = "insert into CnFolioPoliza (tnyClaveEmpresa,smiEjercicio,intClavePoliza) values (" + str(vlintEmpresaContable) + "," + str(vlintEjercicio) + "," + "2" + ")"
        flngClavePoliza = 1
        pEjecutaSentencia vlstrsql
    End If
End Function

Public Function fblnPeriodoCerrado(vlintClaveEmpresa As Integer, vlintEjercicio As Integer, vlintMes As Integer) As Boolean
'------------------------------------------------------------------------
' Revisa si el periodo contable de una empresa dada esta abierto o cerrado
'------------------------------------------------------------------------
On Error GoTo NotificaError
    Dim rs As New ADODB.Recordset
    Dim lintMesInicio As Integer
    Dim lintEjercicioInicio As Integer
    
    Set rs = frsSelParametros("CN", vgintClaveEmpresaContable, "TNYMESINICIOOPERACIONES")
    If Not rs.EOF Then
        lintMesInicio = rs!Valor
    End If
    Set rs = frsSelParametros("CN", vgintClaveEmpresaContable, "SMIEJERCICIOINICIOOPERACIONES")
    If Not rs.EOF Then
        lintEjercicioInicio = rs!Valor
    End If
        
    fblnPeriodoCerrado = True
    If vlintEjercicio > lintEjercicioInicio Or (vlintEjercicio = lintEjercicioInicio And vlintMes >= lintMesInicio) Then
        Set rs = frsRegresaRs("select TNYCLAVEEMPRESA, INTNUMCIERRE, SMIEJERCICIO, TNYMES, INTNUMEMPLEADO, DTMFECHAHORA, INTNUMPOLIZACIERREANUAL from CnCierreContable where tnyClaveEmpresa=" + str(vlintClaveEmpresa) + " and smiEjercicio=" + str(vlintEjercicio) + " and tnyMes=" + str(vlintMes))
        If rs.RecordCount = 0 Then
            fblnPeriodoCerrado = False
        End If
    End If
    rs.Close
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnPeriodoCerrado"))
End Function

Public Function flngPersonaGraba(vlintxDepartamento As Integer, Optional vlstrQuienGraba As String, Optional vlstrPosicionInicialOptFiltro As String, Optional llngClavePersona As Long) As Long
'----------------------------------------------------------------------------------------------------
' Función para seleccionar el empleado o médico que realiza la operación, validando el password
' en NoEmpleado o HoMedico según sea el caso, cuando se introduce la contraseña correcta:
' La funcion devuelve el número de médico o empleado seleccionado
' El valor del parámetro se cambia segun si es medico o empleado,
'       "M" indica que se seleccionó un médico, "E" un empleado,
' Si la contraseña proporcionada no es correcta la función devuelve un 0 (cero)
' y el valor del parámetro no se cambia
' Valores para el parámetro <vlstrQuienGraba>
' "" o "E"  = Se puede seleccionar únicamente Empleados
' "A"       = Se puede seleccionar Empleados y médicos
' "M"       = Se puede seleccionar únicamente Médicos
' llngClaveEmpleado clave del empleado o medico
'----------------------------------------------------------------------------------------------------
    
    On Error GoTo NotificaError
    
    vgstrPersonaqueGrabaEmpleadoMedico = ""
    
    frmPersonaGraba.vlintxDepartamento = vlintxDepartamento
    frmPersonaGraba.vlstrQuienGraba = vlstrQuienGraba
    frmPersonaGraba.vlstrPosicionInicialFiltro = vlstrPosicionInicialOptFiltro
    frmPersonaGraba.llngCvePersona = llngClavePersona
    frmPersonaGraba.pCargarForma
    frmPersonaGraba.Show vbModal
    
    flngPersonaGraba = frmPersonaGraba.vllngEmpleadoSeleccionado
    vlstrQuienGraba = frmPersonaGraba.vlstrQuienGraba
    vgstrPersonaqueGrabaEmpleadoMedico = frmPersonaGraba.vlstrQuienGraba
        
    Unload frmPersonaGraba

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngPersonaGraba"))
End Function

Public Function fblnValidaPunto(pstrTexto As String) As Boolean
'--------------------------------------
'Funcion para validar que en una cantidad no se puedan poner dos puntos
'--------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintcontador As Integer
    fblnValidaPunto = False
    For vlintcontador = 1 To Len(pstrTexto)
        If Mid(pstrTexto, vlintcontador, 1) = "." Then
            fblnValidaPunto = True
            vlintcontador = Len(pstrTexto) + 1
        End If
    Next

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnValidaPunto"))

End Function

Public Sub pFormatoNumeroColumnaGrid(grdNombre As MSHFlexGrid, vlintxColumna As Integer, Optional vlstrSigno As String)
'--------------------------------------
' Función para dar formato a la columna del grid que son números
'--------------------------------------
    On Error GoTo NotificaError
    
    Dim X As Long
    
    For X = 1 To grdNombre.Rows - 1
        grdNombre.TextMatrix(X, vlintxColumna) = Format(grdNombre.TextMatrix(X, vlintxColumna), vlstrSigno & " ###,###,###,###,###.00")
    Next X

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pFormatoNumeroColumnaGrid" & " " & grdNombre.Name))
End Sub


Public Function fdblTipoCambio(vldtmFecha As Date, vlstrTipoCambio As String) As Double
'----------------------------------------------------------------------------------------
' Regresa el tipo de cambio de un día determinado dependiendo del segundo parámetro
' regresa el tipo de cambio oficial, compra o venta
' "C" tipo de cambio a la compra
' "V" tipo de cambio a la venta
' "0" tipo de cambio del diario oficial de la federacion
'----------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim rsTipoCambio As New ADODB.Recordset
    Dim lstrFechaTexto As String
    
    fdblTipoCambio = 0
    lstrFechaTexto = vldtmFecha
    
    vgstrParametrosSP = lstrFechaTexto
    Set rsTipoCambio = frsEjecuta_SP(vgstrParametrosSP, "sp_GnSelTipoCambio")
    
    If rsTipoCambio.RecordCount <> 0 Then
        Select Case vlstrTipoCambio
            Case "O"
                fdblTipoCambio = rsTipoCambio!Oficial
            Case "C"
                fdblTipoCambio = rsTipoCambio!Compra
            Case "V"
                fdblTipoCambio = rsTipoCambio!Venta
        End Select
        
    Else
        fdblTipoCambio = 0
    End If
    
    rsTipoCambio.Close

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fdblTipoCambio"))
End Function

Public Sub pFormaPermisos(vllngxNumeroOpcion As Long)
'--------------------------------------
' Procedimiento para llamar la forma de mantenimiento de permisos de acceso
' de la opción X del módulo
'--------------------------------------
    frmPermisos.vllngNumeroOpcion = vllngxNumeroOpcion
    frmPermisos.Show vbModal
End Sub

Public Sub pPermisos(vlintNumeroOpciones As Integer, frmNombre As Form)
'------------------------------------------------------------------------
' Deshabilita opciones a las cuales el usuario no tiene acceso
'------------------------------------------------------------------------
    Dim X As Integer
    Dim rsPermiso As New ADODB.Recordset
    Dim rsObjeto As New ADODB.Recordset
    Dim vlstrsql As String
    
    For X = 0 To vlintNumeroOpciones
        vlstrsql = "select chrPermiso as Permiso from Permiso where intNumeroLogin=" & CStr(vglngNumeroLogin) & " and intNumeroOpcion=" & CStr(aPermisos(X).vllngNumeroOpcion)
        Set rsPermiso = frsRegresaRs(vlstrsql, adLockOptimistic, adOpenDynamic)
        If rsPermiso.RecordCount <> 0 Then
            vlstrsql = "select vchNombreObjeto,intOrdenObjeto from Opcion where intNumeroOpcion=" & CStr(aPermisos(X).vllngNumeroOpcion)
            Set rsObjeto = frsRegresaRs(vlstrsql, adLockOptimistic, adOpenDynamic)
            If rsObjeto.RecordCount <> 0 Then
                aPermisos(X).vlstrTipoPermiso = rsPermiso!Permiso
                If rsPermiso!Permiso = "S" Then
                    If TypeOf frmNombre.Controls(rsObjeto!vchNombreObjeto) Is SSTab Then
                        frmNombre.Controls(rsObjeto!vchNombreObjeto).TabEnabled(rsObjeto!intordenobjeto) = False
                    Else
                        frmNombre.Controls(rsObjeto!vchNombreObjeto).Enabled = False
                    End If
                Else
                    If TypeOf frmNombre.Controls(rsObjeto!vchNombreObjeto) Is SSTab Then
                        frmNombre.Controls(rsObjeto!vchNombreObjeto).TabEnabled(rsObjeto!intordenobjeto) = True
                    Else
                        frmNombre.Controls(rsObjeto!vchNombreObjeto).Enabled = True
                    End If
                End If
            End If
        Else
            If UCase(vgstrNombreUsuario) <> "ADMINISTRADOR" Then
                vlstrsql = "select vchNombreObjeto,intOrdenObjeto from Opcion where intNumeroOpcion=" + str(aPermisos(X).vllngNumeroOpcion)
                Set rsObjeto = frsRegresaRs(vlstrsql)
                If rsObjeto.RecordCount <> 0 Then
                    If TypeOf frmNombre.Controls(rsObjeto!vchNombreObjeto) Is SSTab Then
                        frmNombre.Controls(rsObjeto!vchNombreObjeto).TabEnabled(rsObjeto!intordenobjeto) = False
                    Else
                        frmNombre.Controls(rsObjeto!vchNombreObjeto).Enabled = False
                    End If
                End If
            End If
        End If
    Next X
End Sub

Public Sub PSuperBusqueda(txtTexto As TextBox, vlstrInstruccion As String, lstResultados As ListBox, vlstrCampoFiltro As String, vlintMaxRecords As Integer, Optional vlstrOtroFiltro As String, Optional vlstrOrderBy As String)
    '---------------------------------------------------------------------
    'Fecha : 14/Nov/2003
    'Modificó : Rodolfo Ramos
    'Descripcion: Se le quito el ROWCOUNT que maneja MSSQL y se le puso para que llamara el frsRegresaRS
    '       ya que se creaba todo el cursor ahí mismo
    '---------------------------------------------------------------------


    Dim vlintRenglones As Integer
    Dim rsDatos As New ADODB.Recordset
    
    If EntornoSIHO.ConeccionSIHO.State = 0 Then
        EntornoSIHO.ConeccionSIHO.Open
    End If
    vlstrInstruccion = vlstrInstruccion & " where " & vlstrCampoFiltro & " like '" & txtTexto.Text & "%' " & vlstrOtroFiltro
    If vlstrOrderBy <> "" Then
        vlstrInstruccion = vlstrInstruccion & " Order by " & vlstrOrderBy
    End If
    
    ' Instruccion para que Deshabilitar el Filtro de la SuperBusqueda con ROWCOUNT
    ' vlstrInstruccion = vlstrInstruccion & " set rowCount 0"
    '-----------------------------------------------------------------------------
    
    
    lstResultados.Clear
    If txtTexto.Text <> "" Then
        lstResultados.Visible = False
        
        Set rsDatos = frsRegresaRs(vlstrInstruccion, adLockOptimistic, adOpenForwardOnly, vlintMaxRecords)
        
        For vlintRenglones = 0 To rsDatos.RecordCount - 1
            lstResultados.AddItem rsDatos.Fields(1)
            lstResultados.ItemData(lstResultados.newIndex) = rsDatos.Fields(0)
            rsDatos.MoveNext
        Next vlintRenglones
        If rsDatos.RecordCount > 0 Then
            lstResultados.ListIndex = 0
            lstResultados.Enabled = True
        Else
            lstResultados.Enabled = False
        End If
        rsDatos.Close
        lstResultados.Visible = True
    Else
        lstResultados.Enabled = False
    End If
End Sub

Public Sub pSeleccionaGrid(vlintElemento As Integer, grdOrigen As MSHFlexGrid, grdDestino As MSHFlexGrid, Optional vlcmdSelecciona As CommandButton, Optional vlcmdDesSelecciona As CommandButton)
'------------------------------------------------------------------------------------------------
' Permite seleccionar un elemento (vlintelemento) de un grid (grdOrigen) a otro (grdDestino)
' tomando en cuenta que pueden existir botones para realizar la asignación (vlcmdSelecciona y vlcmdDesselecciona)
' con la finalidad  de que se habiliten o no los votones (estos son otros)
' Se requiere de una Función llamada pBorrarRegMshFGrdData externa para que funcione
'------------------------------------------------------------------------------------------------
    
    Dim vlintcontador As Integer
    With grdDestino
        .Redraw = False
        If .RowData(1) <> -1 Then
            .Rows = .Rows + 1
            .Row = .Rows - 1
        End If
        .RowData(.Row) = grdOrigen.RowData(vlintElemento)
        For vlintcontador = 1 To .Cols - 1
            .TextMatrix(.Row, vlintcontador) = grdOrigen.TextMatrix(vlintElemento, vlintcontador)
        Next
        grdDestino.Enabled = True
        If Not vlcmdDesSelecciona Is Nothing Then
            vlcmdDesSelecciona.Enabled = True
        End If
        .Row = 1
        .Redraw = True
    End With
    
    With grdOrigen
        .Redraw = False
        pBorrarRegMshFGrdData vlintElemento, grdOrigen, True
        If grdOrigen.RowData(1) = -1 Then
            grdOrigen.Enabled = False
            If Not vlcmdSelecciona Is Nothing Then
                vlcmdSelecciona.Enabled = False
            End If
        End If
        .Redraw = True
    End With
End Sub

Public Sub pSeleccionaLista(vlintElemento As Integer, vllstOrigen As ListBox, vllstDestino As ListBox, Optional vlcmdSelecciona As CommandButton, Optional vlcmdDesSelecciona As CommandButton)
    vllstDestino.AddItem vllstOrigen.List(vlintElemento)
    vllstDestino.ItemData(vllstDestino.newIndex) = vllstOrigen.ItemData(vlintElemento)
    vllstOrigen.RemoveItem (vlintElemento)
    
    If Not (vlcmdSelecciona Is Nothing) Then
        If vllstOrigen.ListCount = 0 Then
            vlcmdSelecciona.Enabled = False
            vllstOrigen.Enabled = False
        Else
            vllstOrigen.ListIndex = 0
            vlcmdSelecciona.Enabled = True
            vllstOrigen.Enabled = True
        End If
    End If
    If Not (vlcmdDesSelecciona Is Nothing) Then
        If vllstDestino.ListCount = 0 Then
            vlcmdDesSelecciona.Enabled = False
            vllstDestino.Enabled = False
        Else
            vllstDestino.ListIndex = 0
            vlcmdDesSelecciona.Enabled = True
            vllstDestino.Enabled = True
        End If
    End If
End Sub

Public Sub pLlenarMshFGrdRs(ObjGrid As MSHFlexGrid, ObjRS As Recordset, Optional vlstrColumnaData As String)
'----------------------------------------------------------------------------------------
'Procedimiento para llenar un grid con datos de un record set
' Modificacion: vlintColumna dice que columna del record set se debe
' de llenar en el RowData
' Si no quieres meter nada en el RowData mandale un -1 o una columna
' que no exista
'----------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumCampos As Long
    Dim vlintNumReg As Long
    Dim vlintSeqFil As Long
    Dim vlintSeqCol As Long
    
    vlintNumCampos = ObjRS.Fields.Count
    vlintNumReg = ObjRS.RecordCount
    
    If vlintNumReg > 0 Then
        With ObjGrid
            .Redraw = False
            .Visible = False
            .Clear
            .ClearStructure
            .Cols = vlintNumCampos + 1
            .Rows = vlintNumReg + 1
            .FixedCols = 1
            .FixedRows = 1
        End With
        ObjRS.MoveFirst
        
        For vlintSeqFil = 1 To vlintNumReg
            For vlintSeqCol = 1 To vlintNumCampos
                If IsNull(ObjRS.Fields(vlintSeqCol - 1).Value) Then
                    ObjGrid.TextMatrix(vlintSeqFil, vlintSeqCol) = ""
                Else
                    If vlstrColumnaData <> "" Then
                        If vlintSeqCol - 1 = Val(vlstrColumnaData) Then
                            ObjGrid.RowData(vlintSeqFil) = ObjRS.Fields(vlintSeqCol - 1)
                        End If
                    End If
                    ObjGrid.TextMatrix(vlintSeqFil, vlintSeqCol) = ObjRS.Fields(vlintSeqCol - 1).Value
                End If
            Next vlintSeqCol
            ObjRS.MoveNext
        Next vlintSeqFil
        ObjGrid.Redraw = True
        ObjGrid.Visible = True
    End If

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLlenarMshFGrdRs" & " " & ObjGrid.Name))
End Sub

Public Function fstrNumeroenLetras(vllngxNumero As Double, vlstrMoneda As String, vlstrAgregadoaMoneda As String) As String
'-------------------------------------------------------------------------------
' Regresa la descripción de un número en letras utiliza la tabla NumeroNombre
'-------------------------------------------------------------------------------
    Dim vlstrsql As String
    Dim vlstrDecimales As String
    Dim vlstrNumeroconFormato As String
    Dim vlstrNumerosinDecimales As String
    Dim vlstrNumeroaExaminar As String
    Dim aNombreNumero() As String
    Dim X As Integer
    
    Dim rsNombreNumero As New ADODB.Recordset
    
    
    ReDim aNombreNumero(11)
    
    vlstrNumeroconFormato = Format(vllngxNumero, "############.00")
    vlstrDecimales = Mid(vlstrNumeroconFormato, Len(vlstrNumeroconFormato) - 1, 2) + "/100"
    vlstrNumerosinDecimales = Mid(vlstrNumeroconFormato, 1, Len(vlstrNumeroconFormato) - 3)
    
    Do While Len(vlstrNumerosinDecimales) <> 12
        vlstrNumerosinDecimales = "0" + vlstrNumerosinDecimales
    Loop
    
    X = 1
    Do While X <= Len(vlstrNumerosinDecimales)
        vlstrNumeroaExaminar = Mid(vlstrNumerosinDecimales, X, 1)
        If X = 1 Or X = 4 Or X = 7 Or X = 10 Then
            '------------------------------------
            ' CENTENAS
            '------------------------------------
            vlstrsql = "select vchCentena from NumeroNombre where tnyUnidad=" + vlstrNumeroaExaminar + " and tnyDecena=" + vlstrNumeroaExaminar
            Set rsNombreNumero = frsRegresaRs(vlstrsql)
            aNombreNumero(X - 1) = rsNombreNumero.Fields(0)
        Else
            If X = 2 Or X = 5 Or X = 8 Or X = 11 Then
                '------------------------------------
                ' DECENAS
                '------------------------------------
                vlstrsql = "select vchDecena from NumeroNombre where tnyUnidad=" + vlstrNumeroaExaminar + " and tnyDecena=" + vlstrNumeroaExaminar
                Set rsNombreNumero = frsRegresaRs(vlstrsql)
                aNombreNumero(X - 1) = rsNombreNumero.Fields(0)
                
                If vlstrNumeroaExaminar <> "0" And Mid(vlstrNumerosinDecimales, X - 1, 1) = "1" Then
                    '------------------------------------
                    ' VARIACION EN LA CENTENA 1 'CIEN' A 'CIENTO'
                    '------------------------------------                                      '1 1 1
                    vlstrsql = "select vchCentenaVariacion from NumeroNombre where tnyUnidad=1 and tnyDecena=1 and tnyCentena=1"
                    Set rsNombreNumero = frsRegresaRs(vlstrsql)
                    aNombreNumero(X - 2) = rsNombreNumero.Fields(0)
                End If
            Else
                '------------------------------------
                ' UNIDADES
                '------------------------------------
                vlstrsql = "select vchUnidad from NumeroNombre where tnyUnidad=" + vlstrNumeroaExaminar + " and tnyDecena=" + vlstrNumeroaExaminar
                Set rsNombreNumero = frsRegresaRs(vlstrsql)
                aNombreNumero(X - 1) = rsNombreNumero.Fields(0)
                
                If vlstrNumeroaExaminar <> "0" Then
                
                    If Mid(vlstrNumerosinDecimales, X - 2, 1) = "1" Then
                        '------------------------------------
                        ' VARIACION EN LA CENTENA 1 'CIEN' A 'CIENTO'
                        '------------------------------------                                      '1 1 1
                        vlstrsql = "select vchCentenaVariacion from NumeroNombre where tnyUnidad=1 and tnyDecena=1 and tnyCentena=1"
                        Set rsNombreNumero = frsRegresaRs(vlstrsql)
                        aNombreNumero(X - 3) = rsNombreNumero.Fields(0)
                    End If
                    If Mid(vlstrNumerosinDecimales, X - 2, 1) <> "0" And Mid(vlstrNumerosinDecimales, X - 1, 1) = "0" And vlstrNumeroaExaminar = "1" Then
                        '------------------------------------
                        ' VARIACION EN LA UNIDAD 1 'UNO' A 'UN'
                        '------------------------------------
                        vlstrsql = "select vchUnidadVariacion from NumeroNombre where tnyUnidad=1"
                        Set rsNombreNumero = frsRegresaRs(vlstrsql)
                        aNombreNumero(X - 1) = rsNombreNumero.Fields(0)
                    End If
                    If vlstrNumeroaExaminar = "1" And Mid(vlstrNumerosinDecimales, X - 1, 1) = "0" And Mid(vlstrNumerosinDecimales, X - 2, 1) = "0" Then
                        '------------------------------------
                        ' VARIACION EN LA UNIDAD 1 'UNO' A 'UN'
                        '------------------------------------
                        vlstrsql = "select vchUnidadVariacion from NumeroNombre where tnyUnidad=" + "1"
                        Set rsNombreNumero = frsRegresaRs(vlstrsql)
                        aNombreNumero(X - 1) = rsNombreNumero.Fields(0)
                    Else
                        If Mid(vlstrNumerosinDecimales, X - 1, 1) <> "0" Then
                            If Mid(vlstrNumerosinDecimales, X - 1, 1) <> "1" Then
                                '------------------------------------
                                ' VARIACION EN LA DECENA <> 1 EJ 'VEINTE' A 'VEINTI'
                                '------------------------------------
                                vlstrsql = "select vchDecenaVariacion from NumeroNombre where tnyUnidad=" + Mid(vlstrNumerosinDecimales, X - 1, 1) + " and tnyDecena=" + Mid(vlstrNumerosinDecimales, X - 1, 1)
                                Set rsNombreNumero = frsRegresaRs(vlstrsql)
                                aNombreNumero(X - 2) = rsNombreNumero.Fields(0)
                                '
                                If vlstrNumeroaExaminar = "1" Then
                                    '------------------------------------
                                    ' VARIACION EN LA UNIDAD 1 'UNO' A 'UN'
                                    '------------------------------------
                                    vlstrsql = "select vchUnidadVariacion from NumeroNombre where tnyUnidad=1"
                                    Set rsNombreNumero = frsRegresaRs(vlstrsql)
                                    aNombreNumero(X - 1) = rsNombreNumero.Fields(0)
                                End If
                            Else
                                If Val(vlstrNumeroaExaminar) <= 5 Then
                                    '------------------------------------
                                    ' VARIACION EN LA DECENA 1 A 5 EJEM 'DIEZ UNO' A 'ONCE'
                                    '------------------------------------
                                    vlstrsql = "select vchDecenaVariacion from NumeroNombre where tnyUnidad=" + vlstrNumeroaExaminar + " and tnyDecena=1 and tnyCentena=0"
                                    Set rsNombreNumero = frsRegresaRs(vlstrsql)
                                    aNombreNumero(X - 2) = rsNombreNumero.Fields(0)
                                    aNombreNumero(X - 1) = ""
                                Else
                                    '------------------------------------
                                    ' VARIACION EN LA DECENA <> 1 EJ 'VEINTE' A 'VEINTI'
                                    '------------------------------------                                       '111X
                                    vlstrsql = "select vchDecenaVariacion from NumeroNombre where tnyUnidad=1"
                                    Set rsNombreNumero = frsRegresaRs(vlstrsql)
                                    aNombreNumero(X - 2) = rsNombreNumero.Fields(0)
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
        X = X + 1
    Loop

    fstrNumeroenLetras = ""
    X = 0
    Do While X <= 11
        If X = 2 Or X = 5 Or X = 8 Or X = 11 Then
            If Mid(vlstrNumerosinDecimales, X + 1, 1) <> "0" Then
                If Mid(vlstrNumerosinDecimales, X, 1) = "1" Or Mid(vlstrNumerosinDecimales, X, 1) = "2" Then
                    fstrNumeroenLetras = fstrNumeroenLetras + Trim(aNombreNumero(X))
                Else
                    If Trim(aNombreNumero(X)) <> "" Then
                        fstrNumeroenLetras = fstrNumeroenLetras + " " + Trim(aNombreNumero(X))
                    End If
                End If
            Else
                If Trim(aNombreNumero(X)) <> "" Then
                    fstrNumeroenLetras = fstrNumeroenLetras + " " + Trim(aNombreNumero(X))
                End If
            End If
        Else
            If Trim(aNombreNumero(X)) <> "" Then
                fstrNumeroenLetras = fstrNumeroenLetras + " " + Trim(aNombreNumero(X))
            End If
        End If
        If X = 2 Then
            If Trim(fstrNumeroenLetras) <> "" Then
                If Trim(aNombreNumero(0)) = "" And Trim(aNombreNumero(1)) = "" And Trim(aNombreNumero(2)) = "UN" Then
                    fstrNumeroenLetras = fstrNumeroenLetras + " BILLON"
                Else
                    fstrNumeroenLetras = fstrNumeroenLetras + " BILLONES"
                End If
            End If
        End If
        If X = 5 Then
            If Trim(fstrNumeroenLetras) <> "" Then
                If Trim(aNombreNumero(3)) <> "" Or Trim(aNombreNumero(4)) <> "" Or Trim(aNombreNumero(5)) <> "" Then
                    If Trim(aNombreNumero(3)) = "" And Trim(aNombreNumero(4)) = "" And Trim(aNombreNumero(5)) = "UN" Then
                        fstrNumeroenLetras = fstrNumeroenLetras + " MILLON"
                    Else
                        fstrNumeroenLetras = fstrNumeroenLetras + " MILLONES"
                    End If
                End If
            End If
        End If
        If X = 8 Then
            If Trim(fstrNumeroenLetras) <> "" Then
                If Trim(aNombreNumero(6)) <> "" Or Trim(aNombreNumero(7)) <> "" Or Trim(aNombreNumero(8)) <> "" Then
                    fstrNumeroenLetras = fstrNumeroenLetras + " MIL"
                End If
            End If
        End If
        X = X + 1
    Loop
    If Val(Mid(vlstrNumerosinDecimales, 1, 3)) <> 0 And Val(Mid(vlstrNumerosinDecimales, 4, 3)) = 0 And Val(Mid(vlstrNumerosinDecimales, 7, 3)) = 0 And Val(Mid(vlstrNumerosinDecimales, 10, 3)) = 0 Then
        fstrNumeroenLetras = Trim(fstrNumeroenLetras) + " DE " + UCase(vlstrMoneda) + " " + vlstrDecimales + " " + UCase(vlstrAgregadoaMoneda)
    Else
        If Val(Mid(vlstrNumerosinDecimales, 1, 3)) = 0 And Val(Mid(vlstrNumerosinDecimales, 4, 3)) <> 0 And Val(Mid(vlstrNumerosinDecimales, 7, 3)) = 0 And Val(Mid(vlstrNumerosinDecimales, 10, 3)) = 0 Then
            fstrNumeroenLetras = Trim(fstrNumeroenLetras) + " DE " + UCase(vlstrMoneda) + " " + vlstrDecimales + " " + UCase(vlstrAgregadoaMoneda)
        Else
            fstrNumeroenLetras = Trim(fstrNumeroenLetras) + " " + UCase(vlstrMoneda) + " " + vlstrDecimales + " " + UCase(vlstrAgregadoaMoneda)
        End If
    End If
End Function

Public Function fstrCantidadMoneda(vldblNumero As Double, vllngTamaño As Long) As String
    On Error GoTo NotificaError

    fstrCantidadMoneda = Space(vllngTamaño - Len(FormatNumber(str(vldblNumero), 2))) + FormatNumber(str(vldblNumero), 2)

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrCantidadMoneda"))
End Function

Public Function fstrNumeroJustificadoFormato(vldblNumero As Double, vllngTamaño As String) As String
   'Sirve para agregar espacios a una cantidad, sirve para justificar hacia la derecha
   'Si trae con formato se dara formato si pos no
   On Error GoTo NotificaError
   'vllngTamaño = $ #,###,###,###.##
   
   fstrNumeroJustificadoFormato = "$" & fstrNumeroJustificado(vldblNumero, Val(vllngTamaño))

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrNumeroJustificadoFormato"))
End Function

Public Function fblnRevisaPermiso(vllngxNumeroLogin As Long, vllngxNumeroOpcion As Long, vlstrxTipoPermiso As String, Optional vlblnNoMostrarMensaje As Boolean) As Boolean
'-------------------------------------------------------------------------------
' Validar si un login tiene permiso x a una opcion x o permiso de control total
'-------------------------------------------------------------------------------
    Dim rspermisodelusuario As New ADODB.Recordset
    Dim vlstrsql As String
    
    'If cgstrModulo = "SI" Then
    '    fblnRevisaPermiso = True
    '    Exit Function
    'End If

    If UCase(vgstrNombreUsuario) <> "ADMINISTRADOR" Then
        vlstrsql = "select chrPermiso from Permiso where intNumeroLogin=" + str(vllngxNumeroLogin) + " and intNumeroOpcion=" + str(vllngxNumeroOpcion)
        Set rspermisodelusuario = frsRegresaRs(vlstrsql)
        If rspermisodelusuario.RecordCount <> 0 Then
            If rspermisodelusuario!chrpermiso = vlstrxTipoPermiso Or rspermisodelusuario!chrpermiso = "C" Then
                fblnRevisaPermiso = True
            Else
                fblnRevisaPermiso = False
            End If
        Else
            fblnRevisaPermiso = False
        End If
    Else
        fblnRevisaPermiso = True
    End If
    
    If Not fblnRevisaPermiso Then
        If vlblnNoMostrarMensaje Then Exit Function
        If vlstrxTipoPermiso = "E" Then
            If vllngxNumeroOpcion <> 4167 And vllngxNumeroOpcion <> 4168 And vllngxNumeroOpcion <> 305 And vllngxNumeroOpcion <> 1532 Then
                MsgBox SIHOMsg(65), vbOKOnly + vbExclamation, "Mensaje"
            End If
        Else
            If vlstrxTipoPermiso = "L" Then
                If vllngxNumeroOpcion <> 4167 And vllngxNumeroOpcion <> 4168 And vllngxNumeroOpcion <> 305 And vllngxNumeroOpcion <> 1532 Then
                    MsgBox SIHOMsg(71), vbOKOnly + vbExclamation, "Mensaje"
                End If
            End If
        End If
    End If
End Function

Public Sub pBorrarRegMshFGrdData(vlintNumeroRenglonBorrar As Integer, grdNombre As MSHFlexGrid, Optional vlblnNolimpia As Boolean)
'--------------------------------------
'Funcion borrar un registro del grid sin que se pierda el rowdata
'--------------------------------------
    Dim acontenido() As Variant
    Dim X As Integer
    Dim z As Integer
    Dim Y As Integer
    Dim vlintColumnasArreglo As Integer
    Dim vlintRenglonesArreglo As Integer

    If grdNombre.Rows = 2 Then
        If vlblnNolimpia Then
            For vlintColumnasArreglo = 0 To grdNombre.Cols - 1
                grdNombre.TextMatrix(1, vlintColumnasArreglo) = ""
            Next
            grdNombre.RowData(1) = -1
        Else
            grdNombre.Rows = 0
        End If
    Else
        vlintRenglonesArreglo = grdNombre.Rows - 2
        vlintColumnasArreglo = grdNombre.Cols
        
        ReDim acontenido(vlintRenglonesArreglo, vlintColumnasArreglo)
        
        z = 0
        For X = 1 To grdNombre.Rows - 1
            If X <> vlintNumeroRenglonBorrar Then
                For Y = 0 To grdNombre.Cols
                    If Y = grdNombre.Cols Then
                        acontenido(z, Y) = grdNombre.RowData(X)
                    Else
                        acontenido(z, Y) = grdNombre.TextMatrix(X, Y)
                    End If
                Next Y
                z = z + 1
            End If
        Next X
    
        grdNombre.Rows = grdNombre.Rows - 1
    
        For X = 1 To vlintRenglonesArreglo
            For Y = 0 To vlintColumnasArreglo
                If Y = vlintColumnasArreglo Then
                    grdNombre.RowData(X) = acontenido(X - 1, Y)
                Else
                    grdNombre.TextMatrix(X, Y) = acontenido(X - 1, Y)
                End If
            Next Y
        Next X
    End If
End Sub

Function fblnFormatoCantidad(pstrTexto As TextBox, pintKeyascii As Integer, pbytDecimales As Byte) As Boolean
'--------------------------------------
'Funcion para validar que en una cantidad no se puedan poner mas de un punto
'y que le da formato a las cantidades ###,###,###,###.##
'y que sólo le pone el numero de digitos que le mandan por parametros
' Ultima modificación : 25/Oct/2001
'--------------------------------------
Dim vlintcontador As Integer 'Para la contada de los decimales
Dim vlblnTienePunto As Boolean 'Bandera para saber si la cantidad tiene punto
Dim vlstrFormato As String 'Texto para ver como quedaría el formato
Dim vlstrRollback As String
Dim vlintSelStart As Integer 'Temporal para no perder la posición del cursor

vlblnTienePunto = False 'Inicializada
vlstrFormato = "##,###,###,###,###"
pstrTexto.Text = RTrim(pstrTexto.Text) 'Quitar espacios
vlstrRollback = pstrTexto.Text
fblnFormatoCantidad = True

If Not pintKeyascii = vbKeyBack And Not pintKeyascii = vbKeyReturn Then
    If IsNumeric(Chr(pintKeyascii)) Or pintKeyascii = 46 Then
        If pbytDecimales = 0 And pintKeyascii = 46 Then
           fblnFormatoCantidad = False
        Else
            If pstrTexto.SelLength = 0 Or pstrTexto.SelLength <> Len(pstrTexto.Text) Then
                For vlintcontador = 1 To Len(pstrTexto.Text)
                    If Mid(pstrTexto.Text, vlintcontador, 1) = "." Then
                        If Len(Mid(pstrTexto.Text, vlintcontador)) = pbytDecimales + 1 Or pintKeyascii = 46 Then
                            If Not pintKeyascii = vbKeyBack And Not pintKeyascii = vbKeyReturn Then
                                If (vlblnTienePunto And pintKeyascii = 46) Or (pstrTexto.SelStart > Len(pstrTexto.Text) - pbytDecimales + 1) Then
                                    fblnFormatoCantidad = False
                                    vlintcontador = Len(pstrTexto.Text) + 1
                                End If
                            End If
                        End If
                        vlblnTienePunto = True
                    Else
                        fblnFormatoCantidad = True
                    End If
                Next
            Else
                fblnFormatoCantidad = True
            End If
        End If
    Else
        fblnFormatoCantidad = False
    End If
    
    If fblnFormatoCantidad And Not pintKeyascii = 46 Then
        If Val(pstrTexto.Text) > 0 Then
            If pstrTexto.SelLength = Len(RTrim(pstrTexto.Text)) Then
                pstrTexto.Text = Chr(pintKeyascii)
            Else
                pstrTexto.Text = Mid(pstrTexto.Text, 1, pstrTexto.SelStart) & Chr(pintKeyascii) & Mid(pstrTexto.Text, pstrTexto.SelStart + 1, Len(pstrTexto.Text))
            End If
                                
            vlintSelStart = Len(pstrTexto.Text)
            
            If vlblnTienePunto Then
                If pbytDecimales > 0 Then
                    vlstrFormato = vlstrFormato & "."
                    For vlintcontador = 1 To pbytDecimales
                        vlstrFormato = vlstrFormato & "0"
                    Next
                End If
            Else
                vlintSelStart = Len(pstrTexto.Text)
            End If
            pintKeyascii = 0
            pstrTexto.SelStart = vlintSelStart
            
        End If
    Else
        If pintKeyascii = 46 Then
            If pstrTexto.SelLength = Len(RTrim(pstrTexto.Text)) Then
                pstrTexto.Text = Chr(pintKeyascii)
            Else
                pstrTexto.Text = Mid(pstrTexto.Text, 1, pstrTexto.SelStart) & Chr(pintKeyascii) & Mid(pstrTexto.Text, pstrTexto.SelStart + 1, Len(pstrTexto.Text))
            End If
            If Not IsNumeric(Format(pstrTexto.Text, "#############")) And pstrTexto.Text <> "." And pstrTexto.Text <> "0." Then
                pstrTexto.Text = vlstrRollback
            End If
            pintKeyascii = 0
            pstrTexto.SelStart = Len(pstrTexto.Text)
        End If
    End If
Else
    If pintKeyascii = vbKeyReturn Then 'Para que sólo se ejecute con un ENTER
        If pbytDecimales > 0 Then
            vlstrFormato = vlstrFormato & "."
            For vlintcontador = 1 To pbytDecimales
                vlstrFormato = vlstrFormato & "0"
            Next
        End If
        pstrTexto.Text = Format(pstrTexto.Text, vlstrFormato)
        fblnFormatoCantidad = True
        pstrTexto.SelStart = Len(pstrTexto.Text)
    End If
End If

End Function

Public Function SIHOMsg(numero As Integer) As String
    Dim rsMensaje As New ADODB.Recordset
    Dim vlstrSentencia As String
    
    vlstrSentencia = "select vchMensaje from Mensaje where intNumeroMensaje=" + str(numero)
    SIHOMsg = ""
    Set rsMensaje = frsRegresaRs(vlstrSentencia)
    If rsMensaje.RecordCount <> 0 Then
        SIHOMsg = rsMensaje!vchmensaje
    Else
        SIHOMsg = "No se ha registrado el mensaje: " & numero & "." & vbCrLf & "Favor de avisar al área de sistemas."
    End If
End Function

Public Sub pRegistraError(intNumError As Long, strDescripError, strModulo As String, strForm As String, Optional strParametros As String = " ", Optional blnRollback As Boolean = True)
'-------------------------------------------------------------------------------------------
' Permite crear un registro conteniendo el error ocurrido en VB
'-------------------------------------------------------------------------------------------
    Dim strParametrosSP As String
    Dim vlDllError As String
    Dim vlMensajeFinal As String
    Dim vlErrSource As String
    Dim vlErrNumber As Long
    Dim vlErrDescription As String
    
    vlErrSource = Trim(Err.Source)
    vlErrNumber = Err.Number
    vlErrDescription = Trim(Err.Description)
    vlDllError = Err.LastDllError
    
    On Error Resume Next
    If blnRollback Then
       EntornoSIHO.ConeccionSIHO.RollbackTrans
    End If
    
On Error GoTo NotificaError
        
    vlMensajeFinal = ""
        
    strForm = Replace(strForm, "|Linea:", " Linea:")
    strForm = Replace(strForm, ", Linea:", " Linea:")
    strForm = Replace(strForm, ",Linea:", " Linea:")
        
    If Trim(vgstrNombreUsuario) <> "" Then vlMensajeFinal = vlMensajeFinal & Chr(13) & "Usuario: " & Trim(vgstrNombreUsuario)
    If Trim(vgstrNombreDepartamento) <> "" Then vlMensajeFinal = vlMensajeFinal & Chr(13) & "Departamento: " & Trim(vgstrNombreDepartamento)
    If Trim(strModulo) <> "" Then vlMensajeFinal = vlMensajeFinal & Chr(13) & Trim("Módulo: " & Trim(strModulo) & " " & App.Major & "." & App.Minor & "." & App.Revision)
    If Trim(strForm) <> "" Then vlMensajeFinal = vlMensajeFinal & Chr(13) & "Forma: " & Trim(Replace(strForm, ":", " "))
    If Trim(strParametros) <> "" Then vlMensajeFinal = vlMensajeFinal & Chr(13) & "Parámetros: " & Trim(Replace(strParametros, "|", "_"))
    If vlErrSource <> "" Then vlMensajeFinal = vlMensajeFinal & Chr(13) & "Err.Source: " & vlErrSource
    If vlErrNumber <> 0 Then vlMensajeFinal = vlMensajeFinal & Chr(13) & "Err.Number: " & vlErrNumber
    If vlErrDescription <> "" Then vlMensajeFinal = vlMensajeFinal & Chr(13) & "Err.Description: " & vlErrDescription
    
    strParametrosSP = intNumError & "|" & Left(Trim(vlMensajeFinal), 200) & "|" & strModulo & "|" & Left(strForm, 50) & "|" & Left(Replace(strParametros, "|", "_"), 500)
    frsEjecuta_SP strParametrosSP, "SP_GNINSREGISTROERRORES", True

    Call MsgBox(SIHOMsg(1) & Chr(13) & Chr(13) & vlMensajeFinal, vbExclamation, "Mensaje")

    Err.Clear

    Exit Sub
NotificaError:
    Exit Sub
End Sub

Public Function fstrFormatTxt(vlstrTexto, vlstrTipoTexto, vlstrForma As String, vlintTamano As Integer, vlblnPermiteEsp As Boolean) As String
'----------------------------------------------------------------------------------------------------------
' Da un formato al texto según criterio
'----------------------------------------------------------------------------------------------------------
' vlstrTipo Tipo de dato a validar T-Texto,N-Númerico,F-Fecha,A-Alfabético,M-Moneda,*-Cualquier caracter
' vlstrForma La forma > pasar a Mayúsculas, < pasar a Minúsculas, P la primera letra en mayusculas
' vlintTamano Tamano máximo que puede alcanzar el texto
' vlblnPermiteEsp Si nos permite espacios dentro del texto
'----------------------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintLargo As Integer 'Tamaño del texto
    Dim vlintseq As Integer 'Contador de caracteres
    Dim vlstrResultado As String 'Resultado de la función
    Dim vlblnEspacioAnt As Boolean 'Si hubo espacio anteriormente
    Dim vlstrcaracter As String 'El caracter a revisar
    
    vlintLargo = Len(vlstrTexto)
    If vlintLargo > 0 Then
        'Revisión del tipo de texto
        For vlintseq = 1 To vlintLargo
            vlstrcaracter = Mid(vlstrTexto, vlintseq, 1)
            Select Case vlstrTipoTexto
                Case "A" 'Alfabetico
                    If fblnVerificaAlfabetico(Asc(vlstrcaracter)) Then
                        vlstrResultado = vlstrResultado & vlstrcaracter
                    End If
                Case "AE" 'Alfabetico
                    If fblnVerificaAlfabeticoE(Asc(vlstrcaracter)) Then
                        vlstrResultado = vlstrResultado & vlstrcaracter
                    End If
                    
                Case "T" 'Alfanúmerico
                    If fblnVerificaAlfanumerico(Asc(vlstrcaracter)) Then
                        vlstrResultado = vlstrResultado & vlstrcaracter
                    End If
                Case "N" 'Númerico
                    If fblnVerificaNumerico(Asc(vlstrcaracter)) Then
                        vlstrResultado = vlstrResultado & vlstrcaracter
                    End If
                Case "F" 'Fecha
                    If fblnVerificaFecha(Asc(vlstrcaracter)) Then
                        vlstrResultado = vlstrResultado & vlstrcaracter
                    End If
                Case "H" 'Hora
                    If fblnVerificaHora(Asc(vlstrcaracter)) Then
                        vlstrResultado = vlstrResultado & vlstrcaracter
                    End If
                Case "M" 'Moneda
                    If fblnVerificaMoneda(Asc(vlstrcaracter)) Then
                        vlstrResultado = vlstrResultado & vlstrcaracter
                    End If
                    
                Case "*" 'Fecha
                    vlstrResultado = vlstrResultado & vlstrcaracter
            End Select
        Next vlintseq
        
        vlstrTexto = vlstrResultado
        vlintLargo = Len(vlstrTexto)
        vlstrResultado = ""
        
        'Revisión de la forma
        If Len(vlstrForma) > 0 Then
            Select Case vlstrForma
                Case ">" '> Mayúsculas
                    vlstrResultado = UCase(vlstrTexto)
                Case "<" '< Minúsculas
                    vlstrResultado = LCase(vlstrTexto)
                Case "P" 'Propio
                    For vlintseq = 1 To vlintLargo
                        vlstrcaracter = Mid(vlstrTexto, vlintseq, 1)
                        If (vlintseq = 1) Then
                            vlstrResultado = vlstrResultado & UCase(vlstrcaracter)
                        Else
                            vlstrResultado = vlstrResultado & LCase(vlstrcaracter)
                        End If
                    Next vlintseq
            End Select
            vlstrTexto = vlstrResultado
            vlintLargo = Len(vlstrTexto)
            vlstrResultado = ""
        End If
    
        'Revision de los Espacios
        vlstrResultado = LTrim(RTrim(vlstrTexto))
        
        'Quitar espacios extras en la frase
        vlstrTexto = vlstrResultado
        vlintLargo = Len(vlstrTexto)
        vlstrResultado = ""
        vlblnEspacioAnt = False
    
        If vlblnPermiteEsp Then 'Elimina los espacios extras no necesarios dentro de la frase
            For vlintseq = 1 To vlintLargo
                vlstrcaracter = Mid(vlstrTexto, vlintseq, 1)
                If Asc(vlstrcaracter) = 32 Then
                    If vlblnEspacioAnt Then
                        vlblnEspacioAnt = True
                    Else
                        vlblnEspacioAnt = True
                        vlstrResultado = vlstrResultado & vlstrcaracter
                    End If
                Else
                    vlstrResultado = vlstrResultado & vlstrcaracter
                    vlblnEspacioAnt = False
                End If
            Next vlintseq
        Else 'Elimina todos los espacios de la frase
            For vlintseq = 1 To vlintLargo
                vlstrcaracter = Mid(vlstrTexto, vlintseq, 1)
                If Asc(vlstrcaracter) <> 32 Then
                    vlstrResultado = vlstrResultado & vlstrcaracter
                End If
            Next vlintseq
        End If
        'Quitar el exceso de carateres
        vlstrResultado = Left(vlstrResultado, vlintTamano)
        
        Select Case vlstrTipoTexto
            Case "F"
                If Len(vlstrResultado) = 8 Or Len(vlstrResultado) = 10 Then
                    fstrFormatTxt = vlstrResultado
                Else
                    fstrFormatTxt = ""
                End If
            Case "H"
                If Len(vlstrResultado) = 5 Or Len(vlstrResultado) = 8 Then
                    fstrFormatTxt = vlstrResultado
                Else
                    fstrFormatTxt = ""
                End If
            Case Else
                fstrFormatTxt = vlstrResultado
        End Select
    End If
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrFormatTxt"))
End Function

Public Function fblnVerificaAlfabetico(vlintCaracter As Integer) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica si el caracter es alfabetico o no
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
   
    If ((vlintCaracter >= 65 And vlintCaracter <= 90) Or _
        (vlintCaracter >= 97 And vlintCaracter <= 122) Or _
        vlintCaracter = 130 Or vlintCaracter = 160 Or vlintCaracter = 161 Or _
        vlintCaracter = 162 Or vlintCaracter = 163 Or vlintCaracter = 164 Or _
        vlintCaracter = 225 Or vlintCaracter = 233 Or vlintCaracter = 237 Or _
        vlintCaracter = 243 Or vlintCaracter = 250 Or vlintCaracter = 241 Or _
        vlintCaracter = 209 Or vlintCaracter = 193 Or vlintCaracter = 201 Or _
        vlintCaracter = 205 Or vlintCaracter = 211 Or vlintCaracter = 218 Or _
        vlintCaracter = 64 Or vlintCaracter = 44 Or vlintCaracter = 47 Or _
        vlintCaracter = 46 Or vlintCaracter = 42 Or vlintCaracter = 32 Or _
        vlintCaracter = 58 Or vlintCaracter = 35 Or vlintCaracter = 45) Then
       fblnVerificaAlfabetico = True
    Else
        fblnVerificaAlfabetico = False
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnVerificaAlfabetico"))
End Function

Public Function fblnVerificaAlfabeticoE(vlintCaracter As Integer) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica si el caracter es alfabetico o no
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
   
    If ((vlintCaracter >= 65 And vlintCaracter <= 90) Or _
        (vlintCaracter >= 97 And vlintCaracter <= 122) Or _
        vlintCaracter = 130 Or vlintCaracter = 160 Or vlintCaracter = 161 Or _
        vlintCaracter = 162 Or vlintCaracter = 163 Or vlintCaracter = 164 Or _
        vlintCaracter = 225 Or vlintCaracter = 233 Or vlintCaracter = 237 Or _
        vlintCaracter = 243 Or vlintCaracter = 250 Or vlintCaracter = 241 Or _
        vlintCaracter = 209 Or vlintCaracter = 193 Or vlintCaracter = 201 Or _
        vlintCaracter = 205 Or vlintCaracter = 211 Or vlintCaracter = 218 Or _
        vlintCaracter = 32) Then
        
       fblnVerificaAlfabeticoE = True
    Else
        fblnVerificaAlfabeticoE = False
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnVerificaAlfabeticoE"))
End Function

Public Function fblnVerificaAlfanumerico(vlintCaracter As Integer) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica si el caracter es alfanúmerico
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    If ((vlintCaracter >= 65 And vlintCaracter <= 90) Or _
        (vlintCaracter >= 97 And vlintCaracter <= 122) Or _
        (vlintCaracter >= 48 And vlintCaracter <= 57) Or _
        vlintCaracter = 130 Or vlintCaracter = 160 Or vlintCaracter = 161 Or _
        vlintCaracter = 162 Or vlintCaracter = 163 Or vlintCaracter = 164 Or _
        vlintCaracter = 225 Or vlintCaracter = 233 Or vlintCaracter = 237 Or _
        vlintCaracter = 243 Or vlintCaracter = 250 Or vlintCaracter = 241 Or _
        vlintCaracter = 209 Or vlintCaracter = 193 Or vlintCaracter = 201 Or _
        vlintCaracter = 205 Or vlintCaracter = 211 Or vlintCaracter = 218 Or _
        vlintCaracter = 64 Or vlintCaracter = 44 Or vlintCaracter = 47 Or _
        vlintCaracter = 46 Or vlintCaracter = 42 Or vlintCaracter = 32 Or _
        vlintCaracter = 58 Or vlintCaracter = 35 Or vlintCaracter = 45 Or _
        vlintCaracter = 37 Or vlintCaracter = 38 Or vlintCaracter = 95) Then
        'ojo procedimiento modificado con el car 37 para que acepte el % y el 38 para el &
        'se agrega el "_" car 95 :cgr
        
       fblnVerificaAlfanumerico = True
    Else
        fblnVerificaAlfanumerico = False
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnVerificaAlfanumerico"))
End Function
Public Function fblnVerificaNumerico(vlintCaracter As Integer) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica si el caracter es númerico
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    If (vlintCaracter >= 48 And vlintCaracter <= 57) Or vlintCaracter = 46 Or vlintCaracter = 44 Then
        fblnVerificaNumerico = True
    Else
        fblnVerificaNumerico = False
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnVerificaNumerico"))
End Function
Public Function fblnVerificaMoneda(vlintCaracter As Integer) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica si el caracter es para ingreso de moneda
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    If ((vlintCaracter >= 48 And vlintCaracter <= 57) Or _
        vlintCaracter = 44 Or vlintCaracter = 46 Or vlintCaracter = 205) Then
        fblnVerificaMoneda = True
    Else
        fblnVerificaMoneda = False
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnVerificaMoneda"))
End Function

Public Function fblnVerificaFecha(vlintCaracter As Integer) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica si el caracter es para ingreso de fecha
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    If ((vlintCaracter >= 48 And vlintCaracter <= 57) Or _
        vlintCaracter = 47) Then
        fblnVerificaFecha = True
    Else
        fblnVerificaFecha = False
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnVerificaFecha"))
End Function

Public Function fblnVerificaHora(vlintCaracter As Integer) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica si el caracter es para ingreso de fecha
' 46 es .  58 es : y 48 al 57 numeros
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    If ((vlintCaracter >= 48 And vlintCaracter <= 57) Or _
        vlintCaracter = 46 Or vlintCaracter = 58) Then
        fblnVerificaHora = True
    Else
        fblnVerificaHora = False
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnVerificaHora"))
End Function

Public Sub pEnfocaMkTexto(ObjMkTexto As MaskEdBox)
'-------------------------------------------------------------------------------------------
' Selecciona el texto del un campo MaskEdBox y lo enfoca
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError

    With ObjMkTexto
        If .Visible And .Enabled Then
            .SelStart = 0
            .SelLength = Len(ObjMkTexto.Text)
            .SetFocus
        End If
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEnfocaMkTexto"))
End Sub

Public Sub pEnfocaTextBox(ObjTexto As TextBox)
'-------------------------------------------------------------------------------------------
' Selecciona el texto del un campo MaskEdBox y lo enfoca
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    With ObjTexto
        If .Enabled And .Visible Then
        .SelStart = 0
        .SelLength = Len(ObjTexto.Text)
        .SetFocus
        End If
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEnfocaTextBox"))
End Sub

Public Sub pRefrescaMshFGrid(ObjGrid As MSHFlexGrid, vlintNumReg As Integer)
'-------------------------------------------------------------------------------------------
' Refresca el grid y lo enfoca
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError

    ObjGrid.SetFocus
    If vlintNumReg > 0 Then
        ObjGrid.Row = 1
        ObjGrid.Col = 1
    End If
    ObjGrid.Refresh
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pRefrescaMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pOrdColMshFGrid(ObjGrid As MSHFlexGrid, vlintTipoOrd As Integer)
'-------------------------------------------------------------------------------------------
' Permite Ordenar un MSHFlexGrid por una columna y un tipo de ordenación especificos
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    ObjGrid.FocusRect = flexFocusNone
    With ObjGrid
        .Redraw = False
        .Row = 1
        .RowSel = .Rows - 1
        .Sort = vlintTipoOrd
        .Redraw = True
    End With
    ObjGrid.FocusRect = flexFocusHeavy
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pOrdColMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pDesSelMshFGrid(ObjGrid As MSHFlexGrid)
'-------------------------------------------------------------------------------------------
' Limpia completamente las selecciones del Grid
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlintNumFilas As Long 'Almacena el número de filas que tiene el grid
    Dim vlintSeqC As Integer 'Contador para el número de columnas
    Dim vlintSeqF As Long 'Contador para el número de filas
    Dim vlintNumColumnas As Integer 'Almacena el número de columnas que tiene el grid
    
    ObjGrid.Redraw = False
    ObjGrid.FocusRect = flexFocusNone
    vlintNumColumnas = ObjGrid.Cols - 1
    vlintNumFilas = ObjGrid.Rows - 1
    For vlintSeqF = 1 To vlintNumFilas
        For vlintSeqC = 1 To vlintNumColumnas
            ObjGrid.Row = vlintSeqF
            ObjGrid.Col = vlintSeqC
            ObjGrid.CellBackColor = vbWindowBackground
            ObjGrid.CellForeColor = vbWindowText
        Next vlintSeqC
    Next vlintSeqF

    ObjGrid.BackColorSel = vbWindowBackground
    ObjGrid.ForeColorSel = vbWindowText
    
    ObjGrid.Row = 1
    ObjGrid.Col = 1
    ObjGrid.FocusRect = flexFocusHeavy
    ObjGrid.Redraw = True
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pDesSelMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Function fintSigNumRs(ObjRS As Recordset, vlintNumPkey As Integer) As Double
'-----------------------------------------------------------------------------------------------
' Función que busca el último registro del recordset y le agrega uno (para efectos de visualizar
' en pantalla el siguiente consecutivo
'-----------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlstrCampo As String
    Dim vlstrNombreCampo As String
    Dim vldblSigNumRs, vldblPrecision As Double
    
    vldblPrecision = fdblTipoNumPrecision(ObjRS.Fields(vlintNumPkey).Type)
    
    vlstrNombreCampo = ObjRS.Fields(vlintNumPkey).Name
    vlstrCampo = vlstrNombreCampo & " Asc"
    If ObjRS.RecordCount > 0 Then
        ObjRS.Sort = vlstrCampo
        ObjRS.MoveLast
        vldblSigNumRs = ObjRS.Fields(vlintNumPkey) + 1
    Else
        vldblSigNumRs = 1
    End If
    
    If vldblSigNumRs > vldblPrecision Then
        Call pRegistraError(0, ("El tipo de dato a llegado a su rango-límite:" & ObjRS.Fields(vlintNumPkey).Name) & ", con el tipo " & ObjRS.Fields(vlintNumPkey).Type & " y un limite de " & vldblPrecision, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintSigNumRs"))
        fintSigNumRs = 0
    Else
        fintSigNumRs = vldblSigNumRs
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintSigNumRs"))
End Function

Public Function fintLocalizaPkRs(ObjRS As Recordset, vlintNumPkey As Integer, vlstrCriterio As String) As Long
'-------------------------------------------------------------------------------------------
' Función para Localizar un criterio dentro de un recorset, retornando el bookmark y
' y posicionandose en el registro buscado
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlblnResul As Boolean
    Dim vlstrNombreCampo As String
    Dim vlstrCriterioBus As String
    
    If ObjRS.RecordCount > 0 Then
        vlstrNombreCampo = ObjRS.Fields(vlintNumPkey).Name
        If InStr(1, vlstrCriterio, Chr(39)) > 0 Then
            vlstrCriterio = Replace(vlstrCriterio, "'", "''")
        End If
        vlstrCriterioBus = vlstrNombreCampo & " = '" & vlstrCriterio & "'"
        ObjRS.MoveFirst
        ObjRS.Find vlstrCriterioBus
        If ObjRS.EOF Or ObjRS.BOF Then
            fintLocalizaPkRs = 0
        Else
            fintLocalizaPkRs = ObjRS.Bookmark
        End If
    Else
        fintLocalizaPkRs = 0
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintLocalizaPkRs"))
End Function

Public Sub pSelCriterioMshFGrid(ObjGrid As MSHFlexGrid, vlintColLoc As Integer, vlintCaracter As Integer)
'-------------------------------------------------------------------------------------------
' Realiza la busqueda de un criterio en el grid
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    ObjGrid.Redraw = False

    ObjGrid.FocusRect = flexFocusNone
    
    'Verifica los alfabeticos a-z, A-Z,0-9,ñÑ,áéíóúÁÉÍÓÚ,@/.=
    If ((vlintCaracter >= 65 And vlintCaracter <= 90) Or _
        (vlintCaracter >= 97 And vlintCaracter <= 122) Or _
        (vlintCaracter >= 48 And vlintCaracter <= 57) Or _
        vlintCaracter = 130 Or vlintCaracter = 160 Or vlintCaracter = 161 Or _
        vlintCaracter = 162 Or vlintCaracter = 163 Or vlintCaracter = 164 Or _
        vlintCaracter = 225 Or vlintCaracter = 233 Or vlintCaracter = 237 Or _
        vlintCaracter = 243 Or vlintCaracter = 250 Or vlintCaracter = 241 Or _
        vlintCaracter = 209 Or vlintCaracter = 193 Or vlintCaracter = 201 Or _
        vlintCaracter = 205 Or vlintCaracter = 211 Or vlintCaracter = 218 Or _
        vlintCaracter = 64 Or vlintCaracter = 44 Or vlintCaracter = 47 Or _
        vlintCaracter = 46 Or vlintCaracter = 42 Or vlintCaracter = 32) Then
        
        vgstrAcumTextoBusqueda = vgstrAcumTextoBusqueda & Chr(vlintCaracter)
        Call pLocalizaTxtMshFGrid(ObjGrid, vgstrAcumTextoBusqueda, vlintColLoc)
    Else
        If (vlintCaracter = 8) Then
            If Len(vgstrAcumTextoBusqueda) > 0 Then
                vgstrAcumTextoBusqueda = Left(vgstrAcumTextoBusqueda, (Len(vgstrAcumTextoBusqueda) - 1))
                If Len(vgstrAcumTextoBusqueda) > 0 Then
                    Call pLocalizaTxtMshFGrid(ObjGrid, vgstrAcumTextoBusqueda, vlintColLoc)
                Else
                    Call pDesSelMshFGrid(ObjGrid)
                End If
            Else
                Call pDesSelMshFGrid(ObjGrid)
            End If
        End If
    End If
    ObjGrid.Refresh
    ObjGrid.Col = vlintColLoc
    ObjGrid.FocusRect = flexFocusHeavy
    ObjGrid.Redraw = True

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pSelCriterioMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pLocalizaTxtMshFGrid(ObjGrid As MSHFlexGrid, vlstrCriterio As String, vlintColBus As Integer)
'-------------------------------------------------------------------------------------------
' Realiza la busqueda de un criterio dentro de una de las columnas del grdHBusqueda
' señalando los criterios encontrados
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumFilas As Integer 'Almacena el número de filas que contiene el grdHBusqueda
    Dim vlintseq As Integer 'Contador del número de filas del grdHBusqueda
    Dim vlintEFila As Integer 'Fila que se encuentra mediante el criterio de búsqueda
    Dim vlintLargo As Integer 'Almacena el largo del criterio de búsqueda
    Dim vlstrTexto As String 'Almacena los caracteres obtenidos de las celda del grid, segun el largo de busqueda del criterio, para su comparacion con el criterio de búsqueda
    
    ObjGrid.Redraw = False
    vlintLargo = Len(vlstrCriterio)
    vlintEFila = 0 'Inicializa la búsqueda desde la primera fila
    With ObjGrid
      If .Rows > 0 Then
        vlintNumFilas = .Rows - 1
        If vlintLargo > 0 Then
            For vlintseq = 1 To vlintNumFilas 'Realiza la búsqueda en todo el grid
                vlstrTexto = Left(.TextMatrix(vlintseq, vlintColBus), vlintLargo)
                If UCase(vlstrCriterio) = UCase(vlstrTexto) Then
                    If vlintLargo > 0 Then
                        Call pSelFilaMshFGrid(ObjGrid, vlintseq)
                        vlintEFila = vlintseq
                    End If
                Else
                    If vlintLargo > 0 Then
                        Call pDesSelFilaMshFGrid(ObjGrid, vlintseq)
                    End If
                End If
            Next vlintseq
            .Row = vlintEFila
            .Col = vlintColBus
            If vlintEFila > 0 Then
                .TopRow = vlintEFila
            Else
                vgstrAcumTextoBusqueda = ""
                .Row = 1
                .TopRow = 1
                .Col = 1
            End If
        End If
      End If
      .Redraw = True
    End With
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLocalizaTxtMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pDesSelFilaMshFGrid(ObjGrid As MSHFlexGrid, vlintNumFila As Integer)
'-------------------------------------------------------------------------------------------
' Quita la selección de una determinada fila dentro del grid
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlintNumColumnas As Integer 'Almacena el número de columnas del grid
    Dim vlintSeqC As Integer 'Contador para el número de columnas del grid
    'vlintFila Almacena a que fila se quitará la selección
    ObjGrid.Redraw = False
    ObjGrid.FocusRect = flexFocusNone
    vlintNumColumnas = ObjGrid.Cols - 1
    For vlintSeqC = 1 To vlintNumColumnas
        ObjGrid.Row = vlintNumFila
        ObjGrid.Col = vlintSeqC
        ObjGrid.CellBackColor = vbWindowBackground
        ObjGrid.CellForeColor = vbWindowText
    Next vlintSeqC
    ObjGrid.FocusRect = flexFocusHeavy
    ObjGrid.Redraw = True
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pDesSelFilaMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pSelFilaMshFGrid(ObjGrid As MSHFlexGrid, vlintNumFila As Integer)
'-------------------------------------------------------------------------------------------
' Realiza la seleccion de una fila determinada dentro del grid
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlintNumColumnas As Integer
    Dim vlintSeqC As Integer
    
    'vlintFila Almacena a que fila se dará la selección
    ObjGrid.Redraw = False
    ObjGrid.FocusRect = flexFocusNone
    vlintNumColumnas = ObjGrid.Cols - 1
    For vlintSeqC = 1 To vlintNumColumnas
        ObjGrid.Row = vlintNumFila
        ObjGrid.Col = vlintSeqC
        ObjGrid.CellBackColor = vbWindowBackground
        ObjGrid.CellForeColor = vbWindowText
        ObjGrid.CellBackColor = vbActiveTitleBar
        ObjGrid.CellForeColor = vbActiveTitleBarText
    Next vlintSeqC
    ObjGrid.FocusRect = flexFocusHeavy
    ObjGrid.Redraw = True
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pSelFilaMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pPosicionaRegRs(ObjRS As Recordset, vlstrPosicion As String)
'-------------------------------------------------------------------------------------------
' Posiciona en el primer, anterior, siguiente y último registro de un recordset
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    If ObjRS.RecordCount > 0 Then
        Select Case vlstrPosicion
            Case "I" 'Mueve al primer registro
                ObjRS.MoveFirst
            Case "A" 'Mueve al registro anterior
                ObjRS.MovePrevious
                If ObjRS.BOF Or ObjRS.EOF Then
                    ObjRS.MoveFirst
                End If
            Case "S" 'Mueve al registro siguiente
                ObjRS.MoveNext
                If ObjRS.BOF Or ObjRS.EOF Then
                    ObjRS.MoveLast
                End If
            Case "U" 'Mueve al último registro
                ObjRS.MoveLast
        End Select
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pPosicionaRegRs"))
End Sub

Public Function fintLocalizaCbo(ObjCbo As ComboBox, vlstrCriterio As String) As Integer
'-------------------------------------------------------------------------------------------
' Busca un criterio dentro del combobox -1 indica que no encontro
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumReg As Integer
    Dim vlintseq As Integer
    
    fintLocalizaCbo = -1
    vlintNumReg = ObjCbo.ListCount
    If Len(vlstrCriterio) > 0 Then
        For vlintseq = 0 To vlintNumReg - 1
            If ObjCbo.ItemData(vlintseq) = vlstrCriterio Then
                fintLocalizaCbo = vlintseq
                Exit For
            Else
                fintLocalizaCbo = -1
            End If
        Next vlintseq
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintLocalizaCbo" & " " & ObjCbo.Name))
End Function

Public Function fintLocalizaCritCbo(ObjCbo As ComboBox, vlstrCriterio As String) As Integer
'-------------------------------------------------------------------------------------------
' Busca un criterio dentro del combobox en el campo list
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumReg As Integer
    Dim vlintseq As Integer
    
    vlintNumReg = ObjCbo.ListCount
    If Len(vlstrCriterio) > 0 Then
        For vlintseq = 0 To vlintNumReg
            If ObjCbo.List(vlintseq) = vlstrCriterio Then
                fintLocalizaCritCbo = vlintseq
                Exit For
            Else
                fintLocalizaCritCbo = -1
            End If
        Next vlintseq
    Else
        fintLocalizaCritCbo = -1
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintLocalizaCritCbo" & " " & ObjCbo.Name))
End Function

Public Function fintLocalizaLst(ObjLst As ListBox, vlstrCriterio As String) As Integer
'-------------------------------------------------------------------------------------------
' Busca un criterio dentro del combobox -1 indica que no encontro
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumReg As Integer
    Dim vlintseq As Integer
    
    vlintNumReg = ObjLst.ListCount
    If Len(vlstrCriterio) > 0 Then
        For vlintseq = 0 To vlintNumReg - 1
            If ObjLst.ItemData(vlintseq) = vlstrCriterio Then
                fintLocalizaLst = vlintseq
                Exit For
            Else
                fintLocalizaLst = -1
            End If
        Next vlintseq
    Else
        fintLocalizaLst = -1
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintLocalizaLst" & " " & ObjLst.Name))
End Function

Public Function fintLocalizaTxtCbo(ObjCbo As ComboBox, vlstrCriterio As String) As Integer
'-------------------------------------------------------------------------------------------
' Busca un criterio que sea la primera coincidencia del list dentro del combobox
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumReg As Integer
    Dim vlintseq As Integer
    Dim vlintLargo As Integer
    
    vlintNumReg = ObjCbo.ListCount
    If Len(vlstrCriterio) > 0 Then
        vlintLargo = Len(vlstrCriterio)
        For vlintseq = 0 To vlintNumReg
            If UCase(Left(ObjCbo.List(vlintseq), vlintLargo)) = UCase(vlstrCriterio) Then
                fintLocalizaTxtCbo = vlintseq
                Exit For
            Else
                fintLocalizaTxtCbo = -1
            End If
        Next vlintseq
    Else
        fintLocalizaTxtCbo = -1
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintLocalizaTxtCbo" & " " & ObjCbo.Name))
End Function

Public Sub pEnfocaCbo(ObjCbo As ComboBox)
'-------------------------------------------------------------------------------------------
' Enfoca el Combo box
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError

    If ObjCbo.Enabled And ObjCbo.Visible Then ObjCbo.SetFocus

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEnfocaCbo" & " " & ObjCbo.Name))
End Sub

Public Sub pValidaTextBox(ObjTxt As TextBox, vlstrTipo, vlstrForma As String, vlintTamano As Integer, vlblnPermiteEsp As Boolean)
'-------------------------------------------------------------------------------------------------
' Valida que un objeto TextBox no se encuentre vacio, y presenta un error si lo esta
' vlstrTipo Tipo de dato a validar T-Texto,N-Númerico,F-Fecha,A-Alfabético
' vlstrForma La forma > pasar a Mayúsculas, < pasar a Minúsculas, P la primera letra en mayusculas
' vlintTamano Tamano máximo que puede alcanzar el texto
' vlblnPermiteEsp Si nos permite espacios dentro del texto
'-------------------------------------------------------------------------------------------------
    On Error GoTo NotificaError

    Dim vlstrMensaje As String
    ObjTxt.Text = fstrFormatTxt(ObjTxt.Text, vlstrTipo, vlstrForma, vlintTamano, vlblnPermiteEsp)
    If Len(ObjTxt.Text) = 0 Then
        vgblnErrorIngreso = True
        vlstrMensaje = SIHOMsg(2) & Chr(13) & "Dato:" & ObjTxt.ToolTipText
        Call MsgBox(vlstrMensaje, vbExclamation, "Mensaje")
    Else
        vgblnErrorIngreso = False
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pValidaTextBox"))
End Sub

Public Function fblnValidaTextBox(ObjTxt As TextBox, vlstrTipo, vlstrForma As String, vlintTamano As Integer, vlblnPermiteEsp As Boolean) As Boolean
'-------------------------------------------------------------------------------------------------
' Valida que un objeto TextBox no se encuentre vacio, y presenta un error si lo esta
' vlstrTipo Tipo de dato a validar T-Texto,N-Númerico,F-Fecha,A-Alfabético
' vlstrForma La forma > pasar a Mayúsculas, < pasar a Minúsculas, P la primera letra en mayusculas
' vlintTamano Tamano máximo que puede alcanzar el texto
' vlblnPermiteEsp Si nos permite espacios dentro del texto
'-------------------------------------------------------------------------------------------------
    On Error GoTo NotificaError

    Dim vlstrMensaje As String
    ObjTxt.Text = fstrFormatTxt(ObjTxt.Text, vlstrTipo, vlstrForma, vlintTamano, vlblnPermiteEsp)
    If Len(ObjTxt.Text) = 0 Then
        fblnValidaTextBox = True
        vlstrMensaje = SIHOMsg(2) & Chr(13) & "Dato:" & ObjTxt.ToolTipText
        Call MsgBox(vlstrMensaje, vbExclamation, "Mensaje")
    Else
        fblnValidaTextBox = False
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnValidaTextBox"))
End Function

Public Sub pValidaVarCbo(vlstrVariable As String, ObjCbo As ComboBox, vlstrTipo, vlstrFormaOrd As String, vlintTamano As Integer, vlblnPermiteEsp As Boolean)
'-------------------------------------------------------------------------------------------------
' Valida que una variable relacionada a un Combo Box este con datos
'-------------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlstrMensaje As String
    vlstrVariable = fstrFormatTxt(vlstrVariable, vlstrTipo, vlstrFormaOrd, vlintTamano, vlblnPermiteEsp)
    If Len(vlstrVariable) = 0 Then
        vgblnErrorIngreso = True
        vlstrMensaje = SIHOMsg(2) & Chr(13) & "Dato:" & ObjCbo.ToolTipText
        Call MsgBox(vlstrMensaje, vbExclamation, "Mensaje")
    Else
        vgblnErrorIngreso = False
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pValidaVarCbo" & " " & ObjCbo.Name))
End Sub

Public Sub pValidaComboBox(ObjCbo As ComboBox)
'-------------------------------------------------------------------------------------------------
' Valida que se haya seleccionado un item del combobox
'-------------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlstrMensaje As String

    If ObjCbo.ListIndex = -1 Then
        vgblnErrorIngreso = True
        vlstrMensaje = SIHOMsg(2) & Chr(13) & "Dato:" & ObjCbo.ToolTipText
        Call MsgBox(vlstrMensaje, vbExclamation, "Mensaje")
    Else
        vgblnErrorIngreso = False
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pValidaComboBox" & " " & ObjCbo.Name))
End Sub

Public Sub pEnfocaMkTextL(ObjMkTexto As MaskEdBox)
'-------------------------------------------------------------------------------------------
' Selecciona el texto del un campo MaskEdBox y lo enfoca siempre y cuando el campo este vacio
'-------------------------------------------------------------------------------------------
On Error GoTo NotificaError

If Not ObjMkTexto Is Nothing Then
    If Len(ObjMkTexto.Text) = 0 Then
        With ObjMkTexto
            .SelStart = 0
            .SelLength = Len(ObjMkTexto.Text)
            .SetFocus
        End With
    End If
End If

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEnfocaMkTextL"))
End Sub

Public Sub pEnfocaCboL(ObjCbo As ComboBox, vlintstrCriterio As String)
'-------------------------------------------------------------------------------------------
'Enfoca el combo box siempre y cuando no se haya seleccionado datos del mismo en una variable
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    If Len(vlintstrCriterio) = 0 Then
        ObjCbo.SetFocus
        If ObjCbo.ListCount > 1 Then
            ObjCbo.ListIndex = 1
        Else
            ObjCbo.ListIndex = 0
        End If
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEnfocaCboL" & " " & ObjCbo.Name))
End Sub

Public Sub pSelMkTexto(ObjTxt As MaskEdBox)
'-------------------------------------------------------------------------------------------
' Selecciona el texto dentro de un MaskEdText
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    With ObjTxt
      If .Enabled And .Visible Then
        .SelStart = 0
        .SelLength = Len(ObjTxt.Text)
      End If
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pSelMkTexto"))
End Sub

Public Sub pSelTextBox(ObjTxt As TextBox)
'-------------------------------------------------------------------------------------------
' Selecciona el texto dentro de un TextBox
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    With ObjTxt
      If .Enabled And .Visible Then
        .SelStart = 0
        .SelLength = Len(ObjTxt.Text)
      End If
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pSelTextBox"))
End Sub

Public Sub pGeneraCBBNOM(lngComprobante As Long, strTipo As String, strRutaCBB As String)
    '-------------------------------------------------------------------------------------------
    ' Genera el código de barras bidimensional para un CFDi
    '-------------------------------------------------------------------------------------------
    Dim strQRre As String
    Dim strQRrr As String
    Dim strQRtt As String
    Dim strQRid As String
    Dim strQRCode As String
    Dim intCont As Integer
    Dim strSentencia As String
    Dim rsQRCode As New ADODB.Recordset
    Dim strRuta As String
            
    
    On Error Resume Next
    If Dir$(strRutaCBB) <> "" Then
        Kill strRutaCBB
        If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
            Err.Clear
        Else
            Err.Raise Err.Number
        End If
    End If
    
    '|  Verifica la tabla GNCOMPROBANTEFISCALDIGITAL para mandar los parámetros del QR Code
    strSentencia = "SELECT VCHRFCEMISOR " & _
                   "     , VCHRFCRECEPTOR " & _
                   "     , NUMTOTALCOMPROBANTE " & _
                   "     , NUMTOTALCOMPROBANTE " & _
                   "     , VCHUUID " & _
                   "  FROM GNCFDIGITALNOMINA " & _
                   " WHERE GNCFDIGITALNOMINA.INTIDCOMPROBANTE = " & lngComprobante '& _
                  ' "   AND GNCFDIGITALNOMINA.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
    Set rsQRCode = frsRegresaRs(strSentencia)
    
    'Se asignan los valores para el QR Code
    strQRre = "?re=" + Trim(rsQRCode!VCHRFCEMISOR)
    strQRrr = "&rr=" + Trim(rsQRCode!VCHRFCRECEPTOR)
    'Formatea el total a ######.######
        strQRtt = Trim(rsQRCode!numTotalComprobante)
        strQRtt = CStr(FormatNumber(CDec(strQRtt), 6, vbTrue, vbUseDefault, vbFalse)) '(Agrega los ceros después del punto)
        For intCont = 0 To (10 - CInt(InStr(strQRtt, "."))) 'Agrega los ceros antes del punto
            strQRtt = "0" & strQRtt
        Next intCont
    strQRtt = "&tt=" + strQRtt
    strQRid = "&id=" + Trim(rsQRCode!VCHUUID)
    strQRCode = strQRre & strQRrr & strQRtt & strQRid
    
    'Funcion de la libreria QRCodeLib.dll que genera el QR Code
    FastQRCode strQRCode, strRutaCBB
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pGeneraCBBNOM"))
End Sub

Public Sub pGeneraCBB(lngComprobante As Long, strTipo As String, strRutaCBB As String)
    '-------------------------------------------------------------------------------------------
    ' Genera el código de barras bidimensional para un CFDi
    '-------------------------------------------------------------------------------------------
    Dim strQRre As String
    Dim strQRrr As String
    Dim strQRtt As String
    Dim strQRid As String
    Dim strQRCode As String
    Dim intCont As Integer
    Dim strSentencia As String
    Dim rsQRCode As New ADODB.Recordset
    Dim strRuta As String
    Dim vlStrSello As String
    Dim vllnglocalizacion As Long
    
    On Error Resume Next
    If Dir$(strRutaCBB) <> "" Then
        Kill strRutaCBB
        If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
            Err.Clear
        Else
            Err.Raise Err.Number
        End If
    End If
    
    '|  Verifica la tabla GNCOMPROBANTEFISCALDIGITAL para mandar los parámetros del QR Code
    strSentencia = "SELECT VCHRFCEMISOR " & _
                   "     , VCHRFCRECEPTOR " & _
                   "     , NUMTOTALCOMPROBANTE " & _
                   "     , VCHSELLO " & _
                   "     , VCHUUID " & _
                   "     , CLBCFDITIMBRADO " & _
                   "     , CLBCOMPROBANTEFISCAL " & _
                   "     , CHRTIPOCOMPROBANTE " & _
                   "     , VCHCERTIFICADOSAT " & _
                   "     , VCHCADENATFD " & _
                   "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                   " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                   "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
    Set rsQRCode = frsRegresaRs(strSentencia)
    If vgstrVersionCFDI = "3.2" Then
        'Se asignan los valores para el QR Code
        strQRre = "?re=" + Trim(rsQRCode!VCHRFCEMISOR)
        strQRrr = "&rr=" + Trim(rsQRCode!VCHRFCRECEPTOR)
        'Formatea el total a ######.######
            strQRtt = Trim(IIf(IsNull(rsQRCode!numTotalComprobante), "0", rsQRCode!numTotalComprobante))
            strQRtt = CStr(FormatNumber(CDec(strQRtt), 6, vbTrue, vbUseDefault, vbFalse)) '(Agrega los ceros después del punto)
            For intCont = 0 To (10 - CInt(InStr(strQRtt, "."))) 'Agrega los ceros antes del punto
                strQRtt = "0" & strQRtt
            Next intCont
        strQRtt = "&tt=" + strQRtt
        strQRid = "&id=" + Trim(rsQRCode!VCHUUID)
        strQRCode = strQRre & strQRrr & strQRtt & strQRid
    Else
    
        vlStrSello = ""
        vllnglocalizacion = 0
        With rsQRCode
'            If !CHRTIPOCOMPROBANTE = "FA" Or !CHRTIPOCOMPROBANTE = "DO" Or !CHRTIPOCOMPROBANTE = "CR" Or !CHRTIPOCOMPROBANTE = "AA" Or !CHRTIPOCOMPROBANTE = "AN" Then
            If IIf(IsNull(!VCHCADENATFD), "", !VCHCADENATFD) <> "" Then
                If InStr(1, !VCHCADENATFD, !VCHCERTIFICADOSAT) <> 0 Then
                    vllnglocalizacion = InStr(1, !VCHCADENATFD, !VCHCERTIFICADOSAT)
                    vlStrSello = Mid(!VCHCADENATFD, vllnglocalizacion - 9, 8)
                End If
            End If
            If vlStrSello = "" Then
                If IIf(IsNull(!CLBCOMPROBANTEFISCAL), "", !CLBCOMPROBANTEFISCAL) <> "" Then
                    If InStr(1, !CLBCOMPROBANTEFISCAL, "Sello=" & Chr(34) & Chr(34)) = 0 Then
                        vllnglocalizacion = InStr(1, !CLBCOMPROBANTEFISCAL, " FormaPago=")
                        vlStrSello = Mid(!CLBCOMPROBANTEFISCAL, vllnglocalizacion - 9, 8)
                    End If
                End If
            End If
            If vlStrSello = "" Then
                vlStrSello = Mid(!VCHSELLO, Len(!VCHSELLO) - 7, Len(!VCHSELLO))
            End If
'            Else
'                If !CHRTIPOCOMPROBANTE = "CA" Then
'                    If IIf(IsNull(!CLBCFDITIMBRADO), "", !CLBCFDITIMBRADO) <> "" Then
'                        If InStr(1, !CLBCFDITIMBRADO, "Sello=" & Chr(34) & Chr(34)) = 0 Then
'                            vllnglocalizacion = InStr(1, !CLBCFDITIMBRADO, " formaDePago=")
'                            vlStrSello = Mid(!CLBCFDITIMBRADO, vllnglocalizacion - 9, 8)
'                        End If
'                    End If
'                    If vlStrSello = "" Then
'                        If IIf(IsNull(!CLBCOMPROBANTEFISCAL), "", !CLBCOMPROBANTEFISCAL) <> "" Then
'                            If InStr(1, !CLBCOMPROBANTEFISCAL, "Sello=" & Chr(34) & Chr(34)) = 0 Then
'                                vllnglocalizacion = InStr(1, !CLBCOMPROBANTEFISCAL, " formaDePago=")
'                                vlStrSello = Mid(!CLBCOMPROBANTEFISCAL, vllnglocalizacion - 9, 8)
'                            End If
'                        End If
'                    End If
'                    If vlStrSello = "" Then
'                        vlStrSello = Mid(!VCHSELLO, Len(!VCHSELLO) - 7, Len(!VCHSELLO))
'                    End If
'                Else
'                    If !CHRTIPOCOMPROBANTE = "RE" Then
'                        If IIf(IsNull(!CLBCFDITIMBRADO), "", !CLBCFDITIMBRADO) <> "" Then
'                            If InStr(1, !CLBCFDITIMBRADO, "Sello=" & Chr(34) & Chr(34)) = 0 Then
'                                vllnglocalizacion = InStr(1, !CLBCFDITIMBRADO, " NoCertificado=")
'                                vlStrSello = Mid(!CLBCFDITIMBRADO, vllnglocalizacion - 9, 8)
'                            End If
'                        End If
'                        If vlStrSello = "" Then
'                            If IIf(IsNull(!CLBCOMPROBANTEFISCAL), "", !CLBCOMPROBANTEFISCAL) <> "" Then
'                                If InStr(1, !CLBCOMPROBANTEFISCAL, "Sello=" & Chr(34) & Chr(34)) = 0 Then
'                                    vllnglocalizacion = InStr(1, !CLBCOMPROBANTEFISCAL, " NoCertificado=")
'                                    vlStrSello = Mid(!CLBCOMPROBANTEFISCAL, vllnglocalizacion - 9, 8)
'                                End If
'                            End If
'                        End If
'                        If vlStrSello = "" Then
'                            vlStrSello = Mid(!VCHSELLO, Len(!VCHSELLO) - 7, Len(!VCHSELLO))
'                        End If
'                    End If
'                End If
'            End If
        End With
    
        strQRCode = "https://verificacfdi.facturaelectronica.sat.gob.mx/default.aspx?" & _
        "id=" & Trim(rsQRCode!VCHUUID) & "&re=" & Trim(rsQRCode!VCHRFCEMISOR) & "&rr=" & Trim(rsQRCode!VCHRFCRECEPTOR) & _
        "&tt=" & IIf(IsNull(rsQRCode!numTotalComprobante), "0", rsQRCode!numTotalComprobante) & "&fe=" & vlStrSello
    End If
    
    'Funcion de la libreria QRCodeLib.dll que genera el QR Code
    FastQRCode strQRCode, strRutaCBB
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pGeneraCBB"))
End Sub

Public Sub pEliminaCBB(lngComprobante As Long, strTipo As String, strRutaCBB As String)
    '-------------------------------------------------------------------------------------------
    ' Elimina el código de barras bidimensional para un CFDi
    '-------------------------------------------------------------------------------------------
            
    '|  Elimina el archivo CBB
    On Error Resume Next
    If Dir$(strRutaCBB) <> "" Then
        Kill strRutaCBB
        If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
            Err.Clear
        Else
            Err.Raise Err.Number
        End If
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEliminaCBB"))
End Sub



Public Sub pIniciaCbo(ObjCbo As ComboBox)
'-------------------------------------------------------------------------------------------
'Inicializa un combo box solo con el elemento <AGREGAR> en la posicion 0
'"A" solo <AGREGAR>, "E" solo <ELIMINAR>, "T" ambos <AGREGAR/ELIMINAR>
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    ObjCbo.Clear
    ObjCbo.AddItem "<AGREGAR>", 0

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pIniciaCbo" & " " & ObjCbo.Name))
End Sub

Public Sub pLlenarCboRs(ObjCbo As ComboBox, ObjRS As Recordset, vlintNumCampoItmData As Integer, vlintNumCampoList As String, Optional vlintNumCaso As Integer, Optional vlblnMuestraError As Boolean)
'-------------------------------------------------------------------------------------------
' Llena un combobox con datos de un recordset, pidiendo
' ObjCbo Combo Box en donde se llenaran los datos
' ObjRS Recorsed de donde se llenaran los datos
' vlintNumCampoItmData Numero de campo dek RS para guardarlo en la posicion ItemData del ComboBox
' vlintNumCampoList Numero del campo del RS para guardarlos en la posicion List del ComboBox
' vlintNumCaso para llenar con Agregar o Mantenimiento segun el caso
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumCampoOrd As Long
    Dim vlintNumReg As Long
    Dim vlintseq As Long
    Dim vlstrNombreCampo As String
    Dim vlstrNomCampos As String
    Dim vlNum As Long
    Dim vlintIniciaSeq As Long
    Dim vlstrCampo As String
    Dim vlintSeqCampos As Long
    Dim vlintNum As Long
    
    vlintNumReg = ObjRS.RecordCount
    vlNum = 0
    ObjCbo.Clear
    Select Case vlintNumCaso
        Case Is = 1
                ObjCbo.AddItem "<AGREGAR>", 0
        Case Is = 2
            If vlintNumCaso > 0 Then
                Select Case vlintNumReg
                    Case 0
                        ObjCbo.AddItem "<AGREGAR>", 0
                    Case Is > 0
                        ObjCbo.AddItem "<MANTENIMIENTO>", 0
                End Select
            End If
        Case Is = 3
                ObjCbo.AddItem "<TODOS>", 0
        Case Is = 4
                ObjCbo.AddItem "<NINGUNO(A)>", 0
        Case Is = 5
                ObjCbo.AddItem "<MANTENIMIENTO>", 0
    End Select
    
    vlintNumCampoOrd = CInt(fstrFormatTxt(vlintNumCampoList, "N", "", 20, False))
    If (vlintNumReg > 0) Then
        ObjRS.MoveFirst
        vlstrNombreCampo = ObjRS.Fields(vlintNumCampoOrd).Name
        vlstrCampo = vlstrNombreCampo & " Asc"
        ObjRS.Sort = vlstrCampo
        vlintIniciaSeq = ObjCbo.ListCount
        For vlintseq = 1 To vlintNumReg
            Select Case vlintNumCampoList
                Case Is = "*" 'En la lista suma todos los campos
                    vlstrNombreCampo = ObjRS.Fields(0).Name
                    vlstrCampo = vlstrNombreCampo & " Asc"
                    vlstrNomCampos = ""
                    For vlintSeqCampos = 0 To ObjRS.Fields.Count - 1
                        If vlintSeqCampos = ObjRS.Fields.Count - 1 Then
                            If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                vlstrNomCampos = vlstrNomCampos & ""
                            Else
                                vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos)
                            End If
                        Else
                            If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                vlstrNomCampos = vlstrNomCampos & " - "
                            Else
                                vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos) & " - "
                            End If
                        End If
                    Next vlintSeqCampos
                    ObjCbo.AddItem UCase(vlstrNomCampos), vlintIniciaSeq
                Case Is = "@" 'En la lista suma todos los campos menos el campo clave
                    vlstrNombreCampo = ObjRS.Fields(0).Name
                    vlstrCampo = vlstrNombreCampo & " Asc"
                    vlstrNomCampos = ""
                    vlintNum = vlintNumCampoItmData
                    For vlintSeqCampos = 0 To ObjRS.Fields.Count - 1
                        If vlintSeqCampos <> vlintNum Then
                            If vlintSeqCampos = ObjRS.Fields.Count - 1 Then
                                If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                    vlstrNomCampos = vlstrNomCampos & ""
                                Else
                                    vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos)
                                End If
                            Else
                                If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                    vlstrNomCampos = vlstrNomCampos & " - "
                                Else
                                    vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos) & " - "
                                End If
                            End If
                        End If
                    Next vlintSeqCampos
                    ObjCbo.AddItem UCase(vlstrNomCampos), vlintIniciaSeq
                Case Else 'En la lista va solo en campo que se envio
                    If IsNull(ObjRS.Fields(CInt(vlintNumCampoList))) Then
                        ObjCbo.AddItem "< >", vlintIniciaSeq
                    Else
                        ObjCbo.AddItem UCase(ObjRS.Fields(CInt(vlintNumCampoList))), vlintIniciaSeq
                    End If
            End Select
            
            If vlintNumCampoItmData >= 0 Then
                If IsNumeric(ObjRS.Fields(vlintNumCampoItmData).Value) = True Then
                    ObjCbo.ItemData(vlintIniciaSeq) = CDbl(ObjRS.Fields(vlintNumCampoItmData).Value)
                Else
                    ObjCbo.ItemData(vlintIniciaSeq) = 0
                End If
            Else
                ObjCbo.ItemData(vlintIniciaSeq) = ObjRS.Bookmark
            End If
            vlintIniciaSeq = vlintIniciaSeq + 1
            ObjRS.MoveNext
        Next vlintseq
        ObjRS.MoveFirst
    Else
        If vlblnMuestraError = True Then
            Call MsgBox((SIHOMsg(13) & Chr(13) & ObjCbo.ToolTipText), vbExclamation, "Mensaje") 'Toma un mensaje del módulo de mensajes y lo despliega
        End If
    End If

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLlenarCboRs" & " " & ObjCbo.Name))
End Sub

Public Function fintLocRegRsCriterio(ObjRS As Recordset, vlstrCriterio As String) As Integer
'-------------------------------------------------------------------------------------------
' Localiza un Registro de un RS con un criterio que se envie
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlblnResul As Boolean
    
    If ObjRS.RecordCount > 0 Then
        ObjRS.MoveFirst
        ObjRS.Find vlstrCriterio
        If ObjRS.EOF Or ObjRS.BOF Then
            fintLocRegRsCriterio = 0
        Else
            fintLocRegRsCriterio = ObjRS.Bookmark
        End If
    Else
        fintLocRegRsCriterio = 0
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintLocRegRsCriterio"))
End Function

Public Function fintFiltraCriterioRs(ObjRS As Recordset, vlstrCriterio As String) As Integer
'-------------------------------------------------------------------------------------------
' Realiza la busqueda de un criterio, filtrando informacion en Rs
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlblnResul As Boolean
    
    If ObjRS.RecordCount > 0 Then
        ObjRS.Filter = vlstrCriterio
        fintFiltraCriterioRs = ObjRS.RecordCount
    Else
        fintFiltraCriterioRs = 0
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintFiltraCriterioRs"))
End Function

Public Function fstrObtenerValCampoRs(vlstrNombreTabla As String, vlintNumCampoRegresar As Integer, Optional vlstrCondicion As String = "", Optional vllngParametro As Long = 1) As String
'-------------------------------------------------------------------------------------------
' Procedimiento para obtener la informacion contenida en un campo x de una tabla relacionada
'   a un objeto recordset x
'-------------------------------------------------------------------------------------------

    On Error GoTo NotificaError

    Dim vlstrsql As String
    Dim Recordset As ADODB.Recordset
    
        
    If Format(vlstrNombreTabla, ">") = "CIUDAD" Then
        vlstrCondicion = "intCveCiudad = " & vllngParametro & ""
    End If
    If Format(vlstrNombreTabla, ">") = "ESTADO" Then
        vlstrCondicion = "intCveEstado = " & vllngParametro & ""
    End If
    If Format(vlstrNombreTabla, ">") = "PAIS" Then
        vlstrCondicion = "intCvePais = " & vllngParametro & ""
    End If
    
    If Trim(vlstrCondicion) = "" Then
        vlstrsql = "SELECT * FROM " & vlstrNombreTabla & " "
    Else
        vlstrsql = "SELECT * FROM " & vlstrNombreTabla & " WHERE " & vlstrCondicion & ""
    End If
    Set Recordset = frsRegresaRs(vlstrsql, adLockBatchOptimistic, adOpenDynamic)
    
    If Recordset.RecordCount > 0 Then
        fstrObtenerValCampoRs = Recordset.Fields(vlintNumCampoRegresar).Value
    End If
    
    'Cerrar y liberar recordset
    Recordset.Close
    Set Recordset = Nothing
    
    Exit Function
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrObtenerValCampoRs"))
End Function

Public Sub pCargarVarPrmGnrl()
'-------------------------------------------------------------------------------------------
' Procedimiento para cargar en memoria las variables de la tabla de parametros generales
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim rsParametros As New ADODB.Recordset
    Dim rs As ADODB.Recordset
    
    Set rsParametros = frsSelParametros("SI", -1)
    
    First_time = False
    If rsParametros.RecordCount = 0 Then
        Call pCrearPrmGnrDefault
        First_time = True
    End If
    
    'Parámetros generales
    If rsParametros.RecordCount <> 0 Then
        While Not rsParametros.EOF
            Select Case rsParametros("Nombre")
                Case "INTCVENACIONALIDADPREDETERMINA"
                    vglngCveNacionalidad = IIf(IsNull(rsParametros("Valor")), 0, rsParametros("Valor"))
                Case "BITNOMINA"
                    vgblnNomina = rsParametros("Valor")
                Case "BITINTERFAZSURFING"
                    vgblnInterfazSurfing = rsParametros("Valor")
                Case "CHRRFCFISICAINICIAL"
                    gstrRFCFisicaInicial = Trim(IIf(IsNull(rsParametros("Valor")), "", rsParametros("Valor")))
                Case "CHRRFCFISICAFECHA"
                    gstrRFCFisicaFecha = Trim(IIf(IsNull(rsParametros("Valor")), "", rsParametros("Valor")))
                Case "CHRRFCFISICAHOMOCLAVE"
                    gstrRFCFisicaHomoclave = Trim(IIf(IsNull(rsParametros("Valor")), "", rsParametros("Valor")))
                Case "CHRRFCMORALINICIAL"
                    gstrRFCMoralInicial = Trim(IIf(IsNull(rsParametros("Valor")), "", rsParametros("Valor")))
                Case "CHRRFCMORALFECHA"
                    gstrRFCMoralFecha = Trim(IIf(IsNull(rsParametros("Valor")), "", rsParametros("Valor")))
                Case "CHRRFCMORALHOMOCLAVE"
                    gstrRFCMoralHomoclave = Trim(IIf(IsNull(rsParametros("Valor")), "", rsParametros("Valor")))
                Case "MNYPORCENTAJERETIVA"
                    gdblPorcentajeRetIVA = IIf(IsNull(rsParametros("Valor")), 0, rsParametros("Valor"))
                Case "RELPORCENTAJERETENCIONFLETES"
                    gdblPorcentajeRetFletes = IIf(IsNull(rsParametros("Valor")), 0, rsParametros("Valor"))
                Case "TNYCVEDISPONIBLE"
                    vgbytDisponibleCH = IIf(IsNull(rsParametros("Valor")), 0, rsParametros("Valor"))
                Case "TNYCVEOCUPADO"
                    vgbytOcupadoCH = IIf(IsNull(rsParametros("Valor")), 0, rsParametros("Valor"))
                Case "BITNEWENCRYPT"
                    gbitNewEncrypt = IIf(IsNull(rsParametros("Valor")), 0, rsParametros("Valor"))
                Case "INTCVEIDIOMAPREDETERMINADO"
                    vglngCveIdioma = IIf(IsNull(rsParametros("Valor")), 0, rsParametros("Valor"))
            End Select
            rsParametros.MoveNext
        Wend
    End If
    rsParametros.Close
    
    'CNEmpresaContable
    Set rs = frsRegresaRs("select * from CNEmpresaContable where tnyClaveEmpresa = " & vgintClaveEmpresaContable)
    With rs
        If Not rs.EOF Then
            'Tabla CNEmpresaContable
            vgstrNombreHospitalCH = Trim(IIf(IsNull(!vchNombre), "", !vchNombre))
            vgstrNombCortoCH = Trim(IIf(IsNull(!vchNombreCorto), "", !vchNombreCorto))
            vgstrRfCCH = Trim(IIf(IsNull(!vchRFC), "", !vchRFC))
            vgstrIMSSCH = Trim(IIf(IsNull(!vchRegistroIMSS), "", !vchRegistroIMSS))
            vgstrSSACH = Trim(IIf(IsNull(!vchLicenciaSSA), "", !vchLicenciaSSA))
            vgstrRepLegalCH = Trim(IIf(IsNull(!vchRepresentanteLegal), "", !vchRepresentanteLegal))
            vgstrDirGnralCH = Trim(IIf(IsNull(!vchDirectorGeneral), "", !vchDirectorGeneral))
            vgstrDirMedCH = Trim(IIf(IsNull(!vchDirectorMedico), "", !vchDirectorMedico))
            vgstrAdmGnralCH = Trim(IIf(IsNull(!vchAdministradorGeneral), "", !vchAdministradorGeneral))
            vgimgLogoCH = IIf(IsNull(!vchLogo), "", !vchLogo)
            vgstrDireccionCH = IIf(IsNull(!vchCalle), "", Trim(!vchCalle)) & IIf(IsNull(!VCHNUMEROEXTERIOR), "", " No. " & Trim(!VCHNUMEROEXTERIOR)) & IIf(IsNull(!VCHNUMEROINTERIOR), "", " Int. " & Trim(!VCHNUMEROINTERIOR))
            vgstrColoniaCH = Trim(IIf(IsNull(!VCHCOLONIA), "", !VCHCOLONIA))
            vgintCveCiudadCH = CInt(IIf(IsNull(!intCveCiudad), 0, !intCveCiudad))
            vgstrCiudadCH = fstrObtenerValCampoRs("Ciudad", 1, , CLng(vgintCveCiudadCH))
            pObtenerEstadoPais vgintCveCiudadCH, vgintCveEstadoCH, vgstrEstadoCH, vgintCvePaisCH, vgstrPaisCH
            vgstrTelefonoCH = Trim(IIf(IsNull(!vchTelefono), "", !vchTelefono))
            vgstrFaxCH = Trim(IIf(IsNull(!vchFax), "", !vchFax))
            vgstrEmailCH = Trim(IIf(IsNull(!vchEmail), "", !vchEmail))
            vgstrWebCH = Trim(IIf(IsNull(!vchWeb), "", !vchWeb))
            vgstrCodPostalCH = Trim(IIf(IsNull(!VCHCODIGOPOSTAL), "", !VCHCODIGOPOSTAL))
            vgstrApartPostalCH = Trim(IIf(IsNull(!vchApartadoPostal), "", !vchApartadoPostal))
            vgIntDigitoVerificador = IIf(IsNull(!intDigitoVerificador), 0, !intDigitoVerificador)
            vgintClaveEmpresaContable = IIf(IsNull(!tnyclaveempresa), 0, !tnyclaveempresa)
            vgstrVersionCFDI = IIf(IsNull(!vchVersionCFDI), "3.2", !vchVersionCFDI)
            vgblnNuevoEsquemaCancelacion = IIf(IsNull(!BITNUEVOESQUEMACANCELACION), False, IIf(!BITNUEVOESQUEMACANCELACION = 0, False, True))
        End If
        .Close
    End With
      
    'Parametros empresa
    Set rs = frsSelParametros("SI", vgintClaveEmpresaContable)
    If rs.RecordCount <> 0 Then
        While Not rs.EOF
            'Tabla ParametrosEmpresa
            Select Case rs("Nombre")
                Case "INTCVETIPOCUARTOPRED"
                    vgintTipoCuartoCH = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCVEESTADOSALUDPRED"
                    vgintEstadoSaludCH = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCVEPROVEEDORALMACENGENERAL"
                    vglngCveAlmacenGeneral = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTDIASREQUISICION"
                    vgintDiasRequisicion = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
            End Select
            rs.MoveNext
        Wend
        rs.Close
    End If
    
    'CNParametro
    Set rs = frsSelParametros("CN", vgintClaveEmpresaContable)
    If rs.RecordCount <> 0 Then
        While Not rs.EOF
            'Tabla CNParametro
            Select Case rs("Nombre")
                Case "VCHESTRUCTURACUENTACONTABLE"
                    vgstrEstructuraCuentaContable = Trim(IIf(IsNull(rs("Valor")), "", rs("Valor")))
                Case "INTCTAIVACOBRADO"
                    glngCtaIVACobrado = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAIVANOCOBRADO"
                    glngCtaIVANoCobrado = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAIVAPAGADO"
                    glngCtaIVAPagado = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAIVANOPAGADO"
                    glngCtaIVANoPagado = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTTASAIMPUESTOHOSPITAL"
                    glngCveImpuesto = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTARETENCIONISR"
                    glngCtaRetencionISR = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTARETENCIONIVA"
                    glngCtaRetencionIVA = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTARETIVAARRENDAMIENTO"
                    glngCtaIVAArrendamiento = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTARETISRARRENDAMIENTO"
                    glngCtaISRArrendamiento = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTARETENCIONFLETES"
                    vglngnCtaRetencionFletes = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTADESCUENTOCOMPRA"
                    vglngCtaDescuentosCompra = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAPERDIDACAMBIARIA"
                    vglngCtaPerdidaCambiaria = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAUTILIDADCAMBIARIA"
                    vglngCtaUtilidadCambiaria = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAINTERESESVENCPAGOS"
                    vglngCtaInteresvencimientos = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTNUMCUENTATRASLADOCOBIEPS"
                    glngctaIEPSCobrado = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTNUMCUENTATRASLADONOCOBIEPS"
                    glngctaIEPSNoCobrado = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTNUMCUENTADEACREDITABLEPAGIEPS"
                    glngctaIEPSPagado = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTNUMCUENTADEACREDITABLENOPAGIEPS"
                    glngctaIEPSNoPagado = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAPROVISIONSERVICIOSCLIENTE"
                    glngctaProvServClientes = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTARETENCIONSERVICIOSCLIENTE"
                    glngctaRetenServClientes = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAISRRETENIDOHONORARIO"
                    glngctaISRretenHonorario = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAISRPROVISIONADOHONORARIO"
                    glngctaISRprovisHonorario = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAPROVISIONSERVICIOSPROVEEDOR"
                    glngctaProvisRetenServicios = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAPROVISIONRETENFLETES"
                    glngctaProvisRetenFlete = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTARETENCIONRTP"
                    glngCtaRetencionRTP = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAPROVISIONRTP"
                    glngCtaProvisionRTP = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAISRPROVISIONADORESICO"
                    glngCtaISRprovisionadoResico = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCTAISRRETENIDORESICO"
                    glngCtaISRretenidoResico = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
            End Select
            rs.MoveNext
        Wend
        vgdblCantidadIvaGeneral = Val(fstrObtenerValCampoRs("CNIMPUESTO", 2, "SMICVEIMPUESTO = " & glngCveImpuesto, 0))
        rs.Close
    End If
Exit Sub
NotificaError:
  Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pCargarVarPrmGnrl"))
End Sub

Private Sub pObtenerEstadoPais(lngCveCiudad As Integer, ByRef lngCveEstado As Integer, ByRef strEstado As String, ByRef lngCvePais As Integer, ByRef strPais As String)
    Dim rs As ADODB.Recordset
    Dim rs2 As ADODB.Recordset
    Dim rs3 As ADODB.Recordset
    Dim strSql As String
    strSql = "select * from Ciudad where intCveCiudad = " & lngCveCiudad
    Set rs = frsRegresaRs(strSql)
    If Not rs.EOF Then
        strSql = "select * from Estado where intCveEstado = " & rs!INTCVEESTADO
        Set rs2 = frsRegresaRs(strSql)
        If Not rs2.EOF Then
            strSql = "select * from Pais where intCvePais = " & rs2!intCvePais
            Set rs3 = frsRegresaRs(strSql)
            If Not rs3.EOF Then
                lngCvePais = rs3!intCvePais
                strPais = rs3!VCHDESCRIPCION
            End If
            rs3.Close
            lngCveEstado = rs2!INTCVEESTADO
            strEstado = rs2!VCHDESCRIPCION
        End If
        rs2.Close
    End If
    rs.Close
End Sub

Public Sub pValidaMkText(ObjTxt As MaskEdBox, vlstrTipo, vlstrForma As String, vlintTamano As Integer, vlblnPermiteEsp As Boolean)
'----------------------------------------------------------------------------------------
'Procedimiento para Validar un objeto MaskEdBox si esta vacio segun criterios enviados
'----------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlstrMensaje As String
    ObjTxt.Text = fstrFormatTxt(ObjTxt.Text, vlstrTipo, vlstrForma, vlintTamano, vlblnPermiteEsp)
    If Len(ObjTxt.Text) = 0 Then
        vgblnErrorIngreso = True
        vlstrMensaje = SIHOMsg(2) & Chr(13) & "Dato:" & ObjTxt.ToolTipText
        Call MsgBox(vlstrMensaje, vbExclamation, "Mensaje")
    Else
        vgblnErrorIngreso = False
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pValidaMkText"))
End Sub

Public Function fblnValidaMkText(ObjTxt As MaskEdBox, vlstrTipo, vlstrForma As String, vlintTamano As Integer, vlblnPermiteEsp As Boolean) As Boolean
'----------------------------------------------------------------------------------------
'Procedimiento para Validar un objeto MaskEdBox si esta vacio segun criterios enviados
'----------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlstrMensaje As String
    ObjTxt.Text = fstrFormatTxt(ObjTxt.Text, vlstrTipo, vlstrForma, vlintTamano, vlblnPermiteEsp)
    If Len(ObjTxt.Text) = 0 Then
        fblnValidaMkText = True
        vlstrMensaje = SIHOMsg(2) & Chr(13) & "Dato:" & ObjTxt.ToolTipText
        Call MsgBox(vlstrMensaje, vbExclamation, "Mensaje")
    Else
        fblnValidaMkText = False
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnValidaMkText"))
End Function

Public Function fintLocRegMshFGrd(ObjGrid As MSHFlexGrid, vlstrCriterio As String, vlintColBus As Integer) As Integer
'-------------------------------------------------------------------------------------------
' Realiza la busqueda de un criterio dentro de una de las columnas del grdHBusqueda
' señalando los criterios encontrados
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlintNumFilas As Integer 'Almacena el número de filas que contiene el grdHBusqueda
    Dim vlintseq As Integer 'Contador del número de filas del grdHBusqueda
    Dim vlintEFila As Integer 'Fila que se encuentra mediante el criterio de búsqueda
    Dim vlintLargo As Integer 'Almacena el largo del criterio de búsqueda
    Dim vlstrTexto As String 'Almacena los caracteres obtenidos de las celda del grid, segun el largo de busqueda del criterio, para su comparacion con el criterio de búsqueda
    
    vlintLargo = Len(vlstrCriterio)
    vlintEFila = 0 'Inicializa la búsqueda desde la primera fila
    vlintNumFilas = ObjGrid.Rows - 1
    
    If vlintLargo > 0 And vlintNumFilas > 0 Then
        For vlintseq = 1 To vlintNumFilas 'Realiza la búsqueda en todo el grid
            vlstrTexto = ObjGrid.TextMatrix(vlintseq, vlintColBus)
            If UCase(vlstrCriterio) = UCase(vlstrTexto) Then
                If vlintLargo > 0 Then
                    Call pSelFilaMshFGrid(ObjGrid, vlintseq)
                    vlintEFila = vlintseq
                End If
            Else
                If vlintLargo > 0 Then
                    Call pDesSelFilaMshFGrid(ObjGrid, vlintseq)
                End If
            End If
        Next vlintseq
        fintLocRegMshFGrd = vlintEFila
    Else
        fintLocRegMshFGrd = 0
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintLocRegMshFGrd" & " " & ObjGrid.Name))
End Function

Public Function fintCuentaRegMshFGrd(ObjGrid As MSHFlexGrid, vlstrCriterio As String, vlintColBus As Integer, Optional vlblnCritExacto) As Integer
'-------------------------------------------------------------------------------------------
' Realiza la busqueda de un criterio dentro de una de las columnas del grdHBusqueda
' contando cuantos encontro
' vlblnCritExacto para verificar si el criterio buscado coincida en todos sus caracteres, o los
' que se le parezcan
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlintNumFilas As Integer 'Almacena el número de filas que contiene el grdHBusqueda
    Dim vlintseq As Integer 'Contador del número de filas del grdHBusqueda
    Dim vlintEFila As Integer 'Fila que se encuentra mediante el criterio de búsqueda
    Dim vlintLargo As Integer 'Almacena el largo del criterio de búsqueda
    Dim vlstrTexto As String 'Almacena los caracteres obtenidos de las celda del grid, segun el largo de busqueda del criterio, para su comparacion con el criterio de búsqueda
    
    vlintLargo = Len(vlstrCriterio)
    vlintEFila = 0 'Inicializa la búsqueda desde la primera fila
    vlintNumFilas = ObjGrid.Rows - 1
    If IsMissing(vlblnCritExacto) = True Then
        vlblnCritExacto = False
    End If
    If vlblnCritExacto = True Then
        If vlintLargo > 0 Then
            For vlintseq = 1 To vlintNumFilas 'Realiza la búsqueda en todo el grid con criterio exactamente igual
                vlstrTexto = ObjGrid.TextMatrix(vlintseq, vlintColBus)
                If UCase(vlstrCriterio) = UCase(vlstrTexto) Then
                    vlintEFila = vlintEFila + 1
                End If
            Next vlintseq
            fintCuentaRegMshFGrd = vlintEFila
        End If
    Else
        If vlintLargo > 0 Then
            For vlintseq = 1 To vlintNumFilas 'Realiza la búsqueda en todo el grid con criterio que coincida con los primeros datos
                vlstrTexto = Left(ObjGrid.TextMatrix(vlintseq, vlintColBus), vlintLargo)
                If UCase(vlstrCriterio) = UCase(vlstrTexto) Then
                    vlintEFila = vlintEFila + 1
                End If
            Next vlintseq
            fintCuentaRegMshFGrd = vlintEFila
        End If
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintCuentaRegMshFGrd" & " " & ObjGrid.Name))
End Function

Public Sub pLlenarCboMshFGrd(ObjCbo As ComboBox, ObjGrid As MSHFlexGrid, vlintNumCampoCve As Integer, vlstrNCampo As String, Optional vlintNumCaso As Integer)
'-------------------------------------------------------------------------------------------
' Llena un combobox con datos de un recordset
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintDesdeCol As Long
    Dim vlintNumCampo As Long
    Dim vlintNumReg As Long
    Dim vlintseq As Long
    Dim vlstrNombreCampo As String
    Dim vlstrNomCampos As String
    Dim vlstrcaracter As String
    Dim vlNum As Long
    Dim vlintSeqCampos As Long
    Dim vlintNCampo As Long
    
    vlintNumReg = ObjGrid.Rows - 1
    vlNum = 0
    ObjCbo.Clear
    If vlintNumCaso > 0 Then
        Select Case vlintNumReg
            Case Is <= 0
                ObjCbo.AddItem "<AGREGAR>", 0
            Case Is > 0
                ObjCbo.AddItem "<MANTENIMIENTO>", 0
        End Select
    Else
        ObjCbo.AddItem "<AGREGAR>", 0
    End If

    If (vlintNumReg > 0) Then
        vlstrcaracter = Left(vlstrNCampo, 1)
        vlintDesdeCol = CInt(Right(vlstrNCampo, Len(vlstrNCampo) - 1))
        For vlintseq = 1 To vlintNumReg
            Select Case vlstrcaracter
                Case Is = "*" 'En la lista suma todos los campos
                    vlstrNomCampos = ""
                    For vlintSeqCampos = 0 To ObjGrid.Cols - 1
                        If vlintSeqCampos = ObjGrid.Cols - 1 Then
                            vlstrNomCampos = vlstrNomCampos & ObjGrid.TextMatrix(vlintseq, vlintSeqCampos)
                        Else
                            vlstrNomCampos = vlstrNomCampos & ObjGrid.TextMatrix(vlintseq, vlintSeqCampos) & " - "
                        End If
                    Next vlintSeqCampos
                    ObjCbo.AddItem UCase(vlstrNomCampos), vlintseq
                Case Is = "@"  'En la lista suma todos los campos menos el campo clave
                    vlstrNomCampos = ""
                    For vlintSeqCampos = vlintDesdeCol To ObjGrid.Cols - 1
                        If vlintSeqCampos = ObjGrid.Cols - 1 Then
                            vlstrNomCampos = vlstrNomCampos & ObjGrid.TextMatrix(vlintseq, vlintSeqCampos)
                        Else
                            vlstrNomCampos = vlstrNomCampos & ObjGrid.TextMatrix(vlintseq, vlintSeqCampos) & " - "
                        End If
                    Next vlintSeqCampos
                    ObjCbo.AddItem UCase(vlstrNomCampos), vlintseq
                Case Else 'En la lista va solo en campo que se envio
                    ObjCbo.AddItem UCase(ObjGrid.TextMatrix(vlintseq, CInt(vlintNCampo))), vlintseq
            End Select
        Next vlintseq
    End If

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLlenarCboMshFGrd" & " " & ObjCbo.Name & " " & ObjGrid.Name))
End Sub

Public Sub pLimpiaMshFGrid(ObjGrid As MSHFlexGrid)
'-------------------------------------------------------------------------------------------
' Limpia o Inicia completamente un Grid
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    With ObjGrid
        .Clear
        .ClearStructure
        .Rows = 0
        .Cols = 0
        .FixedCols = 0
        .FixedRows = 0
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLimpiaMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pIniciaMshFGrid(ObjGrid As MSHFlexGrid)
'-------------------------------------------------------------------------------------------
' Inicia un grid con cool y fils
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    With ObjGrid
        .Clear
        .ClearStructure
        .Rows = 2
        .Cols = 2
        .FixedCols = 1
        .FixedRows = 1
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pIniciaMshFGrid" & " " & ObjGrid.Name))
End Sub
      
Public Function fstrEncrypt(vlstrPwd As String, vlstrLogin As String) As String
'-------------------------------------------------------------------------------------------
' Procedimiento que encripta el password
'-------------------------------------------------------------------------------------------
' vlstrpwd = El string que se desea encriptar
' vlstrlogin= el login del password que se desea encriptar
'-------------------------------------------------------------------------------------------
Dim l As Long
Dim X As Long
Dim Char As String
Dim lstrPsswrd As String
   
On Error GoTo NotificaError
    
    l = Len(vlstrLogin)
    lstrPsswrd = ""
    For X = 1 To Len(vlstrPwd)
        Char = Asc(Mid(vlstrLogin, (X Mod l) - l * ((X Mod l) = 0), 1))
        lstrPsswrd = lstrPsswrd & CStr(Asc(Mid(vlstrPwd, X, 1)) Xor Char)
    Next
    fstrEncrypt = lstrPsswrd
    
Exit Function
NotificaError:
      Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrEncrypt"))
End Function

Public Function fstrEncrypt2(vlstrPwd As String, vlstrLogin As String) As String
'-------------------------------------------------------------------------------------------
' Procedimiento que encripta el password para la conexión
'-------------------------------------------------------------------------------------------
Dim l As Long
Dim X As Long
Dim Char As String
   
On Error GoTo NotificaError
    
    l = Len(vlstrLogin)
    For X = 1 To Len(vlstrPwd)
        Char = Asc(Mid(vlstrLogin, (X Mod l) - l * ((X Mod l) = 0), 1))
        Mid(vlstrPwd, X, 1) = Chr(Asc(Mid(vlstrPwd, X, 1)) Xor Char)
    Next
    fstrEncrypt2 = vlstrPwd
    
Exit Function
NotificaError:
      Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrEncrypt2"))
End Function

Public Function fstrObtenerValCampo(vlstrNombreRS As String, vlintNumCampo As Integer, Optional vlstrCriterio As String, Optional vlintNumCampoCriterio As Integer) As String
'-------------------------------------------------------------------------------------------
' Procedimiento para obtener la informacion contenida en un campo x de una tabla relacionada a un objeto comando x
'-------------------------------------------------------------------------------------------
    
    On Error GoTo NotificaError
    
    Dim vlintResul As Integer
    Select Case Len(vlstrCriterio)
        Case Is > 0
            EntornoSIHO.Recordsets(vlstrNombreRS).Open
            vlintResul = fintLocalizaPkRs(EntornoSIHO.Recordsets(vlstrNombreRS), vlintNumCampoCriterio, vlstrCriterio)
            If vlintResul = 0 Then
                fstrObtenerValCampo = ""
            Else
                fstrObtenerValCampo = EntornoSIHO.Recordsets(vlstrNombreRS).Fields(vlintNumCampo).Value
            End If
            EntornoSIHO.Recordsets(vlstrNombreRS).Close
        Case Is = 0
            EntornoSIHO.Recordsets(vlstrNombreRS).Open
            If EntornoSIHO.Recordsets(vlstrNombreRS).RecordCount > 0 Then
                If (EntornoSIHO.Recordsets(vlstrNombreRS).Fields(vlintNumCampo).Value) = Null Then
                    fstrObtenerValCampo = ""
                Else
                    fstrObtenerValCampo = EntornoSIHO.Recordsets(vlstrNombreRS).Fields(vlintNumCampo).Value
                End If
            Else
                fstrObtenerValCampo = ""
            End If
            EntornoSIHO.Recordsets(vlstrNombreRS).Close
    End Select
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrObtenerValCampo"))
End Function

Public Function fintBuscaCharStr(vlstrTexto As String, vlstrCriterio As String, Optional vlblnContar As Boolean) As Integer
'-------------------------------------------------------------------------------------------
' Funcion para regresar la posicion de la primera considencia del criterio dentro de un string,
' o cuenta el numero de coincidencias del criterio
'-------------------------------------------------------------------------------------------
    
    On Error GoTo NotificaError
    
    Dim vlintLargo, vlstrcaracter As String
    Dim vlintseq As Integer
    Dim vlintPos As Integer 'Primera posicion donde encuentra el caracter
    Dim vlintCuantos As Integer 'Para contar datos
    
    vlintPos = 0
    vlintCuantos = 0
    
    vlintLargo = Len(vlstrTexto)
    For vlintseq = 1 To vlintLargo
        vlstrcaracter = Mid(vlstrTexto, vlintseq, 1)
        If vlstrcaracter = vlstrCriterio Then
            vlintCuantos = vlintCuantos + 1
            If vlintPos = 0 Then
                vlintPos = vlintseq
            End If
        End If
    Next vlintseq
    
    If vlblnContar = True Then
        fintBuscaCharStr = vlintCuantos
    Else
        fintBuscaCharStr = vlintPos
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintBuscaCharStr"))
End Function

Public Sub pAgregaRegMshFGrid(ObjGrid As MSHFlexGrid, vlintNumCols As Integer, ParamArray alstrTextCol())
'-------------------------------------------------------------------------------------------
' Procedimiento para Agregar una fila en un grid
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumParam, vlintseq As Integer
    Dim vlstrAgrega As String
    
    vlintNumParam = UBound(alstrTextCol)
    If ObjGrid.Rows <= 0 Then
        With ObjGrid
            .Rows = 2
            .Cols = vlintNumCols
            .FixedCols = 1
            .FixedRows = 1
        End With
        For vlintseq = 1 To vlintNumCols - 1
                ObjGrid.TextMatrix(1, vlintseq) = alstrTextCol(vlintseq - 1)
        Next vlintseq
    Else
        For vlintseq = 1 To vlintNumCols - 1
            If vlintseq = 1 Then
                vlstrAgrega = vbTab
            End If
            vlstrAgrega = vlstrAgrega & alstrTextCol(vlintseq - 1)
            If vlintseq < vlintNumCols - 1 Then
                vlstrAgrega = vlstrAgrega & vbTab
            End If
        Next vlintseq
        ObjGrid.AddItem vlstrAgrega
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pAgregaRegMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pActualizaRegMshFGrid(ObjGrid As MSHFlexGrid, vlintNumFila As Integer, ParamArray alstrTextCol())
'-------------------------------------------------------------------------------------------
' Procedimiento para actualizar datos en la(s) columna(s) perteneciente a una fila en un grid
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumParam, vlintseq As Integer
    
    vlintNumParam = UBound(alstrTextCol)
    For vlintseq = 1 To vlintNumParam + 1
        ObjGrid.TextMatrix(vlintNumFila, vlintseq) = alstrTextCol(vlintseq - 1)
    Next vlintseq
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pActualizaRegMshFGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pBorrarRegMshFGrd(ObjGrid As MSHFlexGrid, vlintNumFila As Integer)
'----------------------------------------------------------------------------------------
' Procedimiento para Borrar un registro dentro de un grid
'----------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlintFils, vlIntCols As Integer
    Dim vlintFila, vlintCol, vlintFilaG As Integer
    Dim alstrGrid() As Variant
    
    
    If (ObjGrid.Rows - 1) > 0 And (ObjGrid.Cols - 1) > 0 Then
        vlIntCols = ObjGrid.Cols - 1
        vlintFils = ObjGrid.Rows - 1
        ReDim alstrGrid(vlintFils, vlIntCols)
        
        'Pasa informacion del Grid al array
        If (vlintFils - 1) <= 0 Then
            Call pIniciaMshFGrid(ObjGrid)
            Call pLimpiaMshFGrid(ObjGrid)
        Else
            vlintFila = 0
            vlintFilaG = 0
            Do
                vlintFilaG = vlintFilaG + 1
                If vlintFilaG <> vlintNumFila Then
                    vlintFila = vlintFila + 1
                    For vlintCol = 1 To vlIntCols
                        alstrGrid(vlintFila, vlintCol) = CStr(ObjGrid.TextMatrix(vlintFilaG, vlintCol))
                    Next vlintCol
                End If
            Loop Until (vlintFilaG = vlintFils)
        
            vlintFils = vlintFila
            ObjGrid.Cols = vlIntCols + 1
            ObjGrid.Rows = vlintFils + 1
            ObjGrid.FixedCols = 1
            ObjGrid.FixedRows = 1
            
            vlintFila = 0
            vlintFilaG = 0
            
            Do
                vlintFila = vlintFila + 1
                For vlintCol = 1 To vlIntCols
                    ObjGrid.TextMatrix(vlintFila, vlintCol) = alstrGrid(vlintFila, vlintCol)
                Next vlintCol
            Loop Until (vlintFila = vlintFils)
            
        End If
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pBorrarRegMshFGrd" & " " & ObjGrid.Name))
End Sub

Public Function fstrCalculoFecha(vldtmFechaActual As Date, vldtmFechaComp As Date, vlstrIntervalo As String, vlblnDatoCompleto As Boolean, vlblnMayMin As Boolean) As String
    Dim vldblDiaFA, vldblDiaFC As Double
    Dim vldblMesFA, vldblMesFC As Double
    Dim vldblAnoFA, vldblAnoFC As Double
    Dim vldblRDia, vldblRMes, vldblRAno, vldblRSem, vldblRTDias As Double
    
    If vldtmFechaActual > vldtmFechaComp Then
        vldblDiaFA = Day(vldtmFechaActual)
        vldblDiaFC = Day(vldtmFechaComp)
        vldblMesFA = Month(vldtmFechaActual)
        vldblMesFC = Month(vldtmFechaComp)
        vldblAnoFA = Year(vldtmFechaActual)
        vldblAnoFC = Year(vldtmFechaComp)
        
        If vldblDiaFC > vldblDiaFA Then
            'vldblRDia = (vldblDiaFA + 30) - vldblDiaFC
            vldblRDia = Format$(DateDiff("d", CDate(vldtmFechaComp), DateAdd("m", 1, CDate(vldtmFechaComp))))  'Calcula los días que tiene el mes de la fecha de nacimiento
            vldblRDia = (vldblDiaFA + vldblRDia) - vldblDiaFC
            vldblMesFA = vldblMesFA - 1
        Else
            vldblRDia = vldblDiaFA - vldblDiaFC
        End If
        
        If vldblMesFC > vldblMesFA Then
            vldblRMes = (vldblMesFA + 12) - vldblMesFC
            vldblAnoFA = vldblAnoFA - 1
        Else
            vldblRMes = vldblMesFA - vldblMesFC
        End If
        
        vldblRAno = vldblAnoFA - vldblAnoFC
        
        vldblRTDias = ((vldblRAno * 365) + (vldblRMes * 30) + vldblRDia)
        
        vldblRSem = vldblRTDias / 7
        
        Select Case UCase(vlstrIntervalo)
            Case "A"
                If vlblnDatoCompleto = False Then
                    fstrCalculoFecha = CStr(vldblRAno) & " A"
                Else
                    fstrCalculoFecha = CStr(vldblRAno) & " AÑO(S)"
                End If
            Case "AN"
                If vlblnDatoCompleto = False Then
                    fstrCalculoFecha = CStr(vldblRAno)
                Else
                    fstrCalculoFecha = CStr(vldblRAno)
                End If
            Case "AC"
                If vlblnDatoCompleto = False Then
                    fstrCalculoFecha = CStr(vldblRAno) & "/" & CStr(vldblRMes) & " A"
                Else
                    fstrCalculoFecha = CStr(vldblRAno) & "/" & CStr(vldblRMes) & " AÑO(S)"
                End If
         
            Case "M"
                If vlblnDatoCompleto = False Then
                    fstrCalculoFecha = CStr(vldblRMes) & " M"
                Else
                    fstrCalculoFecha = CStr(vldblRMes) & " MES(ES)"
                End If
            Case "S"
                vldblRDia = vldblRTDias Mod 7
                If vldblRDia > 0 Then
                    If vlblnDatoCompleto = False Then
                        fstrCalculoFecha = CStr(Int(vldblRSem)) & " S " & CStr(Int(vldblRDia)) & " D"
                    Else
                        fstrCalculoFecha = CStr(Int(vldblRSem)) & " SEMANA(S) " & CStr(Int(vldblRDia)) & " DIA(S)"
                    End If
                Else
                    If vlblnDatoCompleto = False Then
                        fstrCalculoFecha = CStr(Int(vldblRSem)) & " S"
                    Else
                        fstrCalculoFecha = CStr(Int(vldblRSem)) & " SEMANA(S)"
                    End If
                End If
            Case "D"
                If vlblnDatoCompleto = False Then
                    fstrCalculoFecha = CStr(vldblRTDias) & " D"
                Else
                    fstrCalculoFecha = CStr(vldblRTDias) & " DIA(S)"
                End If
        End Select
    Else
        fstrCalculoFecha = "0"
    End If
    If vlblnMayMin Then
        fstrCalculoFecha = UCase(fstrCalculoFecha)
    Else
        fstrCalculoFecha = LCase(fstrCalculoFecha)
    End If
End Function

Public Sub pLlenarMshFGrdRsC(ObjGrid As MSHFlexGrid, ObjRS As Recordset)
'----------------------------------------------------------------------------------------
'Procedimiento para llenar un grid con datos de un record set, con los campos deseados
'----------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlintNumCampos As Long
    Dim vlintNumReg As Long
    Dim vlintSeqFil As Long
    Dim vlintSeqColG As Long
    Dim vlintSeqColRs As Long
    
    vlintNumCampos = 2
    vlintNumReg = ObjRS.RecordCount
    If vlintNumCampos > 0 And vlintNumReg > 0 Then
        
        ObjGrid.ClearStructure
        ObjGrid.Cols = vlintNumCampos + 1
        ObjGrid.Rows = vlintNumReg + 1
        ObjGrid.FixedCols = 1
        ObjGrid.FixedRows = 1
        ObjRS.MoveFirst
        
        For vlintSeqFil = 1 To vlintNumReg
            vlintSeqColRs = 0
            vlintSeqColG = 1
            Do
                If IsNull(ObjRS.Fields(vlintSeqColRs).Value) = True Then
                    ObjGrid.TextMatrix(vlintSeqFil, vlintSeqColG) = ""
                Else
                    ObjGrid.TextMatrix(vlintSeqFil, vlintSeqColG) = ObjRS.Fields((vlintSeqColRs)).Value
                End If
                vlintSeqColRs = vlintSeqColRs + 1
                vlintSeqColG = vlintSeqColG + 1
            Loop Until (vlintSeqColRs = vlintNumCampos)
            
            ObjRS.MoveNext
        Next vlintSeqFil

    End If

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLlenarMshFGrdRsC" & " " & ObjGrid.Name))
End Sub

Public Function fstrNulos(vlstrObjCmd As String, vlintNumCampo As Integer) As String

'Verifica si un texto es nulo o no

    On Error GoTo NotificaError
    If IsNull(EntornoSIHO.Recordsets(vlstrObjCmd).Fields(vlintNumCampo).Value) = True Then
        fstrNulos = ""
    Else
        fstrNulos = CStr(EntornoSIHO.Recordsets(vlstrObjCmd).Fields(vlintNumCampo).Value)
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrNulos"))
End Function

Public Function fdblTipoNumPrecision(vlintTipo As Integer)
'Procedimiento para mostrar la presicion de los datos de tipo numerico
    Select Case vlintTipo
        Case 2
            fdblTipoNumPrecision = 32767 'smallint
        Case 17
            fdblTipoNumPrecision = 255 'byte
        Case 6
            fdblTipoNumPrecision = 214748 'small money
        Case 3
            fdblTipoNumPrecision = 2147483647 'entero
        Case 11
            fdblTipoNumPrecision = 1 'bit
        Case 131, 139, 5
            fdblTipoNumPrecision = 1E+24  'Numeric
         Case Else
            fdblTipoNumPrecision = 0 'no se sabe
    End Select
End Function

Public Function fstrVerificaFecha(vlstrFecha As String)
'Procedimiento para verificar la fecha
    On Error GoTo NotificaError
    
    Dim vldtmFecha As Date
    vlstrFecha = fstrFormatTxt(vlstrFecha, "F", "", 10, False)
    If Len(vlstrFecha) > 0 Then
        vldtmFecha = CDate(vlstrFecha)
        fstrVerificaFecha = Format(vldtmFecha, "dd/mm/yyyy")
    Else
        fstrVerificaFecha = ""
    End If
NotificaError:
    If Err.Number = 13 Then
        fstrVerificaFecha = ""
        On Error GoTo 0
    End If
    
End Function

Public Function fstrVerificaHora(vlstrHora As String)
'Procedimiento para verificar la hora
    On Error GoTo NotificaError
    Dim vldtmHora As Date
    
    If vlstrHora = "  :  :  " Then
      vldtmHora = fdtmServerHora
    Else
      If CDbl(Mid(vlstrHora, 1, InStr(1, vlstrHora, ":") - 1)) > 23 Then
        vlstrHora = "23" & Mid(vlstrHora, InStr(1, vlstrHora, ":"), Len(vlstrHora))
      End If
      If Mid(vlstrHora, InStr(1, vlstrHora, ":") + 1, Len(vlstrHora)) > 59 Then
        vlstrHora = CDbl(Mid(vlstrHora, 1, InStr(1, vlstrHora, ":") - 1)) & "00"
      End If
      vldtmHora = CDate(vlstrHora)
      fstrVerificaHora = Format(vldtmHora, "hh:mm")
    End If
    
Exit Function
NotificaError:
    If Err.Number = 13 Then
        fstrVerificaHora = ""
        On Error GoTo 0
    End If
End Function

Public Function fblnValidaPwdEmp(vlintCveEmpleado As Integer, vlstrPwd As String) As Boolean
'Funcion para comprobar si la contraseña del empleado es correcta
'Para utilizar esta funcion debe existir el objeto comando cmdEmpleados y el campo de la contraseña debe
'ser vchPassword
    Dim vlstrLogin As String
    Dim vlstrCont As String
    Dim rsEmpleados As New ADODB.Recordset
    Dim SQL As String
    Dim lintx As Integer
    
    SQL = "select * From noempleado order by 1 "
    Set rsEmpleados = frsRegresaRs(SQL)
    If rsEmpleados.RecordCount > 0 Then
        If fintLocalizaPkRs(rsEmpleados, 0, CStr(vlintCveEmpleado)) > 0 Then
            vlstrLogin = (rsEmpleados!vchApellidoPaterno & " " & rsEmpleados!vchApellidoMaterno & " " & rsEmpleados!vchNombre)
            vlstrCont = fstrEncrypt(vlstrPwd, vlstrLogin)
            fblnValidaPwdEmp = IIf(vlstrCont = rsEmpleados!vchPassword, True, False)
        Else
            fblnValidaPwdEmp = False
        End If
    Else
        fblnValidaPwdEmp = False
    End If
    rsEmpleados.Close

End Function

Public Function pMkTextAsignaValor(ObjTxt As MaskEdBox, vlstrValor As String)
    'Procedimiento para asignar un valor a un control mktext
    ObjTxt.PromptInclude = False
    ObjTxt.AllowPrompt = True
    ObjTxt.Text = vlstrValor
    ObjTxt.PromptInclude = True
    ObjTxt.AllowPrompt = False
End Function

Public Function fstrObtieneEdad(vldtmFecha As Date, vldtmFechaComp As Date)
'Procedimiento para obtener la edad mediante una fecha
    Dim vlstrEdad As String
    Dim vllngEdad As Long
    Dim vlstrFecha As String
    Dim rsParametros As New ADODB.Recordset
    Dim vlstrsql As String
    Dim vlintEdadMinima As Integer
    Dim vlintEdadMaxima As Integer
    Dim vllngA  As Integer
             
    Set rsParametros = frsSelParametros("EX", -1, "INTEDADMINIMAPEDIATRICA")
    If Not rsParametros.EOF Then
        If Not IsNull(rsParametros!Valor) Then
            vlintEdadMinima = CInt(rsParametros!Valor)
        Else
            vlintEdadMinima = 0
        End If
    Else
        vlintEdadMinima = 0
    End If
    rsParametros.Close
    
    Set rsParametros = frsSelParametros("EX", -1, "INTEDADMAXIMAPEDIATRICA")
    If Not rsParametros.EOF Then
        If Not IsNull(rsParametros!Valor) Then
            vlintEdadMaxima = CInt(rsParametros!Valor)
        Else
            vlintEdadMaxima = 100
        End If
    Else
        vlintEdadMaxima = 100
    End If
    rsParametros.Close
    
    vlstrFecha = fstrVerificaFecha(CStr(vldtmFecha))
    If Len(vlstrFecha) > 0 Then
        vllngEdad = CLng(fstrFormatTxt(fstrCalculoFecha(vldtmFechaComp, vldtmFecha, "D", True, True), "N", ">", 10, False))
        If vllngEdad <= 6 Then
            vlstrEdad = fstrCalculoFecha(vldtmFechaComp, vldtmFecha, "D", True, True)
        End If
        If ((vllngEdad > 6) And (vllngEdad < 30)) Then
            vlstrEdad = fstrCalculoFecha(vldtmFechaComp, vldtmFecha, "S", True, True)
        End If
        If ((vllngEdad >= 30) And (vllngEdad < 360)) Then
            vlstrEdad = fstrCalculoFecha(vldtmFechaComp, vldtmFecha, "M", True, True)
        End If
        If (vllngEdad >= 360) Then
            vlstrEdad = fstrCalculoFecha(vldtmFechaComp, vldtmFecha, "A", True, True)
            vllngA = Int(fstrCalculoFecha(vldtmFechaComp, vldtmFecha, "AN", True, True))
            If vllngA >= vlintEdadMinima And vllngA <= vlintEdadMaxima Then
               vlstrEdad = fstrCalculoFecha(vldtmFechaComp, vldtmFecha, "AC", True, True)
            End If
        End If
    Else
        vlstrEdad = ""
    End If
    fstrObtieneEdad = vlstrEdad
End Function

Public Function fstrCantidadenLetras(vldblCantNumerica As Double, vlstrNomMonedaSing As String, vlstrNomMonedaPlural As String, vlstrSignoMoneda As String) As String
'Procedimiento para transformar cantidades numericas en letras
Dim alstrLetras(100)
Dim alintGrupos(10, 3)
Dim vlintNumGrupos As Integer 'Contiene el numero de grupos de tres unidades que tiene una cantidad
Dim vlintLargoNum As Integer 'Contiene el largo del numero
Dim vldblDivision As Double
Dim vlintEntero As Integer
Dim vlintDecimal As Integer
Dim vlintseq As Integer
Dim vlintPosFinG As Integer
Dim vlintPosIniG As Integer
Dim vlintPosIntG As Integer
Dim vlstrNumTexto As String
Dim vlint1n As Integer
Dim vlint2n As Integer
Dim vlint3n, vlintSeqG As Integer
Dim vlstrContenido As String
Dim vlstrSuma As String
'Llenado del arreglo

vlintLargoNum = Len(CStr(vldblCantNumerica))
If vlintLargoNum > 0 Then
    alstrLetras(0) = "CERO"
    alstrLetras(1) = "UN"
    alstrLetras(2) = "DOS"
    alstrLetras(3) = "TRES"
    alstrLetras(4) = "CUATRO"
    alstrLetras(5) = "CINCO"
    alstrLetras(6) = "SEIS"
    alstrLetras(7) = "SIETE"
    alstrLetras(8) = "OCHO"
    alstrLetras(9) = "NUEVE"
    alstrLetras(10) = "DIEZ"
    alstrLetras(11) = "ONCE"
    alstrLetras(12) = "DOCE"
    alstrLetras(13) = "TRECE"
    alstrLetras(14) = "CATORCE"
    alstrLetras(15) = "QUINCE"
    alstrLetras(16) = "DIEZ Y SEIS"
    alstrLetras(17) = "DIEZ Y SIETE"
    alstrLetras(18) = "DIEZ Y OCHO"
    alstrLetras(19) = "DIEZ Y NUEVE"
    alstrLetras(20) = "VEINTE"
    alstrLetras(30) = "TREINTA"
    alstrLetras(40) = "CUARENTA"
    alstrLetras(50) = "CINCUENTA"
    alstrLetras(60) = "SESENTA"
    alstrLetras(70) = "SETENTA"
    alstrLetras(80) = "OCHENTA"
    alstrLetras(90) = "NOVENTA"
    alstrLetras(100) = "CIEN"
    
    alintGrupos(1, 2) = vlstrNomMonedaSing
    alintGrupos(2, 2) = "MIL"
    alintGrupos(3, 2) = "MILLON"
    alintGrupos(4, 2) = "MIL MILLONES"
    alintGrupos(5, 2) = "BILLON"
    alintGrupos(6, 2) = "MIL BILLONES"
    alintGrupos(7, 2) = "TRILLON"
    
    alintGrupos(1, 3) = vlstrNomMonedaPlural
    alintGrupos(2, 3) = "MIL"
    alintGrupos(3, 3) = "MILLONES"
    alintGrupos(4, 3) = "MIL MILLONES"
    alintGrupos(5, 3) = "BILLONES"
    alintGrupos(6, 3) = "MIL BILLONES"
    alintGrupos(7, 3) = "TRILLONES"
    
    'Sacar el numero de grupos
    vlstrNumTexto = CStr(vldblCantNumerica)
    vldblDivision = vlintLargoNum / 3
    vlintEntero = Int(vldblDivision)
    vlintDecimal = vlintLargoNum Mod 3
    If vldblDivision > vlintEntero Then 'Si es mayor
        vlintNumGrupos = vlintEntero + 1
    Else
        vlintNumGrupos = vlintEntero
    End If
    
    'Ingresa el numero de digitos que tiene cada grupo
    For vlintseq = vlintNumGrupos To 1 Step -1
        If vlintseq = vlintNumGrupos Then
            alintGrupos(vlintseq, 1) = vlintLargoNum - ((vlintNumGrupos - 1) * 3)
        Else
            alintGrupos(vlintseq, 1) = 3
        End If
    Next vlintseq
    
    'Transformar cada grupo en letras
    vlstrSuma = ""
    For vlintSeqG = 1 To vlintNumGrupos
        vlstrContenido = ""
        vlintPosIniG = (vlintLargoNum - ((vlintSeqG * 3) - 1)) 'Saca posiciones de inicio y final de grupo
        If vlintPosIniG <= 0 Then
            vlintPosIniG = 1
        End If
        vlintPosIntG = vlintPosIniG + 1
        vlintPosFinG = (vlintPosIniG + alintGrupos(vlintSeqG, 1) - 1)
        
        Select Case alintGrupos(vlintSeqG, 1)
            Case 1 'Unidades (Tiene un solo numero)
                vlint1n = CInt(Mid(vlstrNumTexto, vlintPosIniG, 1))
                Select Case vlint1n
                    Case 1
                        vlstrContenido = vlstrContenido & alstrLetras(vlint1n) & " " & alintGrupos(vlintSeqG, 2)
                    Case 2 To 9
                        vlstrContenido = vlstrContenido & alstrLetras(vlint1n) & " " & alintGrupos(vlintSeqG, 3)
                End Select
            Case 2 'Decenas (Tiene dos numeros)
                vlint1n = CInt(Mid(vlstrNumTexto, vlintPosIniG, 1))
                vlint2n = CInt(Mid(vlstrNumTexto, vlintPosIntG, 1))
                Select Case vlint1n 'Decenas
                    Case 1
                        Select Case vlint2n
                            Case 0 To 9
                                vlstrContenido = vlstrContenido & alstrLetras(CInt(CStr(vlint1n) & CStr(vlint2n))) & " " & alintGrupos(vlintSeqG, 3)
                        End Select
                    Case 2 To 9
                        vlstrContenido = vlstrContenido & alstrLetras(CInt(CStr(vlint1n) & CStr("0")))
                        Select Case vlint2n
                            Case 0
                                vlstrContenido = vlstrContenido & " " & alintGrupos(vlintSeqG, 3)
                            Case 1 To 9
                                vlstrContenido = vlstrContenido & " Y " & alstrLetras(vlint2n) & " " & alintGrupos(vlintSeqG, 3)
                        End Select
                End Select
            Case 3 'Centenas (Tiene tres numeros)
                vlint1n = CInt(Mid(vlstrNumTexto, vlintPosIniG, 1))
                vlint2n = CInt(Mid(vlstrNumTexto, vlintPosIntG, 1))
                vlint3n = CInt(Mid(vlstrNumTexto, vlintPosFinG, 1))
                Select Case vlint1n 'Centenas
                    Case 1
                        Select Case vlint2n 'Decenas
                            Case 0
                                Select Case vlint3n 'Unidades
                                    Case 0
                                        vlstrContenido = vlstrContenido & alstrLetras(CInt(CStr(vlint1n) & CStr(vlint2n) & CStr(vlint3n))) & " " & alintGrupos(vlintSeqG, 3)
                                    Case 1 To 9
                                        vlstrContenido = vlstrContenido & "CIENTO " & alstrLetras(vlint3n) & " " & alintGrupos(vlintSeqG, 3)
                                End Select
                            Case 1
                                vlstrContenido = vlstrContenido & "CIENTO " & alstrLetras(CInt(CStr(vlint2n) & CStr(vlint3n))) & " " & alintGrupos(vlintSeqG, 3)
                            Case 2 To 8
                                Select Case vlint3n
                                    Case 0
                                        vlstrContenido = vlstrContenido & "CIENTO " & alstrLetras(CInt(CStr(vlint2n) & CStr(vlint3n))) & " " & alintGrupos(vlintSeqG, 3)
                                    Case 1 To 9
                                        vlstrContenido = vlstrContenido & "CIENTO " & alstrLetras(CInt(CStr(vlint2n) & CStr("0"))) & " Y " & alstrLetras(vlint3n) & " " & alintGrupos(vlintSeqG, 3)
                                End Select
                        End Select
                    Case 2 To 8 'Centenas
                        Select Case vlint2n 'Decenas
                            Case 0
                                Select Case vlint3n 'Unidades
                                    Case 0
                                        vlstrContenido = vlstrContenido & alstrLetras(vlint1n) & "CIENTOS " & alintGrupos(vlintSeqG, 3)
                                    Case 1 To 9
                                        vlstrContenido = vlstrContenido & alstrLetras(vlint1n) & "CIENTOS " & alstrLetras(vlint3n) & " " & alintGrupos(vlintSeqG, 3)
                                End Select
                            Case 1
                                vlstrContenido = vlstrContenido & alstrLetras(vlint1n) & "CIENTOS " & alstrLetras(CInt(CStr(vlint2n) & CStr(vlint3n))) & " " & alintGrupos(vlintSeqG, 3)
                            Case 2 To 8
                                Select Case vlint3n
                                    Case 0
                                        vlstrContenido = vlstrContenido & alstrLetras(vlint1n) & "CIENTOS " & alstrLetras(CInt(CStr(vlint2n) & CStr(vlint3n))) & " " & alintGrupos(vlintSeqG, 3)
                                    Case 1 To 9
                                        vlstrContenido = vlstrContenido & alstrLetras(vlint1n) & "CIENTOS " & alstrLetras(CInt(CStr(vlint2n) & CStr("0"))) & " Y " & alstrLetras(vlint3n) & " " & alintGrupos(vlintSeqG, 3)
                                End Select
                        End Select
                    Case 9 'Centenas
                        Select Case vlint2n 'Decenas
                            Case 0
                                Select Case vlint3n 'Unidades
                                    Case 0
                                        vlstrContenido = vlstrContenido & "NOVECIENTOS " & alintGrupos(vlintSeqG, 3)
                                    Case 1 To 9
                                        vlstrContenido = vlstrContenido & "NOVECIENTOS " & alstrLetras(vlint3n) & " " & alintGrupos(vlintSeqG, 3)
                                End Select
                            Case 1
                                vlstrContenido = vlstrContenido & "NOVECIENTOS " & alstrLetras(CInt(CStr(vlint2n) & CStr(vlint3n))) & " " & alintGrupos(vlintSeqG, 3)
                            Case 2 To 8
                                Select Case vlint3n
                                    Case 0
                                        vlstrContenido = vlstrContenido & "NOVECIENTOS " & alstrLetras(CInt(CStr(vlint2n) & CStr(vlint3n))) & " " & alintGrupos(vlintSeqG, 3)
                                    Case 1 To 9
                                        vlstrContenido = vlstrContenido & "NOVECIENTOS " & alstrLetras(CInt(CStr(vlint2n) & CStr("0"))) & " Y " & alstrLetras(vlint3n) & " " & alintGrupos(vlintSeqG, 3)
                                End Select
                        End Select
                End Select
        End Select
        vlstrSuma = vlstrContenido & " " & vlstrSuma
    Next vlintSeqG
    If Len(vlstrSignoMoneda) > 0 Then
        fstrCantidadenLetras = vlstrSignoMoneda & " " & vlstrSuma
    Else
        fstrCantidadenLetras = vlstrSuma
    End If
Else
    fstrCantidadenLetras = ""
End If
End Function

Public Function fblnValidaFecha(ObjTxt As MaskEdBox) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica que la fecha sea correcta
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
        Dim vlstrFecha As String
        'Asume que al revisar tendra error
        fblnValidaFecha = False
        If Not IsDate(ObjTxt.Text) Then
          Exit Function
        End If
        vlstrFecha = CDate(ObjTxt)
        If Len(ObjTxt) = 10 Then
        End If
        fblnValidaFecha = (Format$(vlstrFecha, "dd/mm/yyyy") = ObjTxt)

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnValidaFecha"))
End Function
    
Public Function fstrSexo(vlstrSexoLetra As String, vlstrCaso As String)
'Función para cambiar valores de Sexo a números y viceversa
    If vlstrCaso = "L" Then
        If vlstrSexoLetra = "F" Then
            fstrSexo = "1"
        Else
            If vlstrSexoLetra = "M" Then
                fstrSexo = "0"
            Else
                fstrSexo = "2"
            End If
        End If
   Else
        If vlstrSexoLetra = "1" Then
            fstrSexo = "F"
        Else
            If fstrSexo = "0" Then
                fstrSexo = "M"
            Else
                fstrSexo = "A"
            End If
        End If
  End If
End Function

Public Function fblnExisteCriterioRs(ObjRS As Recordset, vlintNumPkey As Integer, vlintNumCampoRev As Integer, vlStrConcepto As String, vlstrCampoClave As String) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica que no se repita un concepto en el RS, utilizando solo dos criterios
'-------------------------------------------------------------------------------------------
On Error GoTo NotificaError
    
    If fintLocalizaPkRs(ObjRS, vlintNumCampoRev, vlStrConcepto) > 0 Then
        If vlstrCampoClave = CStr(ObjRS.Fields(vlintNumPkey).Value) Then
            fblnExisteCriterioRs = False
        Else
            fblnExisteCriterioRs = True
        End If
    Else
        fblnExisteCriterioRs = False
    End If
    Call fintLocalizaPkRs(ObjRS, vlintNumPkey, vlstrCampoClave)

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnExisteCriterioRs"))
End Function

Public Function fblnExiste2CriterioRs(vlstrTabla As String, _
        vlstrPKey As String, vlstrSKey As String, vlstrTKeyCriteria As String, _
        vlstrValPKey As String, vlstrValSKey As String, vlstrValTKey As String, _
        vlstrTipoPKey As String, vlstrTipoSKey As String, vlstrTipoTKey As String) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica que no se repita un concepto en el RS, utilizando solo dos llaves de busqueda y
' y una descripcion o tercer campo de criterio de busqueda
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlstrSentencia As String
    Dim rs As New ADODB.Recordset

    rs.LockType = adLockReadOnly
    rs.CursorType = adOpenKeyset
    Set rs.ActiveConnection = EntornoSIHO.ConeccionSIHO

    vlstrSentencia = "Select * from " & vlstrTabla & " where "
    
    If vlstrTipoSKey = "S" Then
        vlstrSentencia = vlstrSentencia & vlstrSKey & " = '" & vlstrValSKey & "' and "
    Else
        vlstrSentencia = vlstrSentencia & vlstrSKey & " = " & vlstrValSKey & " and "
    End If
    If vlstrTipoTKey = "S" Then
        vlstrSentencia = vlstrSentencia & vlstrTKeyCriteria & " = '" & vlstrValTKey & "'"
    Else
        vlstrSentencia = vlstrSentencia & vlstrTKeyCriteria & " = " & vlstrValTKey
    End If

    rs.Source = vlstrSentencia
    rs.Open
    Select Case rs.RecordCount
        Case 0
            fblnExiste2CriterioRs = False
        Case 1
            If vlstrValPKey = CStr(rs.Fields(vlstrPKey).Value) Then
                fblnExiste2CriterioRs = False
            Else
                fblnExiste2CriterioRs = True
            End If
        Case Is > 1
            fblnExiste2CriterioRs = True
    End Select
    rs.Close
    Set rs = Nothing

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnExiste2CriterioRs"))
End Function

Public Function fdtmServerFecha() As Date
'Procedimiento para tomar la fecha del servidor
'Para utilizar esta funcion debe tener el objeto comando cmdServerFecha enlazado a un store procedure
'que se llama sp_GnServerFecha
    
    On Error GoTo NotificaError
    Dim rsGnServerFecha As New ADODB.Recordset
    
    Set rsGnServerFecha = frsEjecuta_SP("", "Sp_GnServerFecha")
    fdtmServerFecha = Format(CDate(rsGnServerFecha.Fields(0)), "dd/mm/yyyy")
    rsGnServerFecha.Close

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fdtmServerFecha"))
End Function

Public Function fdtmServerHora() As Date
'Procedimiento para tomar la fecha del servidor
'Para utilizar esta funcion debe tener el objeto comando cmdServerFecha enlazado a un store procedure
'que se llama sp_GnServerFecha

    On Error GoTo NotificaError
    
    Dim rsGnServerFecha As New ADODB.Recordset
    
    Set rsGnServerFecha = frsEjecuta_SP("", "Sp_GnServerFecha")
    fdtmServerHora = Format(CDate(rsGnServerFecha.Fields(0)), "hh:mm:ss")
    rsGnServerFecha.Close
    
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fdtmServerHora"))
End Function

Public Sub pEditMkTextMshFGrd(txtEdit As MaskEdBox, vlstrTipoCampo As String, strMask As String, strFormat As String, ObjGrid As MSHFlexGrid, ObjForm As Form)
    'Procedimiento para Editar un control MkText relacionado a un MshFGrid
    'NT Es un campo numerico y se valida si esta vacio
    'AT Es alfabetico y se valida si esta vacio
    'TT Es de tipo texto y se valida que este vacio
    'NF Es numerico y no se valida si esta vacio
    'AF Es Alfabetico y no se valida si esta vacio
    'TF Es de tipo texto y no se valida si esta vacio

    ObjForm.KeyPreview = False
    With txtEdit
        .Enabled = True
        .Mask = strMask
        .Format = strFormat
        .Tag = vlstrTipoCampo
        Call pMkTextAsignaValor(txtEdit, ObjGrid.Text)

        With ObjGrid
            If ObjGrid.CellWidth < 0 Then
                Exit Sub
            Else
                txtEdit.Move ObjGrid.Left + ObjGrid.CellLeft, ObjGrid.Top + ObjGrid.CellTop, ObjGrid.CellWidth - 8, ObjGrid.CellHeight - 8
            End If
        End With
        .Visible = True
        .SelStart = 0
        .SelLength = Len(txtEdit)
        .SetFocus
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEditMkTextMshFGrd"))
End Sub

Public Sub pProcessMkTextMshFGrd(txtEdit As MaskEdBox, strEvento As String, KeyCode As Integer, KeyAscii As Integer, _
ObjGrid As MSHFlexGrid, vlintPrimerColEdit As Integer, vlstrCmdNombre As String, ObjForm As Form)
'Procedimiento para desarrollar procesos relacionados con un Mktext
    Dim vlstrContenido As String
    Dim vlblnMostrarMsg, vlblnMsg As Boolean 'Variable para Mostrar el mensaje
    Dim vlblnRevisaMsg As Boolean 'Variable para revisar si se necesita verificar el mensaje
    Dim vlstrTag, vlstrValor As String
    
    If fintBuscaCharStr(txtEdit.Format, "d", True) > 0 Then ' Pregunta si es una fecha, ya que en la mascara de salida se encontrara dd/mmm/yyyy
        vlstrContenido = fstrVerificaFecha(txtEdit.Text)
    Else
        vlstrContenido = txtEdit.Text
    End If
    
    vlstrTag = txtEdit.Tag
    
    Select Case vlstrTag
        Case "NT", "AT", "TT" 'Si se revisa si el campo esta vacio
            vlblnRevisaMsg = True
        Case "NF", "AF", "TF" 'No se revisa si el campo esta vacio, no importa si queda vacio
            vlblnRevisaMsg = False
    End Select
    
    vlblnMsg = False 'Que no se despliega mensaje
    
    Select Case strEvento
        Case "Change" 'Cuando se desarrolla un evento Change
            ObjGrid.Text = Format(vlstrContenido, txtEdit.Format)
        Case "Keydown"
            Select Case KeyCode
                Case vbKeyEscape
                    If vlblnRevisaMsg = True Then
                        If Len(Trim(txtEdit)) > 0 Then
                            txtEdit.Visible = False
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                ObjGrid.SetFocus
                            End If
                        Else
                            vlblnMostrarMsg = True
                        End If
                    Else
                        txtEdit.Visible = False
                        If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                            ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                            Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                            ObjGrid.SetFocus
                        End If
                    End If
                Case vbKeyUp
                    If vlblnRevisaMsg = True Then
                        If Len(Trim(txtEdit)) > 0 Then
                            If (ObjGrid.Row - 1) > 0 Then
                                txtEdit.Visible = False
                                
                                If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                    ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                    Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                    ObjGrid.SetFocus
                                End If
                                ObjGrid.Row = ObjGrid.Row - 1
                            Else
                                txtEdit.Visible = False
                                If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                    ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                    Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                    ObjGrid.SetFocus
                                End If
                            End If
                        Else
                            vlblnMostrarMsg = True
                        End If
                    Else
                        If (ObjGrid.Row - 1) > 0 Then
                            txtEdit.Visible = False
                            
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                ObjGrid.SetFocus
                            End If
                            ObjGrid.Row = ObjGrid.Row - 1
                        Else
                            txtEdit.Visible = False
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                ObjGrid.SetFocus
                            End If
                        End If
                    End If
                Case vbKeyDown
                    If vlblnRevisaMsg = True Then
                        If Len(Trim(txtEdit)) > 0 Then
                            If (ObjGrid.Row + 1) < (ObjGrid.Rows) Then
                                txtEdit.Visible = False
                                
                                If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                    ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                    Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                    ObjGrid.SetFocus
                                End If
                                ObjGrid.Row = ObjGrid.Row + 1
                            Else
                                txtEdit.Visible = False
                                If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                    ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                    Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                    ObjGrid.SetFocus
                                End If
                            End If
                        Else
                            vlblnMostrarMsg = True
                        End If
                    Else
                        If (ObjGrid.Row + 1) < (ObjGrid.Rows) Then
                            txtEdit.Visible = False
                            
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                ObjGrid.SetFocus
                            End If
                            ObjGrid.Row = ObjGrid.Row + 1
                        Else
                            txtEdit.Visible = False
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                ObjGrid.SetFocus
                            End If
                        End If
                    End If
                    
                Case vbKeyReturn
                    If vlblnRevisaMsg = True Then
                        If Len(Trim(txtEdit)) > 0 Then
                            ObjGrid.SetFocus
                            If ((ObjGrid.Col + 1) > (ObjGrid.Cols - 1)) Then
                                If (ObjGrid.Row + 1) > (ObjGrid.Rows - 1) Then
                                    If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                        ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                        Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                        ObjGrid.SetFocus
                                    End If
                                Else
                                    If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                        ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                        Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                        ObjGrid.SetFocus
                                    End If
                                    ObjGrid.Row = ObjGrid.Row + 1
                                    If vlintPrimerColEdit > 0 Then
                                        ObjGrid.Col = vlintPrimerColEdit
                                    End If
                                End If
                                txtEdit.Visible = False
                            Else
                                txtEdit.Visible = False
                                If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                    ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                    Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                    ObjGrid.SetFocus
                                End If
                                If vlintPrimerColEdit > 0 Then
                                    ObjGrid.Col = ObjGrid.Col + 1
                                End If
                            End If
                        Else
                            vlblnMostrarMsg = True
                        End If
                    Else
                        ObjGrid.SetFocus
                        If (ObjGrid.Col + 1) > (ObjGrid.Cols - 1) Then
                            If (ObjGrid.Row + 1) > (ObjGrid.Rows - 1) Then
                                If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                    ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                    Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                    ObjGrid.SetFocus
                                End If
                            Else
                                If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                    ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                    Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                    ObjGrid.SetFocus
                                End If
                                ObjGrid.Row = ObjGrid.Row + 1
                                If vlintPrimerColEdit > 0 Then
                                    ObjGrid.Col = vlintPrimerColEdit
                                End If
                            End If
                            txtEdit.Visible = False
                        Else
                            
                            txtEdit.Visible = False
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = Format(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), txtEdit.Format)
                                Call pMkTextActualRs(vlstrCmdNombre, ObjGrid)
                                ObjGrid.SetFocus
                            End If
                            If vlintPrimerColEdit > 0 Then
                                ObjGrid.Col = ObjGrid.Col + 1
                            End If
                        End If
                    End If
            End Select
        Case "KeyPress"
            Select Case KeyAscii
                Case vbKeyBack
                    Call pMkTextAsignaValor(txtEdit, "")
                Case 48 To 57, vbKeyA To vbKeyZ, 46
                    Call pMkTextAsignaValor(txtEdit, Chr(KeyAscii))
                    txtEdit.SelStart = Len(fstrFormatTxt(fstrValTextMkText(txtEdit.Text, txtEdit.Tag), "T", ">", 100, True))
                Case Else
            End Select
        Case "LostFocus"
            txtEdit.Visible = False
            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                ObjGrid.SetFocus
                Call pMkTextAsignaValor(txtEdit, "")
            End If
            ObjForm.KeyPreview = True
    End Select
    
    If vlblnMostrarMsg = True Then
        Select Case txtEdit.Tag
            Case "NT" 'Si se revisa el campo de tipo numerico
                Call MsgBox("!Debe existir un valor mayor que cero!", vbExclamation, "Mensaje")
            Case "AT" 'Si se revisa el campo de tipo Alfabetico
                Call MsgBox("!Se debe ingresar datos, no puede quedar sin datos!", vbExclamation, "Mensaje")
            Case "TT" 'Si se revisa si el campo de tipo texto
                Call MsgBox("!Se debe ingresar datos, no puede quedar sin datos!", vbExclamation, "Mensaje")
        End Select
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pProcessMkTextMshFGrd"))
End Sub

Public Sub pEditCboMshFGrd(cboEdit As ComboBox, vlstrDataMember As String, _
vlintItemData As Integer, vlintList As Integer, vlintCaso As Integer, _
ObjGrid As MSHFlexGrid, ObjForm As Form)
'Procedimiento para Editar un control ComboBox relacionado a un MshFGrid
    
    ObjGrid.RowHeight(ObjGrid.Row) = 350
    ObjForm.KeyPreview = False
    With cboEdit
        .Enabled = True
        If Len(vlstrDataMember) > 0 Then
            If EntornoSIHO.Recordsets(vlstrDataMember).State = 0 Then
                EntornoSIHO.Recordsets(vlstrDataMember).Open
                Call pLlenarCboRs(cboEdit, EntornoSIHO.Recordsets(vlstrDataMember), vlintItemData, CStr(vlintList), vlintCaso)
                EntornoSIHO.Recordsets(vlstrDataMember).Close
            Else
                Call pLlenarCboRs(cboEdit, EntornoSIHO.Recordsets(vlstrDataMember), vlintItemData, CStr(vlintList), vlintCaso)
            End If
        End If
        If cboEdit.ListCount > 0 Then
            
            Select Case vlintCaso
                Case -1 To 0
                    cboEdit.ListIndex = fintLocalizaCritCbo(cboEdit, ObjGrid.Text)
                Case Else
                    cboEdit.ListIndex = fintLocalizaCritCbo(cboEdit, ObjGrid.Text)
            End Select
            With ObjGrid
                If ObjGrid.CellWidth < 0 Then
                    Exit Sub
                Else
                    cboEdit.Move ObjGrid.Left + ObjGrid.CellLeft, ObjGrid.Top + ObjGrid.CellTop, ObjGrid.CellWidth - 8
                End If
            End With
            .Visible = True
            .SetFocus
        Else
            cboEdit.Clear
            cboEdit.Visible = False
            ObjGrid.SetFocus
        End If
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEditCboMshFGrd"))
End Sub

Public Sub pProcessCboMshFGrd(cboEdit As ComboBox, strEvento As String, KeyCode As Integer, KeyAscii As Integer, ObjGrid As MSHFlexGrid, ObjForm As Form)
'Procedimiento para desarrollar procesos relacionados con un Mktext
    Dim vlstrContenido As String
    Dim vlintseq As Integer
    
    vlstrContenido = cboEdit.Text
    
    Select Case strEvento
        Case "Click" 'Cuando se desarrolla un evento Change
            ObjGrid.Text = cboEdit.Text
        Case "Keydown"
            Select Case KeyCode
                Case vbKeyEscape
                    cboEdit.Visible = False
                    If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                        ObjGrid.Text = cboEdit.Text
                        ObjGrid.SetFocus
                    End If
                Case vbKeyUp
                    'DoEvents
                    If cboEdit.ListIndex = 0 Then
                        If (ObjGrid.Row - 1) > 0 Then
                            cboEdit.Visible = False
                            ObjGrid.Row = ObjGrid.Row - 1
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = cboEdit.Text
                                ObjGrid.SetFocus
                            End If
                        Else
                            cboEdit.Visible = False
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = cboEdit.Text
                                ObjGrid.SetFocus
                            End If
                        End If
                    End If
                Case vbKeyReturn
                If cboEdit.Visible = True Then
                    If (ObjGrid.Row + 1) > (ObjGrid.Rows - 1) Then
                        cboEdit.Visible = False
                        If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                            ObjGrid.Text = cboEdit.Text
                            ObjGrid.SetFocus
                        End If
                    Else
                        cboEdit.Visible = False
                        If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                            ObjGrid.Text = cboEdit.Text
                            ObjGrid.SetFocus
                        End If
                        ObjGrid.Row = ObjGrid.Row + 1
                    End If
                Else
                    If cboEdit.ListIndex = cboEdit.ListCount Then
                        ObjGrid.SetFocus
                        If (ObjGrid.Row + 1) > (ObjGrid.Rows - 1) Then
                            cboEdit.Visible = False
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = cboEdit.Text
                                ObjGrid.SetFocus
                            End If
                        Else
                            cboEdit.Visible = False
                            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                                ObjGrid.Text = cboEdit.Text
                                ObjGrid.SetFocus
                            End If
                            ObjGrid.Row = ObjGrid.Row + 1
                        End If
                    End If
                End If
            End Select
        Case "KeyPress"
            Select Case KeyAscii
                Case vbKeyDown, vbKeyF2
                Case 48 To 57, Asc("a") To Asc("z"), Asc("A") To Asc("Z"), 46
                        If cboEdit.ListCount > 0 Then
                            cboEdit.ListIndex = fintLocalizaTxtCbo(cboEdit, Chr(KeyAscii))
                            If Len(ObjGrid.Text) > 0 Then
                                cboEdit.ListIndex = fintLocalizaTxtCbo(cboEdit, ObjGrid.Text)
                            Else
                                If cboEdit.ListCount = 0 Then
                                    cboEdit.ListIndex = -1
                                Else
                                    If cboEdit.ListCount > 1 Then
                                        cboEdit.ListIndex = 1
                                    Else
                                        cboEdit.ListIndex = -1
                                    End If
                                End If
                            End If
                        End If
                Case Else
            End Select
        Case "LostFocus"
            cboEdit.Visible = False
            If ObjGrid.Enabled = True And ObjGrid.Rows > 1 Then
                ObjGrid.SetFocus
                cboEdit.Clear
            End If
            ObjGrid.Redraw = False
            For vlintseq = 1 To ObjGrid.Rows - 1
                ObjGrid.RowHeight(vlintseq) = 240
            Next vlintseq
            ObjGrid.Redraw = True
            ObjForm.KeyPreview = True
    End Select
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pProcessCboMshFGrd"))
End Sub

Public Function fdblSumRs(ObjRS As Recordset, vlintNumCampo As Integer) As Double
'Procedimiento para realizar la suma de un campo especifico del recordset

    On Error GoTo NotificaError
    Dim vlintseq As Integer
    Dim vldblSuma As Double
    
    If ObjRS.RecordCount > 0 Then
        vldblSuma = 0
        ObjRS.MoveFirst
        For vlintseq = 1 To ObjRS.RecordCount
            vldblSuma = vldblSuma + CDbl(ObjRS.Fields(vlintNumCampo).Value)
            ObjRS.MoveNext
        Next vlintseq
        fdblSumRs = vldblSuma
    Else
        fdblSumRs = 0
    End If

NotificaError:
    If vgblnExistioError Then
        Exit Function
    Else
        If Err.Number <> 0 Then
            Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fdblSumRs"))
    
            On Error GoTo 0
            vgblnExistioError = True
            Exit Function
        End If
    End If
End Function

Public Function fstrSigNumRegCha(ObjRS As Recordset, vlintNumCampo As Integer) As String
'-------------------------------------------------------------------------------------------
' Función que busca el último registro del recordset y le agrega uno (para efectos de visualizar
' en pantalla el siguiente consecutivo
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlstrCampo As String
    Dim vlintCampoCve As Integer
    Dim vlintUltimoCampo As Integer
    Dim vlstrNombreCampo As String
    
    vlintUltimoCampo = ObjRS.RecordCount
    vlintUltimoCampo = vlintUltimoCampo + 1
        
    vlstrNombreCampo = ObjRS.Fields(vlintNumCampo).Name
    vlstrCampo = vlstrNombreCampo & " Asc"
    If ObjRS.RecordCount > 0 Then
        ObjRS.Sort = vlstrCampo
        ObjRS.MoveLast
        '**********************************************************
        If vlintUltimoCampo <= 9 Then
            fstrSigNumRegCha = "00" & CStr(vlintUltimoCampo) 'OJO,Checar el .Value ver por que no jala familias, por que necesita agregar uno más en vez de un uno
        Else
            If vlintUltimoCampo >= 10 And vlintUltimoCampo < 100 Then
                fstrSigNumRegCha = "0" & CStr(vlintUltimoCampo)
            End If
            If vlintUltimoCampo >= 100 Then
                fstrSigNumRegCha = CStr(vlintUltimoCampo)
            End If
        End If
        '**************************************************
    Else
        fstrSigNumRegCha = "001"
    End If
    
NotificaError:
    If vgblnExistioError Then
        Exit Function
    Else
        If Err.Number <> 0 Then
            Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrSigNumRegCha"))
            On Error GoTo 0
            vgblnExistioError = True
            Exit Function
        End If
    End If

End Function

Public Function fstrNumRegChaa(vlintNumCampo As Integer, Optional vlintcaracteres As Integer) As String
'-------------------------------------------------------------------------------------------
' Función que cambia una clave numerica a caracter y agrega ceros al comienzo
'-------------------------------------------------------------------------------------------
' Se modificó para poderle enviar de que tamaño debe quedar el campo
' 18/Diciembre/2003 Mónica Ordoñez
        On Error GoTo NotificaError
        
        Dim vlstrCadena As String
        
        If vlintcaracteres = 0 Then
            vlintcaracteres = 3
        End If
     
        vlstrCadena = CStr(vlintNumCampo)
        
        While Len(vlstrCadena) < vlintcaracteres
            vlstrCadena = "0" & vlstrCadena
        Wend
        fstrNumRegChaa = vlstrCadena
        
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrNumRegChaa"))
End Function

'-------------------------------------------------------------------------
'||  Recibe un número y lo regresa con ceros a la iquierda dependiendo
'||  de la configuración de la clave del artículo para la familia
'-------------------------------------------------------------------------
Public Function fstrFormateaComoFamilia(lngClave As Long) As String
    Dim objArticulo As New clsArticulo
    
On Error GoTo NotificaError
    fstrFormateaComoFamilia = objArticulo.fstrFormateaSegmento(lngClave, saFamilia)
    Set objArticulo = Nothing
    Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrFormateaComoFamilia"))
End Function

'-------------------------------------------------------------------------
'||  Recibe un número y lo regresa con ceros a la iquierda dependiendo
'||  de la configuración de la clave del artículo para la subfamilia
'-------------------------------------------------------------------------
Public Function fstrFormateaComoSubFamilia(lngClave As Long) As String
    Dim objArticulo As New clsArticulo
    
On Error GoTo NotificaError
    fstrFormateaComoSubFamilia = objArticulo.fstrFormateaSegmento(lngClave, saSubFamilia)
    Set objArticulo = Nothing
    Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrFormateaComoSubFamilia"))
End Function

'-------------------------------------------------------------------------
'||  Recibe un número y lo regresa con ceros a la iquierda dependiendo
'||  de la configuración de la clave del artículo para el consecutivo
'-------------------------------------------------------------------------
Public Function fstrFormateaComoConsecutivo(lngClave As Long) As String
    On Error GoTo NotificaError
    
    Dim objArticulo As New clsArticulo
    
    fstrFormateaComoConsecutivo = objArticulo.fstrFormateaSegmento(lngClave, saConsecutivo)
    Set objArticulo = Nothing
    Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrFormateaComoConsecutivo"))
End Function

Public Function fblnValidaConcepto(ObjRS As Recordset, vlintNumPkey As Integer, vlStrConcepto As String, vlstrClave As String) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica que no se repita un concepto en el RS
'-------------------------------------------------------------------------------------------
On Error GoTo NotificaError
    
    Dim vlintCve As Integer
    Dim vllngCve As Long
    Dim vlintExisteReg As Integer
    Dim vlintExisteRegis As Integer
    Dim vlblnFlag As Boolean

    vlintExisteReg = fintLocalizaPkRs(ObjRS, vlintNumPkey, vlStrConcepto)  'Busca la descripcion para ver si esta repetida
    If vlintExisteReg <> 0 Then
       vllngCve = ObjRS.Fields(0).Value
    End If
    If vllngCve = vlstrClave Then
       vlintExisteRegis = fintLocalizaPkRs(ObjRS, 0, vlstrClave)  'Busca la clave para ver si existe
    End If
    If vlintExisteReg <> 0 And vlintExisteRegis = 0 Then
       fblnValidaConcepto = True
    Else
        fblnValidaConcepto = False
    End If

NotificaError:
    If vgblnExistioError Then
        Exit Function
    Else
        If Err.Number <> 0 Then
            Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnValidaConcepto"))
            On Error GoTo 0
            vgblnExistioError = True
            Exit Function
        End If
    End If
End Function

Public Function fdblProxNum(vlstrNombreTabla As String, Optional vlstrNombreSecuencia As String) As Double
'-----------------------------------------------------------------------------------------------
' Función que busca el último registro del recordset y le agrega uno (para efectos de visualizar
' en pantalla el siguiente consecutivo
'-----------------------------------------------------------------------------------------------
  On Error GoTo NotificaError
  Dim vlstrSentencia As String
  Dim vlrsIdentity As New ADODB.Recordset

  fdblProxNum = 1
  If vgstrBaseDatosUtilizada = "ORACLE" Then
    If vlstrNombreSecuencia = "" Then
      vlstrNombreSecuencia = "SEC_" & vlstrNombreTabla
    End If
    vlstrSentencia = "SELECT MAX(" & Trim(vlstrNombreSecuencia) & ") FROM " & vlstrNombreTabla
    Set vlrsIdentity = frsRegresaRs(vlstrSentencia)
    If vlrsIdentity.State <> adStateClosed Then
      If vlrsIdentity.RecordCount > 0 Then
        If Not IsNull(vlrsIdentity.Fields(0)) Then
          fdblProxNum = vlrsIdentity.Fields(0) + 1
        End If
      End If
      vlrsIdentity.Close
    End If
  Else 'SQL Server
    vlstrSentencia = "Select max(IDENTITYCOL) from " & vlstrNombreTabla
    Set vlrsIdentity = frsRegresaRs(vlstrSentencia)
    If vlrsIdentity.State <> adStateClosed Then
      If vlrsIdentity.RecordCount = 1 Then
        If Not IsNull(vlrsIdentity.Fields(0).Value) Then
          fdblProxNum = vlrsIdentity.Fields(0).Value + 1
        End If
      End If
      vlrsIdentity.Close
    End If
  End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fdblProxNum"))
End Function

Public Sub pCierraObjCmd()
    Dim vlintseq
    For vlintseq = 1 To EntornoSIHO.Recordsets.Count
        If EntornoSIHO.Recordsets(vlintseq).State = 1 Then
            EntornoSIHO.Recordsets(vlintseq).Close
        End If
    Next vlintseq
End Sub

Public Sub pError()
'Procedimiento para manipular el error
    If Err.Number <> 0 Then
        Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":" & vgstrNombreProcedimiento))
    End If
End Sub

Public Function frsRegresaRs(Optional vlstrSentencia As String, Optional vlintTipoBloq As ADODB.LockTypeEnum, Optional vlintTipoCursor As ADODB.CursorTypeEnum, Optional vlintRowNum As Integer, Optional vlblnConexionEspecial As Boolean = False, Optional vlcnnConexion As ADODB.Connection) As ADODB.Recordset
'Funcion para ejecutar una sentencia Select y obtener un recordset
'On Error GoTo NotificaError

    'Declaración de variables locales
    Dim rs As New ADODB.Recordset
    Dim vlIntCont As Integer
    Dim vlblnBand As Boolean
    Dim vlstrResultado As String
    Dim vlintInicio As Integer
    
    'Rutina que reemplaza el double pipe (||) por el signo de mas (+)
    'en caso de que se este trabajando en una base de datos MSSQL
    If vgstrBaseDatosUtilizada = "MSSQL" Then
        vlstrResultado = ""
        vlintInicio = 1
        For vlIntCont = 1 To Len(vlstrSentencia) + 1
            If Not (vlblnBand) Then
                If (Mid(vlstrSentencia, vlIntCont, 1) = "|") Then vlblnBand = True
            Else
                If (Mid(vlstrSentencia, vlIntCont, 1) = "|") Then
                    vlstrResultado = vlstrResultado & Mid(vlstrSentencia, vlintInicio, (vlIntCont - vlintInicio - 1)) & "+"
                    vlintInicio = vlIntCont + 1
                    vlblnBand = False
                End If
            End If
            If Len(vlstrSentencia) = vlIntCont Then vlstrResultado = vlstrResultado & Mid(vlstrSentencia, vlintInicio, (vlIntCont - vlintInicio + 1))
        Next vlIntCont
        vlstrSentencia = vlstrResultado
    End If
    
    vgstrNombreProcedimiento = "frsRegresaRs"
        
    rs.MaxRecords = vlintRowNum
    
    If vlintTipoBloq = 0 Then
        vlintTipoBloq = adLockReadOnly
    End If
    If Len(vlstrSentencia) > 0 Then
        rs.LockType = vlintTipoBloq
        rs.CursorType = vlintTipoCursor
        
        If EntornoSIHO.ConeccionSIHO.State = 0 Then
            EntornoSIHO.ConeccionSIHO.Open
        End If
        If vlblnConexionEspecial Then
          Set rs.ActiveConnection = vlcnnConexion
        Else
          Set rs.ActiveConnection = EntornoSIHO.ConeccionSIHO
        End If
        rs.Source = vlstrSentencia
        rs.Open
        Set frsRegresaRs = rs
    End If

Exit Function

NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":frsRegresaRs"))
End Function

Public Sub pValidaNumero(KeyAscii As Integer)
On Error GoTo NotificaError
' Solo permite números
    
    Select Case KeyAscii
        Case Asc(vbCr)
            KeyAscii = 0
        Case 8, 46
        Case 48 To 57
        Case Else
            KeyAscii = 0
    End Select

NotificaError:
    If vgblnExistioError Then
        Exit Sub
    Else
        If Err.Number <> 0 Then
            Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pValidaNumero"))
            On Error GoTo 0
            vgblnExistioError = True
            Exit Sub
        End If
    End If
End Sub

Public Function fstrValTextMkText(vlstrTexto, vlstrTipo) As String
    Select Case vlstrTipo
        Case "NT", "NF"
            fstrValTextMkText = fstrFormatTxt(vlstrTexto, "N", "", 100, False)
            If Len(fstrValTextMkText) = 0 Then
                fstrValTextMkText = "0"
            End If
        Case "AT", "AF"
            fstrValTextMkText = fstrFormatTxt(vlstrTexto, "A", ">", 1000, True)
        Case "TT", "TF"
            fstrValTextMkText = fstrFormatTxt(vlstrTexto, "T", ">", 10000, True)
    End Select
End Function

Public Sub pMkTextActualRs(vlstrCmdNombre As String, ObjGrid As MSHFlexGrid)
'Procedimiento para actualizar datos de un recordset cuando se utiliza un mshflex editable
    Dim vlintNumCols As Integer
    If Len(vlstrCmdNombre) > 0 Then
        If fintLocalizaPkRs(EntornoSIHO.Recordsets(vlstrCmdNombre), 0, ObjGrid.TextMatrix(ObjGrid.Row, 1)) > 0 Then
            EntornoSIHO.Recordsets(vlstrCmdNombre).Fields(ObjGrid.Col - 1).Value = ObjGrid.TextMatrix(ObjGrid.Row, ObjGrid.Col)
            EntornoSIHO.Recordsets(vlstrCmdNombre).Update
        End If
    End If
End Sub

Public Sub pLlenarListRs(ObjList As ListBox, ObjRS As Recordset, vlintNumCampoItmData As Integer, vlintNumCampoList As String, Optional vlintNumCaso As Integer, Optional vlblnMuestraError As Boolean)
'-------------------------------------------------------------------------------------------
' Llena un combobox con datos de un recordset, pidiendo
' ObjList List Box en donde se llenaran los datos
' ObjRS Recorsed de donde se llenaran los datos
' vlintNumCampoItmData Numero de campo dek RS para guardarlo en la posicion ItemData del ComboBox
' vlintNumCampoList Numero del campo del RS para guardarlos en la posicion List del ComboBox
' vlintNumCaso para llenar con Agregar o Mantenimiento segun el caso
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim vlintNumCampoOrd As Long
    Dim vlintNumReg, vlintSeqCampos, vlintNum As Long
    Dim vlintseq As Long
    Dim vlstrNombreCampo As String
    Dim vlstrNomCampos, vlstrCampo As String
    Dim vlNum As Long
    Dim vlintIniciaSeq As Long
    vlintNumReg = ObjRS.RecordCount
    ObjList.Visible = False
    vlNum = 0
    ObjList.Clear
    Select Case vlintNumCaso
        Case Is = 1
                ObjList.AddItem "<AGREGAR>", 0
        Case Is = 2
            If vlintNumCaso > 0 Then
                Select Case vlintNumReg
                    Case 0
                        ObjList.AddItem "<AGREGAR>", 0
                    Case Is > 0
                        ObjList.AddItem "<MANTENIMIENTO>", 0
                End Select
            End If
        Case Is = 3
                ObjList.AddItem "<TODOS>", 0
        Case Is = 4
                ObjList.AddItem "<NINGUNO(A)>", 0
        Case Is = 5
                ObjList.AddItem "<MANTENIMIENTO>", 0
    End Select
    
    vlintNumCampoOrd = CInt(fstrFormatTxt(vlintNumCampoList, "N", "", 20, False))
    If (vlintNumReg > 0) Then
        ObjRS.MoveFirst
        vlstrNombreCampo = ObjRS.Fields(vlintNumCampoOrd).Name
        vlstrCampo = vlstrNombreCampo & " Asc"
        ObjRS.Sort = vlstrCampo
        vlintIniciaSeq = ObjList.ListCount
        For vlintseq = 1 To vlintNumReg
            If vlintseq < 32768 Then
                Select Case vlintNumCampoList
                    Case Is = "*" 'En la lista suma todos los campos
                        vlstrNombreCampo = ObjRS.Fields(0).Name
                        vlstrCampo = vlstrNombreCampo & " Asc"
                        vlstrNomCampos = ""
                        For vlintSeqCampos = 0 To ObjRS.Fields.Count - 1
                            If vlintSeqCampos = ObjRS.Fields.Count - 1 Then
                                If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                    vlstrNomCampos = vlstrNomCampos & ""
                                Else
                                    vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos)
                                End If
                            Else
                                If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                    vlstrNomCampos = vlstrNomCampos & " - "
                                Else
                                    vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos) & " - "
                                End If
                            End If
                        Next vlintSeqCampos
                        ObjList.AddItem UCase(vlstrNomCampos), vlintIniciaSeq
                    Case Is = "@" 'En la lista suma todos los campos menos el campo clave
                        vlstrNombreCampo = ObjRS.Fields(0).Name
                        vlstrCampo = vlstrNombreCampo & " Asc"
                        vlstrNomCampos = ""
                        vlintNum = vlintNumCampoItmData
                        For vlintSeqCampos = 0 To ObjRS.Fields.Count - 1
                            If vlintSeqCampos <> vlintNum Then
                                If vlintSeqCampos = ObjRS.Fields.Count - 1 Then
                                    If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                        vlstrNomCampos = vlstrNomCampos & ""
                                    Else
                                        vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos)
                                    End If
                                Else
                                    If IsNull(ObjRS.Fields(vlintSeqCampos)) Then
                                        vlstrNomCampos = vlstrNomCampos & " - "
                                    Else
                                        vlstrNomCampos = vlstrNomCampos & ObjRS.Fields(vlintSeqCampos) & " - "
                                    End If
                                End If
                            End If
                        Next vlintSeqCampos
                        ObjList.AddItem UCase(vlstrNomCampos), vlintIniciaSeq
                    Case Else 'En la lista va solo en campo que se envio
                        If IsNull(ObjRS.Fields(CInt(vlintNumCampoList))) Then
                            ObjList.AddItem "< >", vlintIniciaSeq
                        Else
                            ObjList.AddItem UCase(ObjRS.Fields(CInt(vlintNumCampoList))), vlintIniciaSeq
                        End If
                End Select
                
                If vlintNumCampoItmData >= 0 Then
                    If IsNumeric(ObjRS.Fields(vlintNumCampoItmData).Value) = True Then
                        ObjList.ItemData(vlintIniciaSeq) = CDbl(ObjRS.Fields(vlintNumCampoItmData).Value)
                    Else
                        ObjList.ItemData(vlintIniciaSeq) = 0
                    End If
                Else
                    ObjList.ItemData(vlintIniciaSeq) = ObjRS.Bookmark
                End If
                vlintIniciaSeq = vlintIniciaSeq + 1
                ObjRS.MoveNext
            Else
                Exit For
            End If
        Next vlintseq
        ObjRS.MoveFirst
    Else
        If vlblnMuestraError = True Then
            Call MsgBox((SIHOMsg(13) & Chr(13) & ObjList.ToolTipText), vbExclamation, "Mensaje") 'Toma un mensaje del módulo de mensajes y lo despliega
        End If
    End If
    
    ObjList.Visible = True
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLlenarListRs" & " " & ObjList.Name))
End Sub

Function fstrConvierteChr(ValorChar As String) As String
  Dim i As Integer
  Dim vlstr As String
  
  fstrConvierteChr = ""
  If IsNumeric(ValorChar) Then
    i = 0
    For i = 1 To Len(ValorChar)
      If Mid(ValorChar, i, 1) <> "." Then
        vlstr = vlstr & Mid(ValorChar, i, 1)
        If (i Mod 3) = 0 Then
          fstrConvierteChr = fstrConvierteChr & Chr(CLng(vlstr))
          vlstr = ""
        End If
      End If
    Next i
  End If
End Function

Function fstrConvierteAsc(ValorAsc As String) As String
  Dim i As Integer
  
  fstrConvierteAsc = ""
  i = 0
  For i = 1 To Len(ValorAsc)
    fstrConvierteAsc = fstrConvierteAsc & Format(Asc(Mid(ValorAsc, i, 1)), "000")
  Next i
End Function

Function fstrRegresaConeccion() As String
  On Error GoTo NotificaError
  'sqloledb.1 para SQL
  'MSDAORA.1 para oracle
  Dim FileNumber
  Dim Registro As String
  Dim vlStrConexion As String
  Dim vlstrSERVERBD As String
  Dim vlstrUSERBD As String
  Dim vlstrPSWBD As String
  Dim vlstrBD As String
  Dim vlstrDato As String
  Dim vlstrDriver As String
  Dim vlstrType As String
  Dim vlstrShow As Integer
  Dim vlintSeguridadIntegrada As Integer
  
  Reset
  vlStrConexion = "DESCONOCIDO"
  vlstrType = UCase(GetSetting("SIHO", "CONEXION", "TYPE", "DESCONOCIDO"))
  If ((vlstrType = "DESCONOCIDO") Or (vlstrType = "")) Then
    frmConeccion.Show vbModal
    If Not vgblnTerminate Then vlstrType = vgstrBaseDatosUtilizada
  End If
  If Not vgblnTerminate Then
      If vlstrType = "MSSQL" Then
        vlstrDriver = UCase(GetSetting("SIHO\CONEXION", "SQL", "DRIVER", "SQLOLEDB.1"))
        vlstrSERVERBD = UCase(GetSetting("SIHO\CONEXION", "SQL", "SERVERBD", "SIC-SERVER-CJ"))
        vlstrUSERBD = UCase(GetSetting("SIHO\CONEXION", "SQL", "USERBD", "SA"))
        vlstrPSWBD = UCase(fstrEncrypt2(fstrConvierteChr(GetSetting("SIHO\CONEXION", "SQL", "PSWBD", "XXXX")), vlstrUSERBD))
        vlstrBD = UCase(GetSetting("SIHO\CONEXION", "SQL", "NAMEBD", "GOB"))
        vlstrShow = GetSetting("SIHO\CONEXION", "SQL", "SHOWSCR", "0")
        vlintSeguridadIntegrada = GetSetting("SIHO\CONEXION", "SQL", "SEGINTEGRADA", "1")
      End If
      If vlstrType = "ORACLE" Then
        vlstrDriver = UCase(GetSetting("SIHO\CONEXION", "ORACLE", "DRIVER", "ORAOLEDB.ORACLE.1"))
        vlstrSERVERBD = UCase(GetSetting("SIHO\CONEXION", "ORACLE", "SERVERBD", "SIHO"))
        vlstrUSERBD = UCase(GetSetting("SIHO\CONEXION", "ORACLE", "USERBD", "DBO"))
        vlstrPSWBD = UCase(fstrEncrypt2(fstrConvierteChr(GetSetting("SIHO\CONEXION", "ORACLE", "PSWBD", "XXXX")), vlstrUSERBD))
        vlstrBD = UCase(GetSetting("SIHO\CONEXION", "ORACLE", "NAMEBD", ""))
        vlstrShow = GetSetting("SIHO\CONEXION", "ORACLE", "SHOWSCR", "0")
      End If
      
      If vlstrType = "ORACLE" Then
        vgstrBaseDatosUtilizada = "ORACLE"
        vlStrConexion = "Provider=MSDataShape.1;Persist Security Info=True;"
        vlStrConexion = vlStrConexion & "Data Source=" & vlstrSERVERBD & ";"
    
        vlStrConexion = vlStrConexion & "User ID=" & vlstrUSERBD & ";"
        vlStrConexion = vlStrConexion & "Password=" & vlstrPSWBD & ";"
        vlStrConexion = vlStrConexion & "Data Provider=" & vlstrDriver
        vlStrConexion = vlStrConexion & ";PLSQLRset=1"
      Else
        vgstrBaseDatosUtilizada = "MSSQL"
    
    '   Autentificacion nt
        vlStrConexion = "Provider=" & vlstrDriver & ";Persist Security Info=False;"
        vlStrConexion = vlStrConexion & "Data Source=" & vlstrSERVERBD & ";"
        vlStrConexion = vlStrConexion & "Initial Catalog=" & vlstrBD & ";" & "Data Provider=" & vlstrDriver & ";"
        If vlintSeguridadIntegrada = 1 Then
            vlStrConexion = vlStrConexion & "Integrated security=SSPI;"
        Else
            vlStrConexion = vlStrConexion & "user id=" & vlstrUSERBD & ";password=" & vlstrPSWBD & ";"
        End If
      End If
  End If
  fstrRegresaConeccion = vlStrConexion
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrRegresaConeccion"))
End Function

Public Function fblnLimpiaForma(ByVal frmObj As Form) As Boolean
   On Error GoTo NotificaError
   ' Inicializa los campos de una forma
   Dim vlobjControl As Control
   For Each vlobjControl In frmObj.Controls
      If TypeOf vlobjControl Is TextBox Then
         vlobjControl.Text = ""
      ElseIf TypeOf vlobjControl Is ComboBox Then
        If vlobjControl.Style <> 0 Then
         If vlobjControl.ListCount > 0 Then
            vlobjControl.ListIndex = 0
         Else
            vlobjControl.ListIndex = -1
         End If
        Else
          vlobjControl.Clear
        End If
      ElseIf TypeOf vlobjControl Is CheckBox Then
         vlobjControl.Value = vbUnchecked
      ElseIf TypeOf vlobjControl Is SSTab Then
         vlobjControl.Tab = 0
      End If
   Next
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnLimpiaForma"))
End Function

Public Sub pFocusNextControl(ByRef parForm As Form, parTabIndex As Integer)
  On Error GoTo NotificaError
  
  Dim intTIAux As Integer
  Dim i As Integer
  Dim blnBand As Boolean
  
  blnBand = False
  intTIAux = parTabIndex + 1
  Dim vlobjControl As Control
  
  For Each vlobjControl In parForm.Controls
    If TypeName(vlobjControl) <> "Timer" And TypeName(vlobjControl) <> "CrystalReport" _
      And TypeName(vlobjControl) <> "SysInfo" And TypeName(vlobjControl) <> "Shape" And TypeName(vlobjControl) <> "Line" And TypeName(vlobjControl) <> "Image" Then
        If (vlobjControl.TabIndex = intTIAux) And _
            (TypeOf vlobjControl Is TextBox Or _
             TypeOf vlobjControl Is ComboBox Or _
             TypeOf vlobjControl Is CommandButton Or _
             TypeOf vlobjControl Is MaskEdBox Or _
             TypeOf vlobjControl Is OptionButton Or _
             TypeOf vlobjControl Is CheckBox Or _
             TypeOf vlobjControl Is DTPicker _
             ) Then
             
              If vlobjControl.Enabled And vlobjControl.Visible Then
                vlobjControl.SetFocus
              End If
            
            Exit For
        End If
    End If
  Next
Exit Sub
NotificaError:
  If Abs(Err.Number) = 5 Then
    Err.Clear
  Else
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pFocusNextControl"))
  End If
End Sub

Public Function flngLocalizaCbo(ObjCbo As ComboBox, vlstrCriterio As String) As Long
  '-------------------------------------------------------------------------------------------
  ' Busca un criterio dentro del combobox -1 indica que no encontro
  '-------------------------------------------------------------------------------------------
  On Error GoTo NotificaError
  
  Dim vllngNumReg As Long
  Dim vllngseq As Long
  
  flngLocalizaCbo = -1
  vllngNumReg = ObjCbo.ListCount
  
  If Len(vlstrCriterio) > 0 Then
    For vllngseq = 0 To vllngNumReg - 1
      If ObjCbo.ItemData(vllngseq) = vlstrCriterio Then
        flngLocalizaCbo = vllngseq
        Exit For
      Else
        flngLocalizaCbo = -1
      End If
    Next vllngseq
  End If
    
Exit Function
NotificaError:
  Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngLocalizaCbo" & " " & ObjCbo.Name))
End Function

Public Function flngLocalizaCboTxt(ObjCbo As ComboBox, vlstrCriterio As String) As Long
  '-------------------------------------------------------------------------------------------
  ' Busca un criterio dentro del combobox -1 indica que no encontro
  '-------------------------------------------------------------------------------------------
  On Error GoTo NotificaError
  
  Dim vllngNumReg As Long
  Dim vllngseq As Long
  
  flngLocalizaCboTxt = -1
  vllngNumReg = ObjCbo.ListCount
  
  If Len(vlstrCriterio) > 0 Then
    For vllngseq = 0 To vllngNumReg - 1
        ObjCbo.ListIndex = vllngseq
        If Trim(ObjCbo.Text) = Trim(vlstrCriterio) Then
            flngLocalizaCboTxt = vllngseq
            Exit For
        Else
          flngLocalizaCboTxt = -1
        End If
    Next vllngseq
  End If
    
Exit Function
NotificaError:
  Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngLocalizaCboTxt" & " " & ObjCbo.Name))
End Function

Public Sub pCrearPrmGnrDefault()
'-------------------------------------------------------------------------------------------
' Procedimiento para crear valores de default en la tabla de parametros generales
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim cl As clsParametros
    Dim X As Integer
   
    Set cl = New clsParametros
    
    cl.PswAdmin = fstrEncrypt("SIHO", "ADMINISTRADOR")
    cl.CuartoPred = 1
    cl.EstadoSalud = 1
    cl.CveDisponible = 1
    cl.CveOcupado = 1
    cl.EmpresaActiva = 1
    cl.AdmEmpleado = 1
    cl.Particular = 1
    cl.Nomina = False
    cl.TiempoMensajes = 0
    cl.ArchivoWAV = "''"
    cl.NacPredeterminada = 1
    cl.DptoEmergencias = 1
    cl.ProveedorAlmacenGral = 1

    X = cl.fintAltaParametros(vgintClaveEmpresaContable)
    
Exit Sub
NotificaError:
    If vgblnExistioError Then
        Exit Sub
    Else
        If Err.Number <> 0 Then
            Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pCrearPrmGnrDefault"))
            On Error GoTo 0
            vgblnExistioError = True
            Exit Sub
        End If
    End If

End Sub

Public Function pEjecutaSentencia(vlstrSentencia As String)
  'Declaración de variables locales
  Dim vlobjCommand As ADODB.Command
  
  On Error GoTo NotificaError

  Set vlobjCommand = CreateObject("ADODB.Command")
  With vlobjCommand
    Set .ActiveConnection = EntornoSIHO.ConeccionSIHO
    .CommandText = vlstrSentencia
    .Execute
  End With

Exit Function
NotificaError:
  Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEjecutaSentencia"))
End Function

Public Function flngObtieneIdentity(vlstrNombreSecuencia As String, vllngIdentity As Long) As Long
  'Función que devuelve el identity de acuerdo a que Base de datos se utiliza
  'Fecha de Ultima modificación : 17/Nov/2003 18:20
    
  'Declaración de variables locales
  Dim rsIdentity As New ADODB.Recordset
  Dim vlstrSentencia As String
  
  flngObtieneIdentity = 0
  
  If vgstrBaseDatosUtilizada = "ORACLE" Then
    vlstrSentencia = "SELECT " & Trim(vlstrNombreSecuencia) & ".CURRVAL FROM DUAL"
    Set rsIdentity = frsRegresaRs(vlstrSentencia)
    If rsIdentity.RecordCount > 0 Then
        flngObtieneIdentity = rsIdentity.Fields(0)
    Else
        flngObtieneIdentity = -1
    End If
    rsIdentity.Close
  Else
    flngObtieneIdentity = vllngIdentity
  End If
    
End Function

Public Function dVal(ByVal cnum As String) As Double
  'Rutina que que te convierte a numerico un valor string
  If IsNumeric(cnum) Then
      dVal = CDbl(cnum)
  Else
      dVal = 0
  End If
End Function

Public Function fstrObtenCveArticulo(vlintIdArticulo As Long) As String
  Dim rsIvArticulo As New ADODB.Recordset

  fstrObtenCveArticulo = ""
  Set rsIvArticulo = frsRegresaRs("SELECT CHRCVEARTICULO FROM IvArticulo WHERE INTIDARTICULO=" & vlintIdArticulo)
  If rsIvArticulo.State <> adStateClosed Then
    If rsIvArticulo.RecordCount > 0 Then
      fstrObtenCveArticulo = rsIvArticulo!chrcvearticulo
    End If
    rsIvArticulo.Close
  End If
End Function

Public Sub pCargaArreglo(paryParametros() As String, pstrParametros As String)
    Dim vlIntCont As Integer
    Dim vlstrValParam As String
    Dim vlintRenglonArreglo As Integer
    Dim vlblnValor As Boolean

    ReDim paryParametros(2, 1)
    vlblnValor = True
    vlintRenglonArreglo = 1
    For vlIntCont = 1 To Len(pstrParametros) + 1
      'Busca el valor del parametro
      If (Mid(pstrParametros, vlIntCont, 1) <> "|") And (Len(pstrParametros) >= vlIntCont) Then
        vlstrValParam = vlstrValParam & Mid(pstrParametros, vlIntCont, 1)
      Else 'Encontró el valor o el tipo del parámetro
          If vlblnValor Then 'El parámetro encontrado es un valor
            ReDim Preserve paryParametros(2, vlintRenglonArreglo)
            paryParametros(0, vlintRenglonArreglo - 1) = vlstrValParam
          Else 'El parámetro encontrado es un tipo de dato
            paryParametros(1, vlintRenglonArreglo - 1) = vlstrValParam
            vlintRenglonArreglo = vlintRenglonArreglo + 1
          End If
          vlstrValParam = ""
          vlblnValor = Not vlblnValor
      End If
    Next vlIntCont

End Sub

Public Sub pObtieneValores(paryParametros() As String, Optional pvrtVariable1, Optional pvrtVariable2, Optional pvrtVariable3, Optional pvrtVariable4, Optional pvrtVariable5)
    Dim vlintRenglon As Integer
    
On Error GoTo NotificaError
    If Not IsMissing(pvrtVariable1) Then
        pvrtVariable1 = paryParametros(0, 0)
        If Not IsMissing(pvrtVariable2) Then
            pvrtVariable2 = paryParametros(0, 1)
            If Not IsMissing(pvrtVariable3) Then
                pvrtVariable3 = paryParametros(0, 2)
                If Not IsMissing(pvrtVariable4) Then
                    pvrtVariable4 = paryParametros(0, 3)
                    If Not IsMissing(pvrtVariable5) Then
                        pvrtVariable5 = paryParametros(0, 4)
                    End If
                End If
            End If
        End If
    End If
    Exit Sub
NotificaError:
    MsgBox Err.Description
End Sub

Function fblnExistePermiso(vlstrLogin As String, vlstrCvePermiso As String) As Boolean

Dim vlrsPermiso As New ADODB.Recordset

    fblnExistePermiso = False
    Set vlrsPermiso = frsRegresaRs("SELECT intNumeroOpcion " & _
                                    "FROM Permiso " & _
                                    "WHERE intNumeroLogin = " & vlstrLogin & " AND " & _
                                    "      intNumeroOpcion = " & vlstrCvePermiso, adLockOptimistic, adOpenDynamic)
    If vlrsPermiso.RecordCount Then fblnExistePermiso = True
End Function

Public Sub fblnHabilitaObjetos(ByVal frmObj As Form)
    On Error GoTo NotificaError
    'Funcion que te compara cada uno de los controles de la forma
    'con el arreglo que se lleno en fblnCargaPermisos para establecer
    'si se activa o desactiva un control segun el permiso
    'Autor: Marco Ronquillo
    'Fecha de creacion: 09-10-2003
    'Fecha de ultima modificacion:
    Dim vlobjControl As Control
    Dim vlIntCont, vlintcontador As Integer
    Dim vlblnEncontro As Boolean
    Dim vlblnDeshabilitadoTab As Boolean
    Dim vlintCmdArray As Integer
    Dim vlblnSePuedeHabilitar As Boolean
    Dim vllngManejador As Long
    
    '[  Si requiere ir a buscar una versión más nueva  ]
    If fblnAutoVerificacion Then pRealizaVerificacion vgintNumeroModulo, False
    'Si no existe ningun permiso para el usuario dehabilita todo y se sale
    If aControlesModulo(1).vlintTotalRegistros = 0 Then
        For Each vlobjControl In frmObj.Controls
            If (TypeOf vlobjControl Is CommandButton Or TypeOf vlobjControl Is MyButton) And UCase(vgstrNombreUsuario) <> "ADMINISTRADOR" Then vlobjControl.Enabled = False
            If (TypeOf vlobjControl Is CommandButton Or TypeOf vlobjControl Is MyButton) And UCase(vgstrNombreUsuario) = "ADMINISTRADOR" Then vlobjControl.Enabled = True
        Next
        Exit Sub
    End If
    '------------------------------------------------
    '««  Recorre los controles que tiene la forma  »»
    '------------------------------------------------
    For Each vlobjControl In frmObj.Controls
        vlblnSePuedeHabilitar = True
        
        '------------------------------------------------
        '««  Evalúa si el control tiene un manejador,  »»
        '««  si no tiene, el control no será evaluado  »»
        '------------------------------------------------
        'On Error Resume Next
        '    vllngManejador = IsWindowEnabled(vlobjControl.hwnd)
        'If Err.Number <> 0 Then
        '    vlblnSePuedeHabilitar = False
        'End If
        'Err.Clear
        '[  Si el control se podrá habilitar/deshabilitar  ]
        'If vlblnSePuedeHabilitar Then
            '--------------------------------------------------------------------------------
            '««  Deshabilita el control (Los controles estarán deshabilitados por defecto  »»
            '--------------------------------------------------------------------------------
            '[  Si es un control SSTab  ]
            If TypeOf vlobjControl Is SSTab Then
                'Se quito la variable del contador (vlintContador) de la siguiente linea ya que estaba tronando cuando una forma tiene varios tabs
                vlobjControl.TabEnabled(aControlesModulo(0).vlIntOrdenTab) = True
            Else '[  Si es cualquier otro control  ]
                '[  Si es un ControlArray  ]
                If IsArray(vlobjControl) Then
                    'Se quito la variable del contador (vlintContador) de la siguiente linea ya que estaba tronando cuando una forma tiene varios array´s
                    vlobjControl(aControlesModulo(0).vlIntOrdenTab).Enabled = False
                Else
                    '[  Dado que los frames tienen manejador y no deberán ser habilitados/deshabilitados  ]
                    '[  antes de deshabilitarlo, se evalúa que el control no sea un frame                 ]
                    If TypeOf vlobjControl Is Frame And TypeOf vlobjControl Is MyFrame Then vlobjControl.Enabled = False
                End If
            End If
            '--If (TypeOf vlobjControl Is CommandButton Or TypeOf vlobjControl Is MyButton) And UCase(vgstrNombreUsuario) <> "ADMINISTRADOR" Then vlobjControl.Enabled = False
            '--If (TypeOf vlobjControl Is CommandButton Or TypeOf vlobjControl Is MyButton) And UCase(vgstrNombreUsuario) = "ADMINISTRADOR" Then vlobjControl.Enabled = True
            '--------------------------------------------------------------
            '««  Recorre el arreglo que tiene los permisos, para buscar  »»
            '««  los permisos que tiene el login sobre el control        »»
            '--------------------------------------------------------------
            For vlintcontador = 1 To aControlesModulo(1).vlintTotalRegistros
                '[ ~~~~~~~~~~~~~~~~~~~~~  Si encuentra el control en el arreglo de permisos ~~~~~~~~~~~~~~~~~~~~~~]
                '|  « SI » el nombre del control = nombre del objeto en el arreglo que se está evaluando « Y »    |
                '|  el nombre de la forma = nombre de la forma en el arreglo « O » el nombre de la forma = "Null  |
                If UCase(aControlesModulo(vlintcontador).vlstrObjeto) = UCase(vlobjControl.Name) And _
                   (aControlesModulo(vlintcontador).vlstrForma = "Null" Or _
                   UCase(frmObj.Name) = UCase(aControlesModulo(vlintcontador).vlstrForma)) Then
                    '[  Si es un control SSTab  ]
                    If TypeOf vlobjControl Is SSTab Then
                        '-------------------------------------------------------------------------------------------------------------
                        '««  Si es el mismo nombre del componente y el mismo nombre de la forma deshabilita el tab correspondiente  »»
                        '-------------------------------------------------------------------------------------------------------------
                        If aControlesModulo(vlintcontador).vlstrObjeto = vlobjControl.Name And vlobjControl.Parent.Name = aControlesModulo(vlintcontador).vlstrForma Then
                           If (aControlesModulo(vlintcontador).vlstrTipoPermiso = "S" Or aControlesModulo(vlintcontador).vlstrTipoPermiso = "") And UCase(vgstrNombreUsuario) <> "ADMINISTRADOR" Then
                              vlobjControl.TabEnabled(aControlesModulo(vlintcontador).vlIntOrdenTab) = False
                           Else
                              vlobjControl.TabEnabled(aControlesModulo(vlintcontador).vlIntOrdenTab) = True
                           End If
                        End If
                    Else '[  Si es cualquier otro control  ]
                        '[  Si es un ControlArray  ]
                        If IsArray(vlobjControl) Then
                            If aControlesModulo(vlintcontador).vlstrTipoPermiso = "S" And UCase(vgstrNombreUsuario) <> "ADMINISTRADOR" Then
                               vlobjControl(aControlesModulo(vlintcontador).vlIntOrdenTab).Enabled = False
                            Else
                               vlobjControl(aControlesModulo(vlintcontador).vlIntOrdenTab).Enabled = True
                            End If
                        Else
                            If aControlesModulo(vlintcontador).vlstrTipoPermiso = "S" And UCase(vgstrNombreUsuario) <> "ADMINISTRADOR" Then
                                vlobjControl.Enabled = False
                            Else
                                vlobjControl.Enabled = True
                            End If
                        End If
                    End If
                    'Exit For
                End If
            Next vlintcontador
        'End If
   Next
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnHabilitaObjetos"))
End Sub

Public Function fdtmServerFechaHora() As Date
'Procedimiento para tomar la fecha del servidor
'Para utilizar esta funcion debe tener el objeto comando cmdServerFecha enlazado a un store procedure
'que se llama sp_GnServerFecha
    On Error GoTo NotificaError
    Dim rsGnServerFecha As New ADODB.Recordset
    
    Set rsGnServerFecha = frsEjecuta_SP("", "SP_gnServerFecha")
    fdtmServerFechaHora = CDate(rsGnServerFecha.Fields(0))
    rsGnServerFecha.Close
    
Exit Function
NotificaError:
  Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fdtmServerFechaHora"))
End Function

Public Function fstrParseo(pstrCadena As String) As String
    
    fstrParseo = Replace(pstrCadena, "'", IIf(vgstrBaseDatosUtilizada = "ORACLE", "' || chr(39) || '", "' + char(39) + '"))

End Function

Public Sub fblnCargaPermisos()
   On Error GoTo NotificaError
   'Funcion que permite llenar el arreglo de la seguridad
   'agarrando lo que traiga de seguridad en las tablas de opcion y permiso
   'Autor: Marco Ronquillo
   'Fecha de creacion: 10-09-2003
   'Fecha de ultima modificacion:
   Dim rsObjeto As New ADODB.Recordset
   Dim vlstrsql  As String
   Dim vlintx As Integer
            
   vlstrsql = "SELECT distinct vchNombreObjeto,IsNull(chrPermiso, 'S') AS Permiso, intOrdenObjeto, vchNombreForma" & _
   " From Opcion" & _
   " LEFT OUTER JOIN Permiso ON (Opcion.intNumeroOpcion = Permiso.intNumeroOpcion and intNumeroLogin = " & vglngNumeroLogin & ")" & _
   " WHERE  smiNumeroModulo = " & vgintNumeroModulo
   
   Set rsObjeto = frsRegresaRs(vlstrsql)
   If rsObjeto.RecordCount <> 0 Then
      ReDim aControlesModulo(rsObjeto.RecordCount)
      vlintx = 1
      
      Do While Not (rsObjeto.EOF)
      
         aControlesModulo(vlintx).vlstrObjeto = IIf(IsNull(rsObjeto!vchNombreObjeto), "", rsObjeto!vchNombreObjeto)
         aControlesModulo(vlintx).vlintTotalRegistros = rsObjeto.RecordCount
         
         If IsNull(rsObjeto!vchNombreForma) Or rsObjeto!vchNombreForma = "" Then
            aControlesModulo(vlintx).vlstrForma = "Null"
         Else
            aControlesModulo(vlintx).vlstrForma = rsObjeto!vchNombreForma
         End If
            
         aControlesModulo(vlintx).vlstrTipoPermiso = rsObjeto!Permiso
            
         If IsNull(rsObjeto!intordenobjeto) Then
            aControlesModulo(vlintx).vlIntOrdenTab = 0
         Else
            aControlesModulo(vlintx).vlIntOrdenTab = rsObjeto!intordenobjeto
         End If
         
         vlintx = vlintx + 1
         rsObjeto.MoveNext

      Loop
   Else
      ReDim aControlesModulo(1)
   End If

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnCargaPermisos"))
End Sub

Public Function fblnCargoExcluidoContinuar(lngnumCuenta As Long, strTipoPaciente As String, lngCveCargo As Long, strTipoCargo As String, Optional ByRef blnMuestraAut As Boolean = False, Optional strDescripcionCargo As String = "") As Boolean
'Función para determinar si un cargo es excluido, o sea que no lo cubre la empresa del paciente
'lngNumCuenta       = Número de cuenta
'strTipoPaciente    = Tipo de paciente, I = interno, E = externo
'lngCveCargo        = Clave del artículo, estudio, examen, grupo de examen, otro concepto de cargo
'strTipoCargo       = AR = articulo, IM = estudio, EX = examen, GE = grupo examen, OC = otro concepto de cargo
    On Error GoTo NotificaError

    Dim lngCargoExcluido As Long

    vgstrParametrosSP = CStr(lngnumCuenta) & "|" & Trim(strTipoPaciente) & "|" & CStr(lngCveCargo) & "|" & Trim(strTipoCargo)
    
    lngCargoExcluido = 1
    frsEjecuta_SP vgstrParametrosSP, "SP_PVINTCARGOEXCLUIDO", True, lngCargoExcluido
    
    If lngCargoExcluido > 0 Then
        'El cargo es excluido, continúa con el proceso según responda el usuario:
        fblnCargoExcluidoContinuar = MsgBox(IIf(strDescripcionCargo <> "", strDescripcionCargo & vbCrLf, "") & SIHOMsg(894), vbQuestion + vbYesNo, "Mensaje") = vbYes
    Else
        If lngCargoExcluido = 0 Then
            'No es excluido:
            fblnCargoExcluidoContinuar = True
        Else
            'Es excluido pero requiere autorización
            blnMuestraAut = True
            fblnCargoExcluidoContinuar = True
        End If
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnCargoExcluidoContinuar"))
End Function

Public Function fstrConexionCrystal() As String
  ' Función que Extrae las propiedades de la conexión activa
  ' En formato para Conexión de Crystal Report
  Dim vlStrConexion As String
  
  fstrConexionCrystal = ""
  With EntornoSIHO.ConeccionSIHO.Properties
    .Refresh
    vlStrConexion = ""
    vlStrConexion = "DSN = " & .Item("Data Source")
    vlStrConexion = vlStrConexion & ";UID = " & .Item("User ID")
    vlStrConexion = vlStrConexion & ";PWD = " & .Item("Password")
    vlStrConexion = vlStrConexion & ";DSQ = " & .Item("Initial Catalog")
  End With
  fstrConexionCrystal = vlStrConexion
End Function

Public Function fblnCanFocus(objeto As Object) As Boolean
  On Error GoTo GoError
  If objeto.Visible And objeto.Enabled Then
    fblnCanFocus = True
  Else
    fblnCanFocus = False
  End If
Exit Function
GoError:
  fblnCanFocus = False
End Function

Public Function flngObtenOpcion(vlstrObjeto As String, Optional vlstrForma As String = "") As Long
  On Error GoTo NotificaError
  
  Dim rs As New ADODB.Recordset
  Dim vlstrx As String
  
  flngObtenOpcion = 0
  If Trim(vlstrObjeto) = "" Then Exit Function
  vlstrx = ""
  vlstrx = vlstrx & "SELECT INTNUMEROOPCION FROM OPCION WHERE "
  vlstrx = vlstrx & "  SMINUMEROMODULO=" & vgintNumeroModulo
  vlstrx = vlstrx & "  AND RTRIM(UPPER(VCHNOMBREOBJETO))='" & Trim(UCase(vlstrObjeto)) & "' "
  If Trim(vlstrForma) <> "" Then
    vlstrx = vlstrx & "  AND RTRIM(UPPER(VCHNOMBREFORMA))='" & Trim(UCase(vlstrForma)) & "' "
  End If
  vlstrx = vlstrx & " ORDER BY INTNUMEROOPCION "
  Set rs = frsRegresaRs(vlstrx)
  If rs.State <> adStateClosed Then
    If rs.RecordCount > 0 Then
      rs.MoveFirst
      flngObtenOpcion = IIf(IsNull(rs!intNumeroOpcion), 0, rs!intNumeroOpcion)
    End If
    rs.Close
  End If
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngObtenOpcion"))
End Function

Public Sub pBorrarRenglon(pMSHFGrid As Control, pintRenglon As Integer)
    Dim vlintRenglon As Integer
    Dim vlintColumna As Integer
    
    If pintRenglon < pMSHFGrid.Rows - 1 Then
        For vlintRenglon = pintRenglon To pMSHFGrid.Rows - 2
            For vlintColumna = 0 To pMSHFGrid.Cols - 1
                pMSHFGrid.TextMatrix(vlintRenglon, vlintColumna) = pMSHFGrid.TextMatrix(vlintRenglon + 1, vlintColumna)
            Next vlintColumna
            pMSHFGrid.RowData(vlintRenglon) = pMSHFGrid.RowData(vlintRenglon + 1)
        Next vlintRenglon
    End If
    If pMSHFGrid.Rows = 2 Then 'Limpiar el renglón
        For vlintColumna = 0 To pMSHFGrid.Cols - 1
            pMSHFGrid.TextMatrix(pintRenglon, vlintColumna) = ""
        Next vlintColumna
        pMSHFGrid.RowData(pintRenglon) = -1
    Else
        pMSHFGrid.Rows = pMSHFGrid.Rows - 1
    End If

End Sub

Public Sub pImprimirCheque(vllngxNumeroFormato As Long, vParDeFolio As Long, vParAFolio As Long)
'---------------------------------------------------------------------------------------
' Imprimir un varios folios con un formato en las coordenadas dadas por el usuario
' El formato para este procedimiento debe de tener un total de lineas mayor a Cero (intTotalLineas)
' Orginial de pimprimeformato : Ultima Modificación: 08/FEB/2006
'---------------------------------------------------------------------------------------

    On Error GoTo NotificaError
    Dim rsContenidoFormato As New ADODB.Recordset
    Dim rsResultadoSelect As New ADODB.Recordset
    Dim vlstrSubcadena As String        'para mandar imprimir
    Dim vlstrPorImprimir As String      'para mandar imprimir
    Dim vlintContDetalles As Integer    'para mandar imprimir
    Dim vlintContSdoDetalle As Integer  'para mandar imprimir
    Dim vlintRenglonInicio As Integer   'para mandar imprimir
    Dim vlintColSubCad As Integer
    Dim vlintAnchoFormato As Integer
    Dim vlintTotalLineas As Integer
    Dim lngColumna As Long
    Dim lngRenglon As Long
    Dim vlIntCont As Long
    Dim vlintcont2 As Integer
    Dim vlintReng As Integer
    Dim vlintSiguiente  As Long
    Dim vlintHCadena As Integer     'Total de lineas por todos los folios a imprimir
    Dim vlstrCadenas As String
    Dim vlintTotCad As Integer
    Dim lhPrinter As Long
    Dim lpcWritten As Long
    Dim sWrittenData As String
    Dim strFontName As String
    Dim lngFontSize As Long
    Dim vlblnIncluyeCopia As Boolean

1    ReDim aCadenas(0)

2    Set rsContenidoFormato = frsEjecuta_SP(str(vllngxNumeroFormato), "SP_PVSELFORMATO")

3    If rsContenidoFormato.RecordCount <> 0 Then

4        strFontName = Trim(rsContenidoFormato!vchFont)
5        lngFontSize = rsContenidoFormato!INTLETRA

6        vlintAnchoFormato = rsContenidoFormato!intAncho
7        vlintTotalLineas = rsContenidoFormato!intLargo
8        vlintSiguiente = 1

9        vlblnIncluyeCopia = False

10        For vlIntCont = vParDeFolio To vParAFolio
            ' Prepara impresora
11            vlintReng = IIf(vlintSiguiente = 1, 0, (vlintSiguiente - 1) * vlintTotalLineas)
12            vlintHCadena = vlintTotalLineas * vlintSiguiente
13            vlintSiguiente = vlintSiguiente + 1

14            rsContenidoFormato.MoveFirst
15            Do While Not rsContenidoFormato.EOF
            
16                If vlblnIncluyeCopia = False Then
17                    If InStr(rsContenidoFormato!VCHDESCRIPCION, "(copia)") > 0 Then
18                        If IIf(IsNull(rsContenidoFormato!intCoordenadaY), 0, rsContenidoFormato!intCoordenadaY) > 0 And IIf(IsNull(rsContenidoFormato!intCoordenadaX), 0, rsContenidoFormato!intCoordenadaX) > 0 Then
19                            vlblnIncluyeCopia = True
20                        End If
21                    End If
22                End If
            
23                vlintRenglonInicio = lngColumna
24                If rsContenidoFormato!chrEstatusContenido = "D" Then
                    
25                    Set rsResultadoSelect = frsRegresaRs(fstrArmaInstruccion(rsContenidoFormato!vchSentencia, str(vlIntCont)) & " " + rsContenidoFormato!vchOrderby, adLockOptimistic, adOpenDynamic)

26                    If rsResultadoSelect.RecordCount <> 0 Then

27                        lngRenglon = rsContenidoFormato!intCoordenadaX
                        
28                        If rsContenidoFormato!bitRenglonSiguiente = 0 Then lngColumna = rsContenidoFormato!intCoordenadaY
                        
29                        rsResultadoSelect.MoveFirst
30                        vlintContDetalles = 0
31                        Do While Not rsResultadoSelect.EOF

32                            If Not IsNull(rsResultadoSelect.Fields(0).Value) Then
                            ' Da formato a texto de acuerdo a configuracion
33                                vlstrPorImprimir = ""
34                                Select Case Trim(rsContenidoFormato!vchFuncionFormato)
                                Case ""
36                                    vlstrPorImprimir = UCase(rsResultadoSelect.Fields(0))
37                                Case "Format"
38                                    vlstrPorImprimir = UCase(Format(rsResultadoSelect.Fields(0), rsContenidoFormato!vchFormato))
39                                Case "fstrNumeroenLetras"
40                                    vlstrPorImprimir = UCase(fstrNumeroenLetras(CDbl(rsResultadoSelect.Fields(0)), rsResultadoSelect.Fields(1), rsResultadoSelect.Fields(2)))
41                                Case "fstrNumeroJustificado"
42                                    vlstrPorImprimir = fstrNumeroJustificado(CDbl(rsResultadoSelect.Fields(0)), 14)
43                                Case "fstrNumeroJustificado/Espacio"
44                                    If rsResultadoSelect.Fields(0) = 0 Then
45                                    Else
46                                        vlstrPorImprimir = fstrNumeroJustificado(CDbl(rsResultadoSelect.Fields(0)), 14)
47                                    End If
48                                Case "fstrNumeroJustificadoFormato"
49                                    vlstrPorImprimir = fstrNumeroJustificadoFormato(IIf(IsNull(CDbl(rsResultadoSelect.Fields(0))), 0, CDbl(rsResultadoSelect.Fields(0))), Trim(rsContenidoFormato!vchFormato))
50                                End Select

51                                If Not IsNull(rsContenidoFormato!intAnchoContenido) Then
52                                    If Int(rsContenidoFormato!intAnchoContenido) > 0 And rsContenidoFormato!intAnchoContenido < Len(Trim(vlstrPorImprimir)) Then
53                                        vlstrPorImprimir = Mid(vlstrPorImprimir, 1, rsContenidoFormato!intAnchoContenido)
54                                    End If
55                                End If
                                'Verifica si espacio a la derecha es suficiente para cadena si no va dividir esta cadena en subcadenas
56                                vlintColSubCad = 1
57                                If vlintAnchoFormato > 0 Then
58                                    vlstrSubcadena = Mid(Trim(vlstrPorImprimir), vlintColSubCad, (vlintAnchoFormato - lngRenglon))
59                                Else
60                                    vlstrSubcadena = Trim(vlstrPorImprimir)
61                                End If

62                                vlintContSdoDetalle = 0
63                                Do While vlstrSubcadena <> ""
64                                    vlintTotCad = vlintTotCad + 1
65                                    ReDim Preserve aCadenas(vlintTotCad)
66                                    aCadenas(vlintTotCad).Columna = lngRenglon
67                                    aCadenas(vlintTotCad).renglon = lngColumna + vlintReng
68                                    aCadenas(vlintTotCad).Cadena = vlstrSubcadena
69                                    lngColumna = lngColumna + 1
70                                    vlintColSubCad = vlintColSubCad + (vlintAnchoFormato - lngRenglon)
71                                    If vlintAnchoFormato > 0 Then
72                                        vlstrSubcadena = Mid(Trim(vlstrPorImprimir), vlintColSubCad, (vlintAnchoFormato - lngRenglon))
73                                    Else
74                                        vlstrSubcadena = ""
75                                    End If
76                                Loop
                                'Prepara informacion para la siguiente informacion
77                                vlintContDetalles = vlintContDetalles + 1
78                                If rsContenidoFormato!bitRenglonSiguiente = 0 Then
79                                    lngColumna = rsContenidoFormato!intCoordenadaY + vlintContDetalles
80                                End If
81                            End If
82                            rsResultadoSelect.MoveNext
83                        Loop
84                    End If
85                Else
86                    vlintTotCad = vlintTotCad + 1
87                    ReDim Preserve aCadenas(vlintTotCad)
88                    aCadenas(vlintTotCad).Columna = rsContenidoFormato!intCoordenadaX
89                    aCadenas(vlintTotCad).renglon = IIf(rsContenidoFormato!bitRenglonSiguiente = 0, Printer.CurrentY = rsContenidoFormato!intCoordenadaY + vlintReng, lngColumna + 1 + vlintReng)
90                    aCadenas(vlintTotCad).Cadena = rsContenidoFormato!vchSentencia
91                End If
                'Regresar el registro donde empezo
92                If rsContenidoFormato!bitMantenerRenglon = 1 Then lngColumna = vlintRenglonInicio
93                rsContenidoFormato.MoveNext
94            Loop
95        Next vlIntCont
96    End If

97    If vlintHCadena > 0 Then

'98        Printer.Orientation = 1
'99        If vlblnIncluyeCopia Then
'100            Printer.PaperSize = 5
'101        End If
        
102        Printer.ScaleMode = vbCharacters
103       Printer.Font.Name = strFontName
104        Printer.Font.Size = lngFontSize
        
'        If vlblnIncluyeCopia Then
'            Printer.PaperSize = vbPRPSFolio
'        End If

105        For vlIntCont = 1 To vlintHCadena
106            vlstrCadenas = ""
107            For vlintcont2 = 1 To vlintTotCad
                'arma cadenas
108                If aCadenas(vlintcont2).renglon = vlIntCont Then
109                    If Len(vlstrCadenas) < aCadenas(vlintcont2).Columna Then
110                        vlstrCadenas = vlstrCadenas & Space(aCadenas(vlintcont2).Columna - Len(vlstrCadenas))
111                    End If
112                    vlstrCadenas = vlstrCadenas + aCadenas(vlintcont2).Cadena
113                End If
114            Next vlintcont2
115            If vlstrCadenas = "" Then vlstrCadenas = " "
116            sWrittenData = vlstrCadenas
            
            On Error Resume Next
117          Printer.Print sWrittenData

            If Err.Number <> 0 Then
            'EntornoSiho.ConeccionSiho.RollbackTrans
             Exit Sub
            End If

118        Next vlIntCont

119        Printer.EndDoc
120    End If
                
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pImprimirCheque" & " Linea:" & Erl()))
End Sub

Public Sub pGeneraCuentaPorPagar(mnyMonto As Currency, lngCveMedico As Long, lngnumCuenta As Long, ByRef vllngConsecCuentaPagarMedico As Long, ByRef vlintTipoMoneda As Integer, lngConsecutivo As Long, lngmontohonorario As Currency, lngretencion As Currency, lngcomision As Currency, lngivacomision As Currency, lngRetencionRTP As Currency)
    On Error GoTo NotificaError
    Dim vlstrsql As String
    Dim rsTemp As New ADODB.Recordset
    
    'ºGraba un registro en la tabla de cuentas por pagar al medico
    vlstrsql = "SELECT * FROM CpCuentaPagarMedico WHERE intnumcuentaPagar = -1"
    Set rsTemp = frsRegresaRs(vlstrsql, adLockOptimistic, adOpenDynamic)
    With rsTemp
        .AddNew
        !intCveMedico = lngCveMedico
        !intNumCuentaMedico = lngnumCuenta
        !dtmfecha = fdtmServerFechaHora
        !MNYCantidad = CCur(Format(mnyMonto, "############.00"))
        !bitestatusmoneda = vlintTipoMoneda
        !mnytipocambio = fdblTipoCambio(fdtmServerFecha, "V")
        !intConsecutivo = CCur(Format(lngConsecutivo, "############.00"))
        !mnymontohonorario = CCur(Format(lngmontohonorario, "############.00"))
        !mnyretencion = CCur(Format(lngretencion, "############.00"))
        !mnycomision = CCur(Format(lngcomision, "############.00"))
        !mnyivacomision = CCur(Format(lngivacomision, "############.00"))
        !mnyretencionRTP = CCur(Format(lngRetencionRTP, "############.00"))
        .Update
    End With
    
    vllngConsecCuentaPagarMedico = flngObtieneIdentity("sec_cpcuentapagarmedico", rsTemp!intnumcuentapagar)
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pGeneraCuentaPorPagar"))
End Sub

Public Function fstrTipoFamiliaSubFamilia(vlstrCveArticulo As String, vlintTipoFamSub As Integer) As String
' Función que obtiene el tipo, familia, subfamilia dependiendo de lo que se requiera
'  0: Tipo, Familia, Subfamilia
'  1: Sólo Tipo
'  2: Sólo Familia
'  3: Sólo SubFamilia
' -1: Tipo y Familia
' -2: Tipo y SubFamilia
' -3: Familia y SubFamilia
  Dim rsArticulo As New ADODB.Recordset
  
  fstrTipoFamiliaSubFamilia = ""
  Set rsArticulo = frsRegresaRs("SELECT CHRCVEARTMEDICAMEN, CHRCVEFAMILIA, CHRCVESUBFAMILIA FROM ivArticulo WHERE chrCveArticulo='" & vlstrCveArticulo & "' ")
  If rsArticulo.State <> adStateClosed Then
    If rsArticulo.RecordCount > 0 Then
      If vlintTipoFamSub = 0 Then fstrTipoFamiliaSubFamilia = rsArticulo!chrcveartmedicamen & rsArticulo!chrCveFamilia & rsArticulo!chrCveSubFamilia
      If vlintTipoFamSub = 1 Then fstrTipoFamiliaSubFamilia = rsArticulo!chrcveartmedicamen
      If vlintTipoFamSub = 2 Then fstrTipoFamiliaSubFamilia = rsArticulo!chrCveFamilia
      If vlintTipoFamSub = 3 Then fstrTipoFamiliaSubFamilia = rsArticulo!chrCveSubFamilia
      If vlintTipoFamSub = -1 Then fstrTipoFamiliaSubFamilia = rsArticulo!chrcveartmedicamen & rsArticulo!chrCveFamilia
      If vlintTipoFamSub = -2 Then fstrTipoFamiliaSubFamilia = rsArticulo!chrcveartmedicamen & rsArticulo!chrCveSubFamilia
      If vlintTipoFamSub = -3 Then fstrTipoFamiliaSubFamilia = rsArticulo!chrCveFamilia & rsArticulo!chrCveSubFamilia
    End If
    rsArticulo.Close
  End If
  Exit Function
End Function

Public Sub pLlenaVsfGrid(ByVal vsfObj As VSFlexGrid, ByRef rs As Recordset, Optional ByVal L_Cargadatos As Boolean = True, Optional ByVal LRegnuevo As Boolean = True, Optional ByVal LTablaNueva As Boolean = True)
  'Procedimiento que llena un vsflexgrid en forma dinamico de un recordset
  'Te llena el encabezado y el cuerpo del grid
  'Encabezado
  Dim lni  As Integer, vlintSeqFil As Integer, vlintSeqCol As Integer
  Dim c_cadena  As String
  If LTablaNueva Then
      vsfObj.Clear
      vsfObj.Cols = rs.Fields.Count
      vsfObj.Rows = 1
      For lni = 1 To rs.Fields.Count - 1
          vsfObj.TextMatrix(0, lni) = rs.Fields(lni).Name
          vsfObj.ColComboList(lni) = ""
          If rs.Fields(lni).Type = adCurrency Or rs.Fields(lni).Type = 10 Or rs.Fields(lni).Type = 3 Then
              vsfObj.ColWidth(lni) = rs.Fields(lni).DefinedSize * vsfObj.FontSize * 18
              vsfObj.ColDataType(lni) = flexDTCurrency
          ElseIf rs.Fields(lni).Type = adDate Or rs.Fields(lni).Type = 135 Then
              vsfObj.ColWidth(lni) = rs.Fields(lni).DefinedSize * vsfObj.FontSize * 7
              vsfObj.ColDataType(lni) = flexDTDate
          Else
              vsfObj.ColWidth(lni) = rs.Fields(lni).DefinedSize * vsfObj.FontSize * 9 + 250
              vsfObj.ColDataType(lni) = rs.Fields(lni).Type
          End If
      Next
  End If
  vsfObj.Col = 0
  'Detalle
    If L_Cargadatos Then
        Do While Not rs.EOF
            c_cadena = ""
            For lni = 0 To rs.Fields.Count - 1
                If rs.Fields(lni).Type = adBoolean Then
                    c_cadena = c_cadena & IIf(rs.Fields(lni).Value, 1, 0) & vbTab
                ElseIf rs.Fields(lni).Type = adCurrency Or rs.Fields(lni).Type = 10 Then
                    c_cadena = c_cadena & Format(rs.Fields(lni).Value, "##,###,##0.00") & vbTab
                Else
                    c_cadena = c_cadena & rs.Fields(lni).Value & vbTab
                End If
            Next
            c_cadena = Left(c_cadena, Len(c_cadena) - 1)
            vsfObj.AddItem c_cadena
            rs.MoveNext
        Loop
    End If
End Sub

Public Function fbCboLlenaDepartamento(ByVal Cbo As ComboBox) As Boolean
   On Error GoTo NotificaError
   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   
   vlstrsql = "SELECT smiCveDepartamento, vchDescripcion descrip " & _
      "From NoDepartamento " & _
      "Where(bitEstatus = 1) " & _
      "ORDER BY vchDescripcion"
      
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs Cbo, rs, 0, 1
      fbCboLlenaDepartamento = True
   Else
      fbCboLlenaDepartamento = False
   End If
   rs.Close
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fbCboLlenaDepartamento"))
End Function

Public Function fEspStr(vlstrExpresion As String, vlLong As Integer, Optional Caracter As String) As String
    On Error GoTo NotificaError
    
    vlstrExpresion = Trim(vlstrExpresion)
    If Len(vlstrExpresion) < vlLong Then
        Do While Len(vlstrExpresion) <= vlLong - 1
            vlstrExpresion = vlstrExpresion + IIf(Caracter <> "", Caracter, Space(1))
        Loop
    Else
        vlstrExpresion = Mid(vlstrExpresion, 1, vlLong)
    End If
    fEspStr = vlstrExpresion
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fEspStr"))
End Function

Public Function fRegresaDiasMes(fecha As Date) As Integer
   Dim fechastr As String
   fechastr = (CDate("01/" & CStr(Month(fecha) + 1) & "/" & CStr(Year(fecha)))) - CDate("01/" & CStr(Month(fecha)) & "/" & CStr(Year(fecha)))
   fRegresaDiasMes = Val(fechastr)
End Function



Public Sub pCargaParametrosContabilidad(vlintNumeroEmpresa As Integer)
    On Error GoTo NotificaError
    '------------------------------------------------------------------------------
    ' Cargar en las variables globales del módulo los datos de una empresa contable
    '------------------------------------------------------------------------------
    Dim rsDatosEmpresa As New ADODB.Recordset
    Dim rsDatosParametros As New ADODB.Recordset
    Dim vlstrx As String
    
    vlstrx = "select * from CnEmpresaContable where tnyClaveEmpresa=" & str(vlintNumeroEmpresa)
    Set rsDatosEmpresa = frsRegresaRs(vlstrx)
    If rsDatosEmpresa.RecordCount <> 0 Then
        vgstrNombreEmpresaContable = Trim(rsDatosEmpresa!vchNombre)
        vgstrNombreCortoEmpresaContable = Trim(rsDatosEmpresa!vchNombreCorto)
        vgstrRepresentanteLegalEmpresaContable = Trim(rsDatosEmpresa!vchRepresentanteLegal)
        vgstrRFCEmpresaContable = Trim(rsDatosEmpresa!vchRFC)
        vgstrDireccionEmpresaContable = Trim(rsDatosEmpresa!vchCalle) ' Cambio el campo de VCHDIRECCION a VCHCALLE
        vgstrTelefonoEmpresaContable = Trim(rsDatosEmpresa!vchTelefono)
    End If
    
    Set rsDatosParametros = frsSelParametros("CN", vlintNumeroEmpresa)
    If Not rsDatosParametros.EOF Then
        Do Until rsDatosParametros.EOF
            Select Case rsDatosParametros!Nombre
                
                Case "VCHESTRUCTURACUENTACONTABLE"
                     If Not IsNull(rsDatosParametros!Valor) Then
                     vgstrEstructuraCuentaContable = Trim(rsDatosParametros!Valor)
                     End If
                Case "INTNUMCUENTARESULTADOEJERCICIO"
                     If Not IsNull(rsDatosParametros!Valor) Then
                     vglngCuentaResultadoEjercicio = rsDatosParametros!Valor
                     End If
                Case "SMIEJERCICIOINICIOOPERACIONES"
                     If Not IsNull(rsDatosParametros!Valor) Then
                     vgintEjercicioInicioOperaciones = rsDatosParametros!Valor
                     End If
                Case "TNYMESINICIOOPERACIONES"
                     If Not IsNull(rsDatosParametros!Valor) Then
                     vgintMesInicioOperaciones = rsDatosParametros!Valor
                     End If
            End Select
            rsDatosParametros.MoveNext
        Loop
    Else
        vgstrEstructuraCuentaContable = ""
        vglngCuentaResultadoEjercicio = 0
        vgintEjercicioInicioOperaciones = 0
        vgintMesInicioOperaciones = 0
    End If
    rsDatosParametros.Close
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pCargaParametrosContabilidad"))
End Sub


            
          
Public Function flngSiguiente(vlstrCampo As String, vlstrTabla As String) As Long
'Regresa el siguiente consecutivo de la tabla
    Dim vlstrSentencia As String
    Dim rsSiguienteNumero As New ADODB.Recordset

    vlstrSentencia = "SELECT ISNULL(MAX(" & vlstrCampo & "),0)+1 FROM " & vlstrTabla & ""
    Set rsSiguienteNumero = frsRegresaRs(vlstrSentencia)

    flngSiguiente = rsSiguienteNumero.Fields(0)
    
    'Cierra y libera el recordset
        If rsSiguienteNumero.State = 1 Then
                rsSiguienteNumero.Close
            Set rsSiguienteNumero = Nothing
        End If
        
End Function

Public Function fblnLlenaCiudadesCbo(cboObj As ComboBox) As Boolean
   'Llena combos de ciudades
   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   vlstrsql = "SELECT intCveCiudad, vchDescripcion From Ciudad Where (bitActiva = 1)"
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs cboObj, rs, 0, 1
      fblnLlenaCiudadesCbo = True
   Else
      fblnLlenaCiudadesCbo = False
   End If
   rs.Close
End Function

Public Function fblnLlenaAntiCuaguloCbo(cboObj As ComboBox) As Boolean
   'Llena combos de Ocupaciones
   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   vlstrsql = "SELECT intClave Clave, vchDescripcion Descripcion FROM BsAntiCoagulante where (bitStatus  = 1)"
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs cboObj, rs, 0, 1
      fblnLlenaAntiCuaguloCbo = True
   Else
      fblnLlenaAntiCuaguloCbo = False
   End If
   rs.Close
End Function

Public Function flngSigNumRs(ObjRS As Recordset, vlintNumPkey As Integer) As Long
'-----------------------------------------------------------------------------------------------
' Función que busca el último registro del recordset y le agrega uno (para efectos de visualizar
' en pantalla el siguiente consecutivo
'-----------------------------------------------------------------------------------------------
On Error GoTo NotificaError
    Dim vlstrNombreCampo, vlstrCampo As String
    Dim ObjOraRs As New ADODB.Recordset
    Dim vlstrSentencia As String
    
    vlstrNombreCampo = ObjRS.Fields(vlintNumPkey).Name
    vlstrCampo = vlstrNombreCampo & " Asc"
    If ObjRS.RecordCount > 0 Then
        ObjRS.Sort = vlstrCampo
        ObjRS.MoveLast
        flngSigNumRs = ObjRS.Fields(vlintNumPkey) + 1
    Else
        flngSigNumRs = 1
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngSigNumRs"))
End Function

Public Sub pDesSel(ObjGrd As MSHFlexGrid, tecla As Integer)
    On Error GoTo NotificaError
    Dim vglngCol As Long                    'Almacena la columna actual del Grid
    Dim vglngRow As Long                    'Almacena el renglón actual del Grid
    
    With ObjGrd
        If vgblnFlagGrd = False Then
            If tecla = 38 Or tecla = 40 Then
                If .Row > 1 And Not (.Row = .Rows - 1) Then vgblnFlagGrd = True
            End If
        End If
        If vgblnFlagGrd Then
            If .Redraw Then .Redraw = False
            vglngCol = .Col
            vglngRow = .Row
            pDesSelMshFGrid ObjGrd
            pSelFilaMshFGrid ObjGrd, CInt(vglngRow)
            .Col = vglngCol
            .Row = vglngRow
            If Not .Redraw Then .Redraw = True
        End If
        
        If tecla = 38 Then
            If .Row = 1 Then
                vgblnFlagGrd = False
            Else
                vgblnFlagGrd = True
            End If
        ElseIf tecla = 40 Then
            If .Row = .Rows - 1 Then
                vgblnFlagGrd = False
            Else
                vgblnFlagGrd = True
            End If
        End If
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pDesSel"))
End Sub

Public Sub pLocalizaGrid(ObjGrid As MSHFlexGrid, Caracter As Integer, Ordena As Boolean)
'Se localiza automaticamente el registro que se busca de acuerdo a la columna
    On Error GoTo NotificaError
    Dim vlintRows As Integer     'Variable para recorrer los renglones del grid
    Dim vlstrTexto As String     'Almacena el texto a buscar
    
    With ObjGrid
        If .Rows > 0 Then
            .Redraw = False
            .FocusRect = flexFocusNone
            If (Caracter >= 48 And Caracter <= 57) Or (Caracter >= 65 And Caracter <= 90) Or (Caracter >= 97 And Caracter <= 122) Then 'Si se teclean números o caracteres alfabeticos
                If Ordena Then .Sort = 1    'Se ordena la columna en donde se esta buscando
                vgstrAcumTextoBusqueda = vgstrAcumTextoBusqueda & Chr(Caracter)  'Se almacena la busqueda
                Call pLocalizaTxtMshFGrid(ObjGrid, vgstrAcumTextoBusqueda, .Col)
            ElseIf (Caracter = 8) Then
                If Len(vgstrAcumTextoBusqueda) > 0 Then
                    vgstrAcumTextoBusqueda = Left(vgstrAcumTextoBusqueda, (Len(vgstrAcumTextoBusqueda) - 1))
                    If Len(vgstrAcumTextoBusqueda) > 0 Then
                        Call pLocalizaTxtMshFGrid(ObjGrid, vgstrAcumTextoBusqueda, .Col)
                    Else
                        Call pDesSelMshFGrid(ObjGrid)
                    End If
                Else
                    Call pDesSelMshFGrid(ObjGrid)
                End If
            End If
            .FocusRect = flexFocusHeavy
            .Redraw = True
        End If
    End With

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLocalizaGrid" & " " & ObjGrid.Name))
End Sub

Public Function fValidaCancela(grid As MSHFlexGrid) As Boolean
'Funcion que valida si se han seleccionado ordenes para ser canceladas
    Dim contador As Integer
    
    On Error GoTo NotificaError
    
    fValidaCancela = False
    With grid
        For contador = 0 To .Rows - 1
            If .TextMatrix(contador, 0) = "*" Then
                fValidaCancela = True
                Exit For
            End If
        Next contador
    End With

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fValidaCancela" & " " & grid.Name))
End Function

Public Function fstrRFC( _
vlstrPaterno As String, _
vlstrMaterno As String, _
vlstrNombre As String, _
vlstrFechaNacimiento As String) As String
    
    On Error GoTo NotificaError
    
    Dim vlCaracter As Byte
    
    fstrRFC = ""
    If Len(vlstrPaterno) > 0 Then
        fstrRFC = Left(vlstrPaterno, 1)
        For vlCaracter = 2 To Len(vlstrPaterno)
            If UCase(Mid(vlstrPaterno, vlCaracter, 1)) = "A" Then
                fstrRFC = fstrRFC & UCase(Mid(vlstrPaterno, vlCaracter, 1))
                Exit For
            End If
        
            If UCase(Mid(vlstrPaterno, vlCaracter, 1)) = "E" Then
                fstrRFC = fstrRFC & UCase(Mid(vlstrPaterno, vlCaracter, 1))
                Exit For
            End If
        
            If UCase(Mid(vlstrPaterno, vlCaracter, 1)) = "I" Then
                fstrRFC = fstrRFC & UCase(Mid(vlstrPaterno, vlCaracter, 1))
                Exit For
            End If
        
            If UCase(Mid(vlstrPaterno, vlCaracter, 1)) = "O" Then
                fstrRFC = fstrRFC & UCase(Mid(vlstrPaterno, vlCaracter, 1))
                Exit For
            End If
        
            If UCase(Mid(vlstrPaterno, vlCaracter, 1)) = "U" Then
                fstrRFC = fstrRFC & UCase(Mid(vlstrPaterno, vlCaracter, 1))
                Exit For
            End If
        Next
    End If
    If Len(vlstrMaterno) > 0 Then
        fstrRFC = fstrRFC & Left(vlstrMaterno, 1)
    End If
    If Len(vlstrNombre) > 0 Then
        fstrRFC = fstrRFC & Left(vlstrNombre, 1)
    End If
    If Len(vlstrFechaNacimiento) > 0 Then
        fstrRFC = fstrRFC & Format(vlstrFechaNacimiento, "yymmdd")
    End If
    
Exit Function
NotificaError:
     Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrRFC"))
End Function

Public Function fstrSigNumeroChar3(ObjRS As Recordset, vlintNumCampo As Integer) As String
'-------------------------------------------------------------------------------------------
' Función que busca el último registro del recordset y le agrega uno (para efectos de visualizar
' en pantalla el siguiente consecutivo
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlstrCampo As String
    Dim vlintCampoCve As Long
    Dim vlintUltimoCampo As Integer
    Dim vlstrNombreCampo As String
    
    vlintUltimoCampo = ObjRS.RecordCount
    vlintUltimoCampo = vlintUltimoCampo + 1
        
    vlstrNombreCampo = ObjRS.Fields(vlintNumCampo).Name
    vlstrCampo = vlstrNombreCampo & " Asc"
    If ObjRS.RecordCount > 0 Then
        ObjRS.Sort = vlstrCampo
        ObjRS.MoveLast
        vlintUltimoCampo = CLng(ObjRS.Fields(vlintNumCampo).Value)
        vlintUltimoCampo = vlintUltimoCampo + 1
        '**********************************************************
        If vlintUltimoCampo <= 9 Then
            fstrSigNumeroChar3 = "00" & CStr(vlintUltimoCampo) 'OJO,Checar el .Value ver por que no jala familias, por que necesita agregar uno más en vez de un uno
        Else
            If vlintUltimoCampo >= 10 And vlintUltimoCampo < 100 Then
                fstrSigNumeroChar3 = "0" & CStr(vlintUltimoCampo)
            End If
            If vlintUltimoCampo >= 100 Then
                fstrSigNumeroChar3 = CStr(vlintUltimoCampo)
            End If
        End If
        '**************************************************
    Else
        fstrSigNumeroChar3 = "001"
    End If
    
NotificaError:
    If vgblnExistioError Then
        Exit Function
    Else
        If Err.Number <> 0 Then
            Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrSigNumeroChar3"))
            On Error GoTo 0
            vgblnExistioError = True
            Exit Function
        End If
    End If

End Function

Public Function fblnComponenteCbo(cboObj As ComboBox, Optional vlintNumOpcion As Integer) As Boolean
   'Llena combos de Ocupaciones
   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   vlstrsql = "SELECT intCveHemoComponente, vchNombre From BsHemocomponente WHERE (bitEstatus = 1)"
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs cboObj, rs, 0, 1, vlintNumOpcion
      fblnComponenteCbo = True
      cboObj.ListIndex = 0
   Else
      fblnComponenteCbo = False
   End If
   rs.Close
End Function

Public Function fblnTipoSangreCbo(cboObj As ComboBox, Optional vlintNumOpcion As Integer) As Boolean
   'Llena combos de Ocupaciones
   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   vlstrsql = "SELECT intCveTipoSanguineo, chrGrupo ||' '|| CASE WHEN bitPositivo = 1 THEN '+' ELSE '-' END  Grupo FROM BsTipoSanguineo"
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs cboObj, rs, 0, 1, vlintNumOpcion
      fblnTipoSangreCbo = True
      cboObj.ListIndex = 0
   Else
      fblnTipoSangreCbo = False
   End If
   rs.Close
End Function

Public Function fstrSacaEdad(dFechaNac As Date) As String
'Procedimiento para obtener la Edad del paciente
    On Error GoTo NotificaError

    Dim vllngEdad As Double
    Dim vlstrFecha As String
    
    vlstrFecha = fstrVerificaFecha(fstrFormatTxt(dFechaNac, "F", "", 10, False))
    If Len(vlstrFecha) > 0 Then
        vllngEdad = CDbl(fstrFormatTxt(fstrCalculoFecha(fdtmServerFecha, CDate(dFechaNac), "D", True, False), "N", ">", 10, False))
        If vllngEdad <= 6 Then
            fstrSacaEdad = fstrCalculoFecha(fdtmServerFecha, CDate(dFechaNac), "D", True, False)
        End If
        If ((vllngEdad > 6) And (vllngEdad <= 31)) Then
            fstrSacaEdad = fstrCalculoFecha(fdtmServerFecha, CDate(dFechaNac), "S", True, False)
        End If
        If ((vllngEdad > 30) And (vllngEdad < 360)) Then
            fstrSacaEdad = fstrCalculoFecha(fdtmServerFecha, CDate(dFechaNac), "M", True, False)
        End If
        If (vllngEdad >= 360) Then
            fstrSacaEdad = fstrCalculoFecha(fdtmServerFecha, CDate(dFechaNac), "A", True, False)
        End If
    Else
        fstrSacaEdad = ""
    End If
    Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrSacaEdad"))
End Function

Public Function fblnFolioUnidades(vblnMuestraMensajeUltimos As Boolean, vintNumFoliosAvisar As Integer) As Boolean
  Dim vlstrsql As String
  Dim rs As New ADODB.Recordset
  fblnFolioUnidades = True
  vlstrsql = "SELECT  intFolioFinal - intFolioActual resta FROM BsFolios where BITACTIVA = 1 and " & fstrFechaSQL(fdtmServerFecha) & " between DTMFECHAINICIAL and DTMFECHAFINAL"
  Set rs = frsRegresaRs(vlstrsql)
  If rs.RecordCount > 0 Then
    If rs!Resta = 0 Then
      MsgBox "No existen folios nuevos.", vbInformation, "Mensaje"
      fblnFolioUnidades = False
    Else
      If vblnMuestraMensajeUltimos And vintNumFoliosAvisar <= rs!Resta Then
        MsgBox "Faltan " & rs!Resta & " para que los folios se terminen."
      End If
    End If
  Else
    MsgBox "Debe de registrar los folios.", vbInformation, "Mensaje"
    fblnFolioUnidades = False
  End If
  rs.Close
End Function

Public Function fblnLlenaEscolaridadCbo(cboObj As ComboBox) As Boolean
   'Llena combos de Escolaridades
   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   vlstrsql = "SELECT intClave Clave, vchDescripcion Descripcion From Escolaridad where (bitStatus  = 1)"
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs cboObj, rs, 0, 1
      fblnLlenaEscolaridadCbo = True
      cboObj.ListIndex = 0
   Else
      fblnLlenaEscolaridadCbo = False
   End If
   rs.Close
End Function

Public Function fblnLlenaEdoCivilCbo(cboObj As ComboBox) As Boolean
   'Llena combos de Estados civiles
   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   vlstrsql = "SELECT intCveEstadoCivil Clave, vchDescripcion Descripcion FROM siEstadoCivil "
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs cboObj, rs, 0, 1
      fblnLlenaEdoCivilCbo = True
      cboObj.ListIndex = 0
   Else
      fblnLlenaEdoCivilCbo = False
   End If
   rs.Close
End Function

Public Function fblnLlenaOcupacionCbo(cboObj As ComboBox) As Boolean
   'Llena combos de Ocupaciones
   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   vlstrsql = "SELECT intClave Clave, vchDescripcion Descripcion FROM Ocupacion where (bitStatus  = 1)"
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs cboObj, rs, 0, 1
      fblnLlenaOcupacionCbo = True
      cboObj.ListIndex = 0
   Else
      fblnLlenaOcupacionCbo = False
   End If
   rs.Close
End Function

Public Function fblnReligionCbo(ByVal cboObj As ComboBox, Optional vlintNumOpcion As Integer) As Boolean

   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   vlstrsql = "select intClave,vchDescripcion from AdReligion where bitStatus=1"
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs cboObj, rs, 0, 1, vlintNumOpcion
      fblnReligionCbo = True
      cboObj.ListIndex = 0
   Else
      fblnReligionCbo = False
   End If
   rs.Close
End Function

Public Function fblnParentescoCbo(ByVal cboObj As ComboBox, Optional vlintNumOpcion As Integer) As Boolean
   'Llena combos de tipo bolsa
   Dim vlstrsql As String
   Dim rs As New ADODB.Recordset
   vlstrsql = "SELECT intCveParentesco, vchDescripcion From SiParentesco "
   Set rs = frsRegresaRs(vlstrsql, adLockReadOnly, adOpenForwardOnly)
   If rs.RecordCount > 0 Then
      pLlenarCboRs cboObj, rs, 0, 1, vlintNumOpcion
      fblnParentescoCbo = True
      cboObj.ListIndex = 0
   Else
      fblnParentescoCbo = False
   End If
   rs.Close
End Function

Public Sub pLlenaVsfGridHorizontal(ByVal vsfObj As VSFlexGrid, ByRef rs As Recordset)
  Dim intRow As Integer
  Dim c_cadena  As String, strCategoria As String
  Dim blnBand As Boolean
  
  With vsfObj
    .Clear
    .FixedRows = 0
    .Cols = 2
    .Rows = 0
    .Col = 0
    .ColWidth(0) = 0
    blnBand = False
    If rs.RecordCount > 0 Then
      Do While Not blnBand 'Recorrer el resultado del query
        c_cadena = ""
        c_cadena = rs.Fields(0).Value & vbTab & rs.Fields(1).Value
        .AddItem c_cadena
        .Row = vsfObj.Row + 1
        .RowHeight(vsfObj.Row) = 400
        .Select vsfObj.Row, 0, vsfObj.Row, 1
        .CellBackColor = &HC0C0C0
        .CellFontBold = True
        .CellAlignment = flexAlignCenterCenter
        .CellFontSize = 10
        .CellBorder &HE0E0E0, 1, 1, 1, 1, 1, 1
    
        strCategoria = rs.Fields(1).Value
        Do While strCategoria = rs.Fields(1).Value
          c_cadena = ""
          c_cadena = rs.Fields(2).Value & vbTab & rs.Fields(3).Value
          vsfObj.AddItem c_cadena
          vsfObj.Row = vsfObj.Row + 1
          vsfObj.Select vsfObj.Row, 0, vsfObj.Row, 1
          vsfObj.CellBackColor = &HE0E0E0
          c_cadena = "" & vbTab & rs.Fields(4).Value
          .AddItem c_cadena
          .Row = vsfObj.Row + 1
          rs.MoveNext
          
          If rs.EOF Then
            blnBand = True
            Exit Do
          End If
        Loop
      Loop
    End If
  End With
End Sub

Public Sub pValidaNumeroTexbox(vlintValor As Integer)
'Procedimiento que solo permite ingresar números
On Error GoTo NotificaError

    Select Case vlintValor
        Case Asc(vbCr)
            vlintValor = 0
        Case 8
        Case 46
        Case 48 To 57
        Case Else
            vlintValor = 0
End Select

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pValidaNumeroTexbox"))
End Sub

Public Function fCerosClave(vlstrClave As String) As String
    'función que agrega los ceros faltantes a la clave del articulo que se selecciono

    If Len(vlstrClave) < 10 Then
        Do While Len(vlstrClave) < 10
            vlstrClave = "0" & vlstrClave
        Loop
    End If
    fCerosClave = vlstrClave
    
End Function

Public Function fBuscaClave(vlintConsecutivo As Long) As String
    Dim vlstrsql As String
    Dim rsTemp As New ADODB.Recordset
    
    vlstrsql = "Select chrCveArticulo from IvArticulo where intidArticulo = " & vlintConsecutivo
    Set rsTemp = frsRegresaRs(vlstrsql, adLockOptimistic, adOpenDynamic)
    If rsTemp.RecordCount > 0 Then
        fBuscaClave = rsTemp!chrcvearticulo
    Else
        fBuscaClave = ""
    End If
    rsTemp.Close
    
End Function

Public Function frsRegresaRsOtraCon(Optional vlstrSentencia As String, Optional vlintTipoBloq As ADODB.LockTypeEnum, Optional vlintTipoCursor As ADODB.CursorTypeEnum, Optional vlintRowNum As Integer) As ADODB.Recordset
'Funcion para ejecutar una sentencia Select y obtener un recordset
'On Error GoTo NotificaError

    'Declaración de variables locales
    Dim rs As New ADODB.Recordset
    Dim vlIntCont As Integer
    Dim vlblnBand As Boolean
    Dim vlstrResultado As String
    Dim vlintInicio As Integer
    Dim vlstrconeccion As String        'String de coneccion temporal
    Dim cnTemporal As New ADODB.Connection
    
    'Rutina que reemplaza el double pipe (||) por el signo de mas (+)
    'en caso de que se este trabajando en una base de datos MSSQL
    If vgstrBaseDatosUtilizada = "MSSQL" Then
        vlstrResultado = ""
        vlintInicio = 1
        For vlIntCont = 1 To Len(vlstrSentencia) + 1
            If Not (vlblnBand) Then
                If (Mid(vlstrSentencia, vlIntCont, 1) = "|") Then vlblnBand = True
            Else
                If (Mid(vlstrSentencia, vlIntCont, 1) = "|") Then
                    vlstrResultado = vlstrResultado & Mid(vlstrSentencia, vlintInicio, (vlIntCont - vlintInicio - 1)) & "+"
                    vlintInicio = vlIntCont + 1
                    vlblnBand = False
                End If
            End If
            If Len(vlstrSentencia) = vlIntCont Then vlstrResultado = vlstrResultado & Mid(vlstrSentencia, vlintInicio, (vlIntCont - vlintInicio + 1))
        Next vlIntCont
        vlstrSentencia = vlstrResultado
    End If
    
    vgstrNombreProcedimiento = "frsRegresaRs"
        
    rs.MaxRecords = vlintRowNum
    
    If vlintTipoBloq = 0 Then
        vlintTipoBloq = adLockReadOnly
    End If
    If Len(vlstrSentencia) > 0 Then
        rs.LockType = vlintTipoBloq
        rs.CursorType = vlintTipoCursor
        If vgstrBaseDatosUtilizada = "MSSQL" Then
            With EntornoSIHO.ConeccionSIHO.Properties
                vlstrconeccion = "Provider=MSDataShape.1;"
                vlstrconeccion = vlstrconeccion & "Data Provider=" & "SQLOLEDB.1" & ";"
                vlstrconeccion = vlstrconeccion & "Persist Security Info=False;"
                vlstrconeccion = vlstrconeccion & "Data Source=" & .Item("Data Source") & ";"
                vlstrconeccion = vlstrconeccion & "Integrated security=SSPI;"
                vlstrconeccion = vlstrconeccion & "Initial Catalog=" & .Item("Initial Catalog")
            End With
            Set cnTemporal = CreateObject("ADODB.Connection")
            cnTemporal.ConnectionString = vlstrconeccion
            cnTemporal.Open
            Set rs.ActiveConnection = cnTemporal
        Else
            If EntornoSIHO.ConeccionSIHO.State = 0 Then
                EntornoSIHO.ConeccionSIHO.Open
            End If
            Set rs.ActiveConnection = EntornoSIHO.ConeccionSIHO
        End If
        
        rs.Source = vlstrSentencia
        rs.Open
        Set frsRegresaRsOtraCon = rs
    End If

Exit Function

NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":frsRegresaRsOtraCon"))
End Function

Public Sub pLiberaCorte(intCorte As Long)
    On Error GoTo NotificaError
    Dim vlstrSentencia As String
    
    vlstrSentencia = "Update PvEstatusCorte set vchEstatus='Libre' where intCorte=" + str(intCorte)
    pEjecutaSentencia vlstrSentencia

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLiberaCorte"))
End Sub

Public Function fstrFechaParametroCrystal(Texto As String) As String
'-------------------------------------------------------------------------------------
' Regresa un string tipo fecha que acepta SQL
' Modif: 26/04/02 se agrego lo del apostrofe
' Modif: 21/11/03 Formato de Fecha dependiendo de la conexión
' Modif: 13/01/04 A la función fstrfechaSQL se le agrego para que separe con comas  año, mes, dia
'-------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlstrTemp As String
    Dim X As Integer
    
    If vgstrBaseDatosUtilizada = "ORACLE" Then
        fstrFechaParametroCrystal = fstrFechaParametroCrystal & Format(Int(CDate(Texto)), "YYYY-MM-DD")
    Else
        fstrFechaParametroCrystal = fstrFechaParametroCrystal & Format(Int(CDate(Texto)), "YYYY/MM/DD")
    End If
        
    If vgstrBaseDatosUtilizada = "ORACLE" Then
        vlstrTemp = ""
        For X = 1 To Len(fstrFechaParametroCrystal)
            If Mid(fstrFechaParametroCrystal, X, 1) = "-" Then
                vlstrTemp = vlstrTemp + ","
            Else
                vlstrTemp = vlstrTemp + Mid(fstrFechaParametroCrystal, X, 1)
            End If
        Next
    Else
        vlstrTemp = ""
        For X = 1 To Len(fstrFechaParametroCrystal)
            If Mid(fstrFechaParametroCrystal, X, 1) = "/" Then
                vlstrTemp = vlstrTemp + ","
            Else
                vlstrTemp = vlstrTemp + Mid(fstrFechaParametroCrystal, X, 1)
            End If
        Next
    End If
       
    fstrFechaParametroCrystal = vlstrTemp
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrFechaParametroCrystal"))

End Function

Public Sub pLlenaCombo(Sentence As String, Combo As ComboBox, Optional Indice As Long)
'Procedimioento que llena combos de acuerdo a una instrucción
    On Error GoTo NotificaError
    Dim vlintx As Integer
    Dim rsTemp As New ADODB.Recordset
    
    Combo.Clear     'Se limpia el combo
    
    Set rsTemp = frsRegresaRs(Sentence, adLockReadOnly, adOpenForwardOnly)
    With rsTemp
        If .RecordCount > 0 Then
            Combo.Visible = False
            Do While Not .EOF
                Combo.AddItem !Nombre, Combo.ListCount
                Combo.ItemData(Combo.newIndex) = !Cve
                .MoveNext
            Loop
            Combo.Visible = True
            vlintx = fintLocalizaCbo(Combo, CStr(Indice))
            Combo.ListIndex = IIf(vlintx = -1, 0, vlintx)
        End If
        .Close
    End With

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLlenaCombo"))
End Sub

Public Sub pCargaEncabezado(forma As Form, vlintDiagnoIngreso As Integer)
'01/01/2002
'Procedimiento que carga los datos generales del paciente en el encabezado general
    Dim vlstrsql As String
    Dim rsDiagnosticos As New ADODB.Recordset
    Dim vlblnValidaEdad As Boolean  'Valida si al hoja necesita forzosamente la edad para su funcionamiento
   ' Dim vlintDiagnoIngreso As Integer
    
    With forma
        .txtNumCuenta = vglngNumeroCuenta
        .txtNumExpe = vglngNumeroPaciente
        .txtCuarto = vgstrNumeroCuarto
        .txtNombrePaciente = vgstrNombrePaciente
        .txtTipoPaciente = vgstrTipoPacienteAdm + IIf(vgstrTipoConvenioPac = "", "", "-" + vgstrTipoConvenioPac)
        If Len(vgstrNombreEmpresa) = 0 Then
            .txtEmpresa = .txtTipoPaciente.Text
        Else
            .txtEmpresa = vgstrNombreEmpresa
        End If
        
        .txtEdad = IIf(Len(vgstrEdad) = 0, "0 AÑOS", vgstrEdad)
        .txtArea = vgstrNomArea
        .txtAfiliacion = vgstrNumeroAfiliacion
        If Day(vgdtmFechaNacimiento) & "/" & Month(vgdtmFechaNacimiento) & "/" & Year(vgdtmFechaNacimiento) = "30/12/1899" Then
            .mskFechaNacimiento = "01/01/1900"
        Else
            .mskFechaNacimiento = vgdtmFechaNacimiento
        End If
              
        pMkTextAsignaValor .txtFechaIngreso, CStr(vgdtmFechaIngreso)

        vgstrParametrosSP = str(vglngNumeroCuenta) & "|" & vgstrTipoPaciente & "|" & str(vlintDiagnoIngreso)
        Set rsDiagnosticos = frsEjecuta_SP(vgstrParametrosSP, "Sp_Exseldiagnoactualpaciente")
        
        .cboDiagnostico.Clear
        If rsDiagnosticos.RecordCount > 0 Then
          vgstrDiagnosticoActual = ""
          .lstDiagnosticos.Clear
          .lstDiagnosticos.Clear
          pLlenarListRs .lstDiagnosticos, rsDiagnosticos, 0, 1
        
        Else
            .cboDiagnostico.AddItem "NO SE HAN REGISTRADO DIAGNOSTICOS", 0
        End If
        rsDiagnosticos.Close
        If vgstrSexoPaciente = "M" Then
            .optSexo(0).Value = 1
        Else
            .optSexo(1).Value = 1
        End If
    End With

End Sub

Public Function fintObtieneEdadNumero(vldtmFecha As Date, vldtmFechaComp As Date)
'Procedimiento para obtener la edad mediante una fecha
    Dim vlstrFecha As String
    Dim vllngA  As Integer
             
    vlstrFecha = fstrVerificaFecha(CStr(vldtmFecha))
    If Len(vlstrFecha) > 0 Then
        vllngA = Int(fstrCalculoFecha(vldtmFechaComp, vldtmFecha, "AN", True, True))
    Else
        vllngA = 0
    End If
    fintObtieneEdadNumero = vllngA
End Function

Public Function fValidaNull(Campo As Variant) As Variant
    'Funcion que valida los nulos dentro de un record set
    On Error GoTo NotificaError
    
    fValidaNull = ""
    If IsNull(Campo) Then
        fValidaNull = ""
    Else
        fValidaNull = Campo
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fValidaNull"))
End Function

Public Sub pMedicoCargo(ObjCbo As ComboBox, vllngNumPaciente As Long, vllngNumCuenta As Long, vlStrTipoPaciente As String, Optional Encabezado As Integer, Optional vlblnNoMostrarMensaje As Boolean)
    
    'Procedimiento que regresa en el combo los médicos asignados al paciente
    'si no los hay, asigna automáticamente el registrado en el movimiento de admisión
    'en el caso de internos o el registro de atención del paciente externo

    On Error GoTo NotificaError
    
    Dim vlstrSentencia As String
    Dim vllngCveMedico As Long
    
    Dim rsDatos As New ADODB.Recordset
    Dim rsExMedicoACargo As New Recordset

    ObjCbo.Clear
    If Encabezado = 0 Then
        ObjCbo.AddItem "<AGREGAR>", 0
    ElseIf Encabezado = 1 Then
        ObjCbo.AddItem "<SELECCIONAR>", 0
    End If
    
    '-*-*-*-*-*-*-*-*-*-*-*-
    'Verificación de la existencia de médicos asignados, asignación en su defecto
    '-*-*-*-*-*-*-*-*-*-*-*-
    
    vlstrSentencia = "select count(*) from ExMedicoaCargo where intNumPaciente = " & str(vllngNumPaciente) & " and numNumCuenta = " & str(vllngNumCuenta) & " and chrTipoPaciente = '" & vlStrTipoPaciente & "'"
    Set rsDatos = frsRegresaRs(vlstrSentencia)
    If rsDatos.Fields(0) = 0 Then
        If vlStrTipoPaciente = "I" Then
            vlstrSentencia = "select intCveMedicoCargo ClaveMedico from AdAdmision where numNumCuenta = " & str(vllngNumCuenta)
        Else
            vlstrSentencia = "select intMedico ClaveMedico from RegistroExterno where intNumCuenta = " & str(vllngNumCuenta)
        End If
        
        Set rsDatos = frsRegresaRs(vlstrSentencia)
        
        If rsDatos.RecordCount <> 0 Then
            
            vllngCveMedico = IIf(IsNull(rsDatos!ClaveMedico), 0, rsDatos!ClaveMedico)
        
            If vllngCveMedico <> 0 Then
            
                vlstrSentencia = "select * from ExMedicoACargo where numNumCuenta = -1"
                
                Set rsExMedicoACargo = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
                With rsExMedicoACargo
                    .AddNew
                    !numNumCuenta = vllngNumCuenta
                    !intnumpaciente = vllngNumPaciente
                    !CHRTIPOPACIENTE = vlStrTipoPaciente
                    !intCveMedico = vllngCveMedico
                    !dtmFechaHoraCargo = fdtmServerFecha
                    !dtmFechaHoraTermino = Null
                    !chrEstatusMedico = "A"
                    .Update
                    .Close
                End With
            End If
        End If
    End If
    
    vlstrSentencia = "Select ExMedicoACargo.intCveMedico Clave, RTrim(HoMedico.vchApellidoPaterno)||' '||RTrim(HoMedico.vchApellidoMaterno)||' '||RTrim(vchNombre) Medico " & _
                     "From ExMedicoACargo " & _
                        "Inner Join HoMedico On " & _
                        "ExMedicoACargo.intCveMedico = HoMedico.intCveMedico " & _
                     "Where " & _
                        " ExMedicoACargo.intNumPaciente = " & vllngNumPaciente & _
                        " And ExMedicoACargo.numNumCuenta = " & vllngNumCuenta & _
                        " and ExMedicoACargo.chrTipoPaciente = '" & vlStrTipoPaciente & "'" & _
                        " And ExMedicoACargo.chrEstatusMedico = 'A' " & _
                     "Order By RTrim(HoMedico.vchApellidoPaterno)||' '||RTrim(HoMedico.vchApellidoMaterno)||' '||RTrim(vchNombre)"

    Set rsDatos = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
    With rsDatos
        If .RecordCount > 0 Then
            Do While Not .EOF
                ObjCbo.AddItem !Medico, ObjCbo.ListCount
                ObjCbo.ItemData(ObjCbo.newIndex) = !clave
                .MoveNext
            Loop
            ObjCbo.ListIndex = IIf(.RecordCount > 1, 1, 0)
        ElseIf Not vlblnNoMostrarMensaje Then
            MsgBox SIHOMsg(467), vbExclamation, "Mensaje"
        End If
        .Close
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pMedicoCargo" & " " & ObjCbo.Name))
End Sub

Public Function fblnValidaHora(ObjTxt As MaskEdBox) As Boolean
'-------------------------------------------------------------------------------------------
' Verifica que la hora sea correcta
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError

       Dim vlstrHora As String
       'Asume que al revisar tendra error
       fblnValidaHora = True
       vlstrHora = CDate(ObjTxt)

NotificaError:
    If Err.Number = 13 Then
        fblnValidaHora = False
    End If
End Function

Public Sub pLlenarMshFGrdRsData(ObjGrid As MSHFlexGrid, ObjRS As Recordset)
'----------------------------------------------------------------------------------------
' Procedimiento para llenar un grid con datos de un record set y guardar el dato
' identificador del registro que sera el ultimo del recordset
'----------------------------------------------------------------------------------------
       
    Dim vlintNumCampos As Integer
    Dim vlintNumReg As Integer
    Dim vlintSeqFil As Integer
    Dim vlintSeqCol As Integer
    
    vlintNumCampos = ObjRS.Fields.Count
    If vlintNumCampos > 0 Then
        vlintNumReg = ObjRS.RecordCount
        If vlintNumReg > 0 Then
            ObjGrid.ClearStructure
            ObjGrid.Cols = vlintNumCampos + 1
            ObjGrid.Rows = vlintNumReg + 1
            ObjGrid.FixedCols = 1
            ObjGrid.FixedRows = 1
            ObjRS.MoveFirst
            
            For vlintSeqFil = 1 To vlintNumReg
                For vlintSeqCol = 1 To vlintNumCampos
                    If IsNull(ObjRS.Fields(vlintSeqCol - 1).Value) = True Then
                        ObjGrid.TextMatrix(vlintSeqFil, vlintSeqCol) = ""
                    Else
                        ObjGrid.TextMatrix(vlintSeqFil, vlintSeqCol) = ObjRS.Fields(vlintSeqCol - 1).Value
                    End If
                Next vlintSeqCol
                ObjGrid.RowData(vlintSeqFil) = ObjRS.Fields(vlintNumCampos - 1)
                ObjRS.MoveNext
            Next vlintSeqFil
        End If
    End If
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLlenarMshFGrdRsData" & " " & ObjGrid.Name))
End Sub

Public Sub pSelFilaCeroGrid(ObjGrid As MSHFlexGrid, vlintNumFila As Integer)
'-------------------------------------------------------------------------------------------
' Realiza la seleccion de una fila determinada dentro del grid iniciando desde la columna 0
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlintNumColumnas As Integer
    Dim vlintSeqC As Integer
    
    'vlintFila Almacena a que fila se dará la selección
    With ObjGrid
        vlintNumColumnas = .Cols - 1
        For vlintSeqC = 0 To vlintNumColumnas
            .Row = vlintNumFila
            .Col = vlintSeqC
            .CellBackColor = vbActiveTitleBar
            .CellForeColor = vbActiveTitleBarText
        Next vlintSeqC
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pSelFilaCeroGrid" & " " & ObjGrid.Name))
End Sub

Public Sub pDesSelCero(ObjGrd As MSHFlexGrid, tecla As Integer)
'Este procedimiento quita la selección y la marca a partir d ela columna cero

    On Error GoTo NotificaError
    Dim vglngCol As Long                    'Almacena la columna actual del Grid
    Dim vglngRow As Long                    'Almacena el renglón actual del Grid
    
    With ObjGrd
        If vgblnFlagGrd = False Then
            If tecla = 38 Or tecla = 40 Then
                If .Row > 1 And Not (.Row = .Rows - 1) Then vgblnFlagGrd = True
            End If
        End If
        If vgblnFlagGrd Then
            If .Redraw Then .Redraw = False
            vglngCol = .Col
            vglngRow = .Row
            pDesSelCeroGrid ObjGrd
            pSelFilaCeroGrid ObjGrd, CInt(vglngRow)
            .Col = vglngCol
            .Row = vglngRow
            If Not .Redraw Then .Redraw = True
        End If
        
        If tecla = 38 Then
            If .Row = 1 Then
                vgblnFlagGrd = False
            Else
                vgblnFlagGrd = True
            End If
        ElseIf tecla = 40 Then
            If .Row = .Rows - 1 Then
                vgblnFlagGrd = False
            Else
                vgblnFlagGrd = True
            End If
        End If
    End With
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pDesSelCero"))
End Sub

Public Sub pDesSelCeroGrid(ObjGrid As MSHFlexGrid)
'-------------------------------------------------------------------------------------------
' Limpia completamente las selecciones del Grid
'-------------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    Dim vlintNumFilas As Integer 'Almacena el número de filas que tiene el grid
    Dim vlintSeqC As Integer 'Contador para el número de columnas
    Dim vlintSeqF As Integer 'Contador para el número de filas
    Dim vlintNumColumnas As Integer 'Almacena el número de columnas que tiene el grid
    
    With ObjGrid
        vlintNumColumnas = .Cols - 1
        vlintNumFilas = .Rows - 1
        For vlintSeqF = 1 To vlintNumFilas
            .Row = vlintSeqF
            If .CellBackColor = vbActiveTitleBar Then
                For vlintSeqC = 0 To vlintNumColumnas
                    .Col = vlintSeqC
                    .CellBackColor = vbWindowBackground
                    .CellForeColor = vbWindowText
                Next vlintSeqC
            End If
        Next vlintSeqF
        .BackColorSel = vbWindowBackground
        .ForeColorSel = vbWindowText
        .Row = 1
    End With
    vgstrAcumTextoBusqueda = ""
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pDesSelCeroGrid" & " " & ObjGrid.Name))
End Sub

Public Function fintUrgente(vllngNumDepto As Integer) As Integer
    On Error GoTo NotificaError
    
    Dim vlstrx As String

    vlstrx = "select count(*) from PvDepartamentoPrecioEspecial where smiCveDepartamento=" & str(vllngNumDepto)
    fintUrgente = frsRegresaRs(vlstrx).Fields(0)
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintUrgente"))
End Function

Public Sub pCargaDiagnosticos(lista As ListBox, vlDesc As String)
    Dim vstrSentencia As String
    Dim rsDatos As New ADODB.Recordset
    
    lista.Clear
    
    If vlDesc <> "" Then
        vstrSentencia = "Select intCveDiagno Cve, Rtrim(vchDescripcion) Nombre " & _
                         "From ExDiagnostico " & _
                         "Where (bitActivo  = 1) And (chrSexoAplica = 'A' Or chrSexoAplica = '" & vgstrSexoPaciente & "') " & _
                         "And (vchDescripcion Like '" & vlDesc & "%') "
    
        Set rsDatos = frsRegresaRs(vstrSentencia, adLockReadOnly, adOpenForwardOnly, 20)
        With lista
            If rsDatos.RecordCount > 0 Then
                Do While Not rsDatos.EOF
                    .AddItem rsDatos!Nombre, .ListCount
                    .ItemData(.newIndex) = rsDatos!Cve
                    rsDatos.MoveNext
                Loop
            End If
        End With
    End If
    
End Sub

Public Function fblnReqSinSurtir(vlstrNumReq As String) As Boolean
    Dim vlstrx As String
    Dim rs As New ADODB.Recordset

    fblnReqSinSurtir = True
    
    vlstrx = "" & _
    "select " & _
        "vchEstatusRequis " & _
    "From " & _
        "IvRequisicionMaestro " & _
    "Where " & _
        "numNumRequisicion=" & vlstrNumReq
        
    Set rs = frsRegresaRs(vlstrx)
    
    If rs.RecordCount <> 0 Then
        If Trim(rs!vchEstatusRequis) = "SURTIDA" Then
            fblnReqSinSurtir = False
        End If
    Else
        fblnReqSinSurtir = False
    End If

End Function

Public Sub pMovimientoKardex(vlstrTablaRelacion As String, vllngNumReferencia As Long, vlstrCveArticulo As String, vllngCantidadUM As Long, vllngCantidadUV As Long, vlintDepto As Integer)
    '-----------------------------------------------------------------
    ' Procedimiento para insertar un movimiento en la tabla de IvKardexInventario
    '-----------------------------------------------------------------
    
    Dim vlstrx As String
    Dim vlcp As Double
    Dim vleum As Double
    Dim vleuv As Double
    Dim rs As ADODB.Recordset
    
    Set rs = frsRegresaRs("SELECT mnyCostoPromedio, intExistenciaDeptoUM, intExistenciaDeptoUV FROM Ivubicacion WHERE smiCveDepartamento = " & str(vlintDepto) & " AND chrCveArticulo = '" & Trim(vlstrCveArticulo) & "'", adLockOptimistic, adOpenDynamic)
    vlcp = IIf(IsNull(rs!mnycostopromedio), 0, rs!mnycostopromedio)
    vleum = IIf(IsNull(rs!intexistenciadeptoum), 0, rs!intexistenciadeptoum)
    vleuv = IIf(IsNull(rs!intExistenciaDeptouv), 0, rs!intExistenciaDeptouv)
    
 vlstrx = "INSERT INTO IvKardexInventario " & _
             "  (vchTablaRelacion," & _
             "  numNumReferencia," & _
             "  chrCveArticulo," & _
             "  dtmFechaHoraMov," & _
             "  relCantidadUM," & _
             "  relCantidadUV," & _
             "  mnyCostoPromedio," & _
             "  smiCveDepartamento," & _
             "  relExistenciaUM," & _
             "  relExistenciaUV,bitRecalculo)" & _
             " VALUES ('" & Trim(vlstrTablaRelacion) & "'," & _
             "  " & str(vllngNumReferencia) & ", " & _
             "  '" & Trim(vlstrCveArticulo) & "', " & _
             "  getdate(), " & _
             str(vllngCantidadUM) & ", " & _
             str(vllngCantidadUV) & ", " & _
             str(vlcp) & ", " & _
             str(vlintDepto) & ", " & _
             vleum & ", " & _
             vleuv & " , 0)"
   
    
    pEjecutaSentencia vlstrx

End Sub

Public Sub pCargaParameterFields(paryParametros() As String, prptReporte As CRAXDRT.Report)
    
    Dim vlCRXParamDef As CRAXDRT.ParameterFieldDefinition   'Objeto ParameterField
    Dim vlCRXParamDefs As CRAXDRT.ParameterFieldDefinitions 'Colección de ParameterField
    Dim vlIntCont As Integer
    
    Set vlCRXParamDefs = prptReporte.ParameterFields
    For Each vlCRXParamDef In vlCRXParamDefs
        For vlIntCont = 0 To UBound(paryParametros)
            If UCase(vlCRXParamDef.ParameterFieldName) = fstrObtenParametro(paryParametros(vlIntCont), 1) Then
                Select Case fstrObtenParametro(paryParametros(vlIntCont), 3)
                    Case "DATE", "DATETIME", "TIME"
                        vlCRXParamDef.SetCurrentValue CDate(fstrObtenParametro(paryParametros(vlIntCont), 2))
                    Case "BOOLEAN"
                        vlCRXParamDef.SetCurrentValue CBool(fstrObtenParametro(paryParametros(vlIntCont), 2))
                    Case "CURRENCY"
                        vlCRXParamDef.SetCurrentValue CDbl(fstrObtenParametro(paryParametros(vlIntCont), 2))
                    Case "NUMBER"
                        vlCRXParamDef.SetCurrentValue CDbl(fstrObtenParametro(paryParametros(vlIntCont), 2))
                    Case "STRING"
                        vlCRXParamDef.SetCurrentValue CStr(fstrObtenParametro(paryParametros(vlIntCont), 2))
                    Case Else
                        Select Case vlCRXParamDef.ValueType
                            Case crBooleanField
                                vlCRXParamDef.SetCurrentValue CBool(fstrObtenParametro(paryParametros(vlIntCont), 2))
                            Case 3, 4, 5, 6, 1, 2, 7
                                vlCRXParamDef.SetCurrentValue CDbl(fstrObtenParametro(paryParametros(vlIntCont), 2))
                            Case Else
                                vlCRXParamDef.SetCurrentValue CStr(fstrObtenParametro(paryParametros(vlIntCont), 2))
                        End Select
                         End Select
                Exit For
            End If
        Next
    Next
    
End Sub

'Función que obtiene el Nombre o el Valor del parámetro con formato "NombreParametro;ValorParámetro"
Private Function fstrObtenParametro(pstrValores As String, pbytData As Byte) As String
    
    Dim vlIntCont As Long            'Sirve para recorre toda la cadena de parámetros
    Dim vlstrparametro As String        'Sirve para armar el parámetro "Actual"
    Dim vlstrValor As String
    Dim vlstrTipo As String
    Dim bytSec As Byte
    fstrObtenParametro = ""
    vlstrparametro = ""
    vlstrValor = ""
    vlstrTipo = ""
    bytSec = 1
    For vlIntCont = 1 To Len(pstrValores)
        If Mid(pstrValores, vlIntCont, 1) <> ";" Then
            Select Case bytSec
                Case 1
                   vlstrparametro = vlstrparametro & Mid(pstrValores, vlIntCont, 1)
                Case 2
                   vlstrValor = vlstrValor & Mid(pstrValores, vlIntCont, 1)
                Case 3
                    vlstrTipo = vlstrTipo & Mid(pstrValores, vlIntCont, 1)
            End Select
        Else
            bytSec = bytSec + 1
        End If
    Next
    Select Case pbytData
        Case 1
            fstrObtenParametro = UCase(vlstrparametro)
        Case 2
            fstrObtenParametro = IIf(vlstrValor = "", " ", vlstrValor)
        Case 3
            fstrObtenParametro = UCase(vlstrTipo)
    End Select
    
End Function

Public Sub pImprimeReporte(prptReporte As CRAXDRT.Report, prsResultado As ADODB.Recordset, Optional pstrDestinoReporte As String = "P", Optional pstrTituloReporte As String = "", Optional pblnMuestraPrompt As Boolean = False, Optional pintNoCopias As Integer = 1, Optional strRutaCBB As String)
    Dim vlstrPrinterName As String
    
    If prptReporte.PrinterName = "" Then
        On Error Resume Next
            'vlstrPrinterName = "Imprimir en: " & Printer.DeviceName
            vlstrPrinterName = "Imprimir en: " & GetDefaultPrinter.DeviceName
        If Err.Number <> 0 Then
            MsgBox "No existe una impresora predeterminada"
            vlstrPrinterName = "No existe impresora en el sistema"
        End If
        Err.Clear
        On Error GoTo 0
    Else
        vlstrPrinterName = "Imprimir en: " & prptReporte.PrinterName
    End If
    
    If prsResultado.Source <> "" Then
        prptReporte.Database.SetDataSource prsResultado
    End If

    If strRutaCBB <> "" Then
        frmReporte.strRutaCBB = strRutaCBB '|  Carga la ruta donde se encuentra el archivo CBB
        frmReporte.pImprimeCBB prptReporte '|  Manda llamar a la función que agrega el CBB al reporte
    End If
    
    'Para que la bandeja de la impresora quede como -Seleccion automática-
    
    'prptReporte.SelectPrinter Printer.DriverName, Printer.DeviceName, Printer.port
    'prptReporte.PaperSource = Printer.PaperBin
    
    prptReporte.PaperSource = crPRBinAuto

    If pstrDestinoReporte = "P" Then
        frmReporte.Caption = pstrTituloReporte
        frmReporte.CrystalActiveXReportViewer1.ReportSource = prptReporte
        If prsResultado.State = 1 Then
            frmReporte.StatusBar1.Panels(1).Text = "Registros: " & prsResultado.RecordCount
        End If
        frmReporte.StatusBar1.Panels(2).Text = vlstrPrinterName
        frmReporte.CrystalActiveXReportViewer1.ViewReport
        frmReporte.Show vbModal
    Else
        prptReporte.PrintOutEx pblnMuestraPrompt, pintNoCopias
    End If
End Sub

Public Sub pInstanciaReporte(prptReporte As CRAXDRT.Report, pstrNombreReporte As String)
    Dim Appn As CRAXDRT.Application
    Dim Obj  As Object
    Dim Sec As CRAXDRT.Section
    Dim strRuta As String
    Dim fso As Scripting.FileSystemObject
    Dim rsRuta As New ADODB.Recordset
    Dim rptPaperOrientation, rptPaperSize, rptPaperSource
    
    Set fso = New Scripting.FileSystemObject
    Set Appn = CreateObject("CrystalRunTime.Application")
    strRuta = ""

    If fblnAutoVerificacion Then
    
        'Valida la ruta de los reportes
        Set rsRuta = frsSelParametros("SI", -1, "VCHRUTAREPORTES")
        If Not rsRuta.EOF Then
            If Trim(rsRuta!Valor) = "" Then
                MsgBox "No se realizó la impresión." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                Exit Sub
            ElseIf Not IsNull(Trim(rsRuta!Valor)) Then
                strRuta = IIf(IsNull(rsRuta("Valor")), "", rsRuta("Valor"))
            Else
                MsgBox "No se realizó la impresión." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                Exit Sub
            End If
        End If
    
        'Valida el acceso a la ruta de los reportes
        If Dir$(strRuta & "\") <> "" Then
        'La ruta SI es válida
            strRuta = strRuta & "\" & pstrNombreReporte
            
            If fso.FileExists(strRuta) = False Then
                MsgBox "No se realizó la impresión." & vbCrLf & vbCrLf & "Se esperaba el archivo: " & vbNewLine & strRuta, vbCritical, "Mensaje"
                Exit Sub
            Else
                Set prptReporte = Appn.OpenReport(strRuta)
            End If
        Else
            MsgBox "No se realizó la impresión." & vbCrLf & vbCrLf & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
            Exit Sub
        End If
            
    Else
    
        If fso.FileExists(App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & pstrNombreReporte) = False Then
            MsgBox "No se realizó la impresión." & vbCrLf & vbCrLf & "Se esperaba el archivo: " & vbNewLine & App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & pstrNombreReporte, vbCritical, "Mensaje"
            Exit Sub
        Else
            Set prptReporte = Appn.OpenReport(App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & pstrNombreReporte)
        End If
        
    End If
    
    prptReporte.ReportTitle = pstrNombreReporte
    
    For Each Sec In prptReporte.Sections
        For Each Obj In Sec.ReportObjects
            If TypeOf Obj Is CRAXDRT.FieldObject Or TypeOf Obj Is CRAXDRT.TextObject Or TypeOf Obj Is CRAXDRT.SubreportObject Then
                Obj.ConditionFormula(crToolTipTextConditionFormulaType) = "Chr(9)"
            End If
        Next
    Next
    
    If vglngTerminalServerSessionId > 0 Then
        If prptReporte.PrinterName <> Printer.DeviceName Then
            rptPaperOrientation = prptReporte.PaperOrientation
            prptReporte.SelectPrinter Printer.DriverName, Printer.DeviceName, Printer.port
            On Error Resume Next
            prptReporte.PaperOrientation = rptPaperOrientation
        End If
    End If
    
End Sub

Public Function fstrArmaInstruccion(pstrSentencia As String, pstrIdentificador As String) As String
    Dim vlIntCont As Integer
    Dim vlstrResultado As String
    Dim vlintIniciaUnion As Integer
    
    vlintIniciaUnion = 1
    vlstrResultado = ""
    For vlIntCont = 1 To Len(pstrSentencia) - 7
        If UCase(Mid(pstrSentencia, vlIntCont, 7)) = " UNION " Then
            vlstrResultado = vlstrResultado & Mid(pstrSentencia, vlintIniciaUnion, vlIntCont - vlintIniciaUnion) & " " & _
                             pstrIdentificador & " UNION "
            vlintIniciaUnion = vlIntCont + 7
        End If
        If vlIntCont = Len(pstrSentencia) - 7 Then vlstrResultado = vlstrResultado & Mid(pstrSentencia, vlintIniciaUnion, vlIntCont + 8 - vlintIniciaUnion) & " " & pstrIdentificador
        
    Next vlIntCont
    fstrArmaInstruccion = vlstrResultado
End Function

Public Function fintEsInterno(vlngLogin As Long, vlintProceso As Integer) As Integer
  'Funcion para saber por medio del login y el proceso cual fue el ultimo que tipo de paciente que utilizo
  '1 Es interno
  '2 es externo
  '0 que no tiene registro
  
  Dim SQL As String
  Dim rs As New ADODB.Recordset
  SQL = " SELECT pvTipoPacienteProceso.chrtipopaciente"
  SQL = SQL & "   FROM pvTipoPacienteProceso"
  SQL = SQL & "   where pvTipoPacienteProceso.intnumerologin = " & vlngLogin
  SQL = SQL & "   and pvTipoPacienteProceso.intproceso = " & vlintProceso
  Set rs = frsRegresaRs(SQL)
  If rs.RecordCount > 0 Then
    If rs!CHRTIPOPACIENTE = "I" Then
      fintEsInterno = 1
    Else
        If rs!CHRTIPOPACIENTE = "E" Then
            fintEsInterno = 2
        Else
            fintEsInterno = 3
        End If
    End If
  Else
    fintEsInterno = 1
  End If
  rs.Close
End Function
Public Function fIntFolioFiscal(vlngLogin As Long, vlintProceso As Integer) As Integer
'Funcion para saber si el estado en el que quedo el chkFolioFiscal
    Dim SQL As String
    Dim rs As New ADODB.Recordset

    SQL = "SELECT CCFOLIOFISCALPROCESO.INTVALOR FROM CCFOLIOFISCALPROCESO"
    SQL = SQL & " WHERE CCFOLIOFISCALPROCESO.INTNUMEROLOGIN = " & vlngLogin
    SQL = SQL & " AND CCFOLIOFISCALPROCESO.INTPROCESO = " & vlintProceso
    
    Set rs = frsRegresaRs(SQL)
    
    If rs.RecordCount > 0 Then
        If rs!INTVALOR = 1 Then
            fIntFolioFiscal = 1
        Else
            fIntFolioFiscal = 0
        End If
    Else
        fIntFolioFiscal = 0
    End If
    rs.Close
End Function

Public Function frsUltimoRecordset(ByVal vlrs As ADODB.Recordset) As ADODB.Recordset
    Do Until vlrs.State <> 0
        Set vlrs = vlrs.NextRecordset
    Loop
    Set frsUltimoRecordset = vlrs
End Function

Public Function fblnClaveManualCatalogo(strCatalogo As String) As Boolean
    On Error GoTo Errores
    
    Dim rsClaveManual As ADODB.Recordset
    Set rsClaveManual = frsRegresaRs("select bitManual from SiConsecutivosCatalogos where vchCatalogo = '" & strCatalogo & "'", adLockReadOnly, adOpenForwardOnly)
    
    If Not rsClaveManual.EOF Then
        fblnClaveManualCatalogo = IIf(rsClaveManual!bitManual = 0, False, True)
    Else
        fblnClaveManualCatalogo = False
    End If
    rsClaveManual.Close

Exit Function
Errores:
    fblnClaveManualCatalogo = False
End Function

Public Function fblnAutoVerificacion() As Boolean
    On Error GoTo Errores
    Dim rsAutoV As ADODB.Recordset
    'RESPALDO ****
    'Set rsAutoV = frsRegresaRs("select bitAutoVerificacionVersion from Parametros", adLockReadOnly, adOpenForwardOnly)
    '*************
    Set rsAutoV = frsSelParametros("SI", -1, "BITAUTOVERIFICACIONVERSION")
    If Not rsAutoV.EOF Then
        fblnAutoVerificacion = IIf(IIf(IsNull(rsAutoV("Valor")), 0, rsAutoV("Valor")) = 0, False, True)
    Else
        fblnAutoVerificacion = False
    End If
    rsAutoV.Close
    Exit Function
Errores:
    fblnAutoVerificacion = False
End Function

Public Function fstrRutaReportes(ByVal strReporte As String) As String
    On Error GoTo Errores
    Dim rsRutaR As ADODB.Recordset
    Dim strFiles As String
    Dim strRuta As String
    'RESPALDO *****
    'Set rsRutaR = frsRegresaRs("select vchRutaReportes from Parametros", adLockReadOnly, adOpenForwardOnly)
    '**************
    Set rsRutaR = frsSelParametros("SI", -1, "VCHRUTAREPORTES")
    If Not rsRutaR.EOF Then
        strRuta = IIf(IsNull(rsRutaR("Valor")), "", rsRutaR("Valor"))
        If strRuta <> "" Then
            strFiles = Dir(strRuta & "\" & strReporte, vbArchive)
            If strFiles <> "" Then
                fstrRutaReportes = strRuta & "\" & strReporte
            Else
                fstrRutaReportes = ""
            End If
        Else
            fstrRutaReportes = ""
        End If
    Else
        fstrRutaReportes = ""
    End If
    rsRutaR.Close
    Exit Function
Errores:
    fstrRutaReportes = ""
End Function

Public Sub pRealizaVerificacion(ByVal intIdModulo As Integer, ByVal blnSoloNotifica As Boolean)
    Dim fso As Scripting.FileSystemObject
    Dim f As Scripting.File
    Dim rsVersion As ADODB.Recordset
    Dim lngErr As Long
    Dim strVersion As String
    
    On Error GoTo Errores
    Set rsVersion = frsRegresaRs("select vchVersion, dtmFecha, intTamano from Modulo where smiNumeroModulo = " & intIdModulo, adLockReadOnly, adOpenForwardOnly)
    If Not rsVersion.EOF Then
        Set fso = New Scripting.FileSystemObject
        
        If fso.FileExists(App.Path & "\" & App.EXEName & ".exe") = True Then
          strVersion = fso.GetFileVersion(App.Path & "\" & App.EXEName & ".exe")
          Set f = fso.GetFile(App.Path & "\" & App.EXEName & ".exe")
          
    
          If IIf(IsNull(rsVersion!vchVersion), "", rsVersion!vchVersion) <> strVersion Then
              If blnSoloNotifica Then
                  MsgBox SIHOMsg(654), vbInformation, "Mensaje"
              Else
                  MsgBox SIHOMsg(653), vbInformation, "Mensaje"
                  Unload frmMenuPrincipal
                  End
              End If
          End If
          
        End If
        
    End If
    Exit Sub
Errores:
    lngErr = Err.Number
    If lngErr <> -2147217900 And lngErr <> 53 Then
        Err.Raise lngErr
    Else
        Err.Clear
    End If
End Sub
Public Sub pDesHabilitaCompartido(ByVal intIdModulo As Integer, ByRef frmForma As Form, Optional ByVal strCatalogo As String = "")
    Dim vlobjControl As Control
    Dim rsControl As ADODB.Recordset
    For Each vlobjControl In frmForma.Controls
        Set rsControl = frsRegresaRs("select * from SIVMCOMPONENTESCOMPARTIDOS where SMINUMEROMODULO = " & intIdModulo & " and VCHNOMBREFORMA = '" & frmForma.Name & "' and VCHNOMBRECOMPONENTE = '" & vlobjControl.Name & "'" & IIf(strCatalogo = "", "", " and VCHNOMBRECATALOGO = '" & strCatalogo & "'"), adLockReadOnly, adOpenForwardOnly)
        If Not rsControl.EOF Then
            vlobjControl.Enabled = False
            vlobjControl.Tag = "ReadOnly"
        Else
            vlobjControl.Tag = ""
        End If
        rsControl.Close
    Next
End Sub

Public Function fblnModificaHabilitadoCompartido(ByRef objControl As Control, ByVal blnData As Boolean) As Boolean
    If objControl.Tag = "ReadOnly" Then
        fblnModificaHabilitadoCompartido = False
    Else
        fblnModificaHabilitadoCompartido = blnData
    End If
End Function

'Verifica si la cuenta se encuentra bloqueada por trabajo social
Function fblnCuentaBloqueada(pstrCuenta As String, pstrTipoPaciente As String) As Boolean
    Dim vlrsCuentaBloqueada As New ADODB.Recordset
    Dim vlstrSentencia As String
    
    If pstrTipoPaciente = "I" Then
        vlstrSentencia = "Select BITCUENTABLOCKTRABSOC From adAdmision Where AdAdmision.NUMNUMCUENTA = " & pstrCuenta
    Else
        vlstrSentencia = "Select BITCUENTABLOCKTRABSOC From RegistroExterno Where RegistroExterno.INTNUMCUENTA = " & pstrCuenta
    End If

    Set vlrsCuentaBloqueada = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    fblnCuentaBloqueada = IIf(IsNull(vlrsCuentaBloqueada!BITCUENTABLOCKTRABSOC), False, vlrsCuentaBloqueada!BITCUENTABLOCKTRABSOC)
    
End Function

'###########################################################
'##  Replica la historia clínica en la ubicación central  ##
'###########################################################
Public Sub pInsertaHistoriaCentralizada(plngNumCta As Long, pstrTipoCta As String)
    Dim vlstrSentencia As String
    Dim vlrsHistoriaCentral As New ADODB.Recordset
    Dim vlrsHistoriaLocal As New ADODB.Recordset
    Dim vlrsPersona As New ADODB.Recordset
    Dim vllngCveHistoria As Long
    Dim vlstrNombrePersonaGraba As String
    Dim vlIntCont As Integer
    Dim vlstrCadenaInsercion As String
    Dim vllngCveHistoriaLocal As Long
    Dim vllngPersonaID As Long
    Dim vllngCveHistoriaCentralizada As Long
        
On Error GoTo NotificaError
    '[  Marca la historia como que ya se intentó replicar, esto es por si falla el proceso de replicación  ]
    vlstrSentencia = "                  Update ExHistoria "
    vlstrSentencia = vlstrSentencia & " Set INTCVEHISTORIACENTRALIZADA = 0"
    vlstrSentencia = vlstrSentencia & " Where ExHistoria.intNumCuenta = " & plngNumCta & " And ExHistoria.chrTipoPaciente = '" & pstrTipoCta & "' And INTCVEHISTORIACENTRALIZADA = -1"
    pEjecutaSentencia vlstrSentencia
    '---------------------------------------------------------------------------------------
    '| Obtiene la clave de la historia y el nombre de la persona que registró la historia  |
    '---------------------------------------------------------------------------------------
    vlstrSentencia = "                  Select intCveHistoria, "
    vlstrSentencia = vlstrSentencia & "     Case ExHistoria.CHRMEDICOENFERMERA"
    vlstrSentencia = vlstrSentencia & "          When 'M' Then RTRIM(HoMedico.VCHNOMBRE) || ' ' || RTRIM(HoMedico.VCHAPELLIDOPATERNO) || ' ' || RTRIM(HoMedico.VCHAPELLIDOMATERNO)"
    vlstrSentencia = vlstrSentencia & "          When 'E' Then RTRIM(NoEmpleado.VCHNOMBRE) || ' ' || RTRIM(NoEmpleado.VCHAPELLIDOPATERNO) || ' ' || RTRIM(NoEmpleado.VCHAPELLIDOMATERNO)"
    vlstrSentencia = vlstrSentencia & "     end As NombreAutorizo,"
    vlstrSentencia = vlstrSentencia & "     INTCVEHISTORIACENTRALIZADA"
    vlstrSentencia = vlstrSentencia & " From ExHistoria"
    vlstrSentencia = vlstrSentencia & "   Left Outer Join HoMedico On (ExHistoria.INTPERSONAGRABA = HoMedico.INTCVEMEDICO)"
    vlstrSentencia = vlstrSentencia & "   Left Outer Join NoEmpleado On (ExHistoria.INTPERSONAGRABA = NoEmpleado.INTCVEEMPLEADO) "
    vlstrSentencia = vlstrSentencia & " Where ExHistoria.intNumCuenta = " & plngNumCta & " And ExHistoria.chrTipoPaciente = '" & pstrTipoCta & "' And " & " INTCVEHISTORIACENTRALIZADA = 0"
    Set vlrsPersona = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    '[  Si el paciente no tiene historia, no tiene nada que replicar (See you) ]
    If vlrsPersona.RecordCount = 0 Then Exit Sub
    vlstrNombrePersonaGraba = IIf(IsNull(vlrsPersona!NombreAutorizo), "", vlrsPersona!NombreAutorizo)
    vllngCveHistoriaLocal = IIf(IsNull(vlrsPersona!intCveHistoria), -1, vlrsPersona!intCveHistoria)
    '--------------------------------------------------------------
    '|  Valida si la historia clínica ya se replicó centralmente  |
    '--------------------------------------------------------------
    If IIf(IsNull(vlrsPersona!INTCVEHISTORIACENTRALIZADA), 1, vlrsPersona!INTCVEHISTORIACENTRALIZADA) > 0 Then Exit Sub
    '--------------------------------------------------------------
    '| Obtiene la clave de la persona (intPersonaId) del paciente |
    '--------------------------------------------------------------
    If pstrTipoCta = "I" Then
        vlstrSentencia = " Select AdPaciente.INTPERSONAID "
        vlstrSentencia = vlstrSentencia & " From AdPaciente "
        vlstrSentencia = vlstrSentencia & "   Inner Join AdAdmision On (AdPaciente.NUMCVEPACIENTE = AdAdmision.NUMCVEPACIENTE) "
        vlstrSentencia = vlstrSentencia & " Where AdAdmision.NUMNUMCUENTA = " & plngNumCta
    Else
        vlstrSentencia = " Select Externo.INTPERSONAID "
        vlstrSentencia = vlstrSentencia & " From Externo "
        vlstrSentencia = vlstrSentencia & "   Inner Join RegistroExterno On (Externo.INTNUMPACIENTE = RegistroExterno.INTNUMPACIENTE) "
        vlstrSentencia = vlstrSentencia & " Where RegistroExterno.INTNUMCUENTA = " & plngNumCta
    End If
    Set vlrsPersona = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    vllngPersonaID = vlrsPersona!INTPERSONAID
    '[  Si PersonaID es cero o negativo no se debe realizar la replicación  ]
    If vllngPersonaID < 1 Then Exit Sub
    On Error GoTo SinConexion
    '[  Comprueba que exista la conexión  ]
    vlrsPersona.Close
    'RESPALDO ***
    'vlrsPersona.Open "SELECT dummy FROM Dual@" & fRegresaParametro("VCHLINKBDCENTRALIZADA", "Parametros", 0), EntornoSIHO.ConeccionSIHO, adOpenForwardOnly, adLockOptimistic
    '************
    vlrsPersona.Open "SELECT dummy FROM Dual@" & frsSelParametros("SI", -1, "VCHLINKBDCENTRALIZADA").Fields("Valor"), EntornoSIHO.ConeccionSIHO, adOpenForwardOnly, adLockOptimistic
    vlrsPersona.Close
    On Error GoTo NotificaError
    '[  Inicia transacción  ]
    EntornoSIHO.ConeccionSIHO.BeginTrans
    '---------------------------------------------------------------------------
    '| Inserción en ExVMHistoria (BD central) valores de ExHistoria (BD local) |
    '---------------------------------------------------------------------------
    'RESPALDO *****
'    Set vlrsHistoriaLocal = frsRegresaRs(" Select VCHINTERROGATORIO, DTMFECHAHORAHIS, INTCVEMEDICO, " & _
'                                         "        VCHPADECIMIENTO, VCHESTATUS, CHRMEDICOENFERMERA, VCHIDHOSPITAL  " & _
'                                         " From ExHistoria, Parametros " & _
'                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
'******************
    Set vlrsHistoriaLocal = frsRegresaRs(" Select VCHINTERROGATORIO, DTMFECHAHORAHIS, INTCVEMEDICO, " & _
                                         "        VCHPADECIMIENTO, VCHESTATUS, CHRMEDICOENFERMERA, " & _
                                         "(SELECT SIPARAMETRO.VCHVALOR FROM SIPARAMETRO WHERE SIPARAMETRO.CHRMODULO = 'SI' AND SIPARAMETRO.VCHNOMBRE = 'VCHIDHOSPITAL' ) AS VCHIDHOSPITAL " & _
                                         " From ExHistoria " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIA Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
    With vlrsHistoriaCentral
        .AddNew
        !VCHINTERROGATORIO = vlrsHistoriaLocal!VCHINTERROGATORIO
        !dtmFechaHoraHis = vlrsHistoriaLocal!dtmFechaHoraHis
        !intCveMedico = vlrsHistoriaLocal!intCveMedico
        !vchPadecimiento = vlrsHistoriaLocal!vchPadecimiento
        !VCHESTATUS = vlrsHistoriaLocal!VCHESTATUS
        !chrMedicoEnfermera = vlrsHistoriaLocal!chrMedicoEnfermera
        !INTPERSONAID = vllngPersonaID
        !vchIdHospital = vlrsHistoriaLocal!vchIdHospital
        !VCHNOMBREPERSONAGRABA = vlstrNombrePersonaGraba
        .Update
        vllngCveHistoria = flngObtieneIdentityRemoto("SEC_EXHISTORIA", !intCveHistoria)
    End With
    '-----------------------------------------------------------------------
    '|  Actualiza la historia clínica local con la clave de la HC central  |
    '-----------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs("Select INTCVEHISTORIACENTRALIZADA From ExHistoria Where INTCVEHISTORIA = " & vllngCveHistoriaLocal, adLockOptimistic, adOpenDynamic)
    vlrsHistoriaLocal!INTCVEHISTORIACENTRALIZADA = vllngCveHistoria
    vlrsHistoriaLocal.Update
    
    '------------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMHISTORIAANTECEDENTECIRU (BD central) valores de EXHISTORIAANTECEDENTECIRUGIA (BD local) |
    '------------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select INTCVEHISTORIA, INTCVECIRUGIA, DTMFECHACIRUGIA, CHROBSERVACION " & _
                                         " From EXHISTORIAANTECEDENTECIRUGIA " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIAANTECEDENTECIRU Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        While Not vlrsHistoriaLocal.EOF
            With vlrsHistoriaCentral
                .AddNew
                !intCveHistoria = vllngCveHistoria
                !intCveCirugia = vlrsHistoriaLocal!intCveCirugia
                !DTMFECHACIRUGIA = vlrsHistoriaLocal!DTMFECHACIRUGIA
                !CHROBSERVACION = vlrsHistoriaLocal!CHROBSERVACION
                .Update
            End With
            vlrsHistoriaLocal.MoveNext
        Wend
    End If
    '--------------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMHISTORIAANTECEDENTEENFE (BD central) valores de EXHISTORIAANTECEDENTEENFERMEDA (BD local) |
    '--------------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select INTCVEHISTORIA, INTCVEANTECEDENTE, CHRESTATUS, CHROBSERVACION " & _
                                         " From EXHISTORIAANTECEDENTEENFERMEDA " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIAANTECEDENTEENFE Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        While Not vlrsHistoriaLocal.EOF
            With vlrsHistoriaCentral
                .AddNew
                !intCveHistoria = vllngCveHistoria
                !INTCVEANTECEDENTE = vlrsHistoriaLocal!INTCVEANTECEDENTE
                !chrEstatus = vlrsHistoriaLocal!chrEstatus
                !CHROBSERVACION = vlrsHistoriaLocal!CHROBSERVACION
                .Update
            End With
            vlrsHistoriaLocal.MoveNext
        Wend
    End If
    '--------------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMHISTORIAANTECEDENTEOBST (BD central) valores de EXHISTORIAANTECEDENTEOBSTETRIC (BD local) |
    '--------------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select INTCVEHISTORIA, INTMENARCA, INTVSA, DTMFUM, DTMFUP, " & _
                                         "        CHRULTIMOPARTO, INTGESTA, INTPARA, INTABORTOS, INTCESAREAS, " & _
                                         "        BITEMBARAZO, DTMFPP, CHRCICLOMENSTRUAL, VCHOBSERVACIONCICLO, " & _
                                         "        INTCVEMETODO, BITMENOPAUSIA, DTMFECHAINICIOMENO, DTMFUPP " & _
                                         " From EXHISTORIAANTECEDENTEOBSTETRIC " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIAANTECEDENTEOBST Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        With vlrsHistoriaCentral
            .AddNew
            !intCveHistoria = vllngCveHistoria
            !intMenarca = vlrsHistoriaLocal!intMenarca
            !INTVSA = vlrsHistoriaLocal!INTVSA
            !dtmFUM = vlrsHistoriaLocal!dtmFUM
            !DTMFUP = vlrsHistoriaLocal!DTMFUP
            !CHRULTIMOPARTO = vlrsHistoriaLocal!CHRULTIMOPARTO
            !intGesta = vlrsHistoriaLocal!intGesta
            !INTPARA = vlrsHistoriaLocal!INTPARA
            !INTABORTOS = vlrsHistoriaLocal!INTABORTOS
            !INTCESAREAS = vlrsHistoriaLocal!INTCESAREAS
            !BITEMBARAZO = vlrsHistoriaLocal!BITEMBARAZO
            !DTMFPP = vlrsHistoriaLocal!DTMFPP
            !VCHOBSERVACIONCICLO = vlrsHistoriaLocal!VCHOBSERVACIONCICLO
            !intCvemetodo = vlrsHistoriaLocal!intCvemetodo
            !BITMENOPAUSIA = vlrsHistoriaLocal!BITMENOPAUSIA
            !DTMFECHAINICIOMENO = vlrsHistoriaLocal!DTMFECHAINICIOMENO
            !DTMFUPP = vlrsHistoriaLocal!DTMFUPP
            .Update
        End With
    End If
    '--------------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMHISTORIAANTECEDENTESUBS (BD central) valores de EXHISTORIAANTECEDENTESUBSTANCI (BD local) |
    '--------------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select INTCVEHISTORIA, INTCVESUBSTANCIA, VCHCANTIDAD, VCHUSO, DTMFECHASUSP " & _
                                         " From EXHISTORIAANTECEDENTESUBSTANCI " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIAANTECEDENTESUBS Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        While Not vlrsHistoriaLocal.EOF
            With vlrsHistoriaCentral
                .AddNew
                !intCveHistoria = vllngCveHistoria
                !INTCVESUBSTANCIA = vlrsHistoriaLocal!INTCVESUBSTANCIA
                !VCHCANTIDAD = vlrsHistoriaLocal!VCHCANTIDAD
                !VCHUSO = vlrsHistoriaLocal!VCHUSO
                !DTMFECHASUSP = vlrsHistoriaLocal!DTMFECHASUSP
                .Update
            End With
            vlrsHistoriaLocal.MoveNext
        Wend
    End If
    '--------------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMHISTORIAANTECEDENTETRAN (BD central) valores de EXHISTORIAANTECEDENTETRANSFUSI (BD local) |
    '--------------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select INTCVEHISTORIA, DTMFECHATRANS, CHRGRUPO, CHRRH, DTMFECHAREACCION " & _
                                         " From EXHISTORIAANTECEDENTETRANSFUSI " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIAANTECEDENTETRAN Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        With vlrsHistoriaCentral
            .AddNew
            !intCveHistoria = vllngCveHistoria
            !dtmFechaTrans = vlrsHistoriaLocal!dtmFechaTrans
            !chrGrupo = vlrsHistoriaLocal!chrGrupo
            !chrRH = vlrsHistoriaLocal!chrRH
            !dtmFechaReaccion = vlrsHistoriaLocal!dtmFechaReaccion
            .Update
        End With
    End If
    '--------------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMHISTORIAANTECEDENTEVACU (BD central) valores de EXHISTORIAANTECEDENTEVACUNA (BD local) |
    '--------------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select INTCVEHISTORIA, INTCVEVACUNA, CHROBSERVACION " & _
                                         " From EXHISTORIAANTECEDENTEVACUNA " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIAANTECEDENTEVACU Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        While Not vlrsHistoriaLocal.EOF
            With vlrsHistoriaCentral
                .AddNew
                !intCveHistoria = vllngCveHistoria
                !INTCVEVACUNA = vlrsHistoriaLocal!INTCVEVACUNA
                !CHROBSERVACION = vlrsHistoriaLocal!CHROBSERVACION
                .Update
            End With
            vlrsHistoriaLocal.MoveNext
        Wend
    End If
    '-------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMHISTORIAAPARATOSISTEMA (BD central) valores de EXHISTORIAAPARATOSISTEMA (BD local) |
    '-------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select INTCVEHISTORIA, INTCVEAPARATO, VCHSINTOMA " & _
                                         " From EXHISTORIAAPARATOSISTEMA " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIAAPARATOSISTEMA Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        While Not vlrsHistoriaLocal.EOF
            With vlrsHistoriaCentral
                .AddNew
                !intCveHistoria = vllngCveHistoria
                !intCveAparato = vlrsHistoriaLocal!intCveAparato
                !VCHSINTOMA = vlrsHistoriaLocal!VCHSINTOMA
                .Update
            End With
            vlrsHistoriaLocal.MoveNext
        Wend
    End If
    '----------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMHISTORIAEXPLORACIONFIS (BD central) valores de EXHISTORIAEXPLORACIONFISICA (BD local) |
    '----------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select INTCVEHISTORIA, VCHPRESION, INTPULSO, INTRESPIRACIONES, " & _
                                         "        NUMTEMPERATURA, NUMPESO, NUMTALLA, VCHCABEZACUELLO, VCHTORAX, " & _
                                         "        VCHABDOMEN, VCHGENITALES, VCHEXTREMIDADES, VCHRESULTADOS, " & _
                                         "        VCHTERAPEUTICA, VCHINSPECCIONGRAL " & _
                                         " From EXHISTORIAEXPLORACIONFISICA " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIAEXPLORACIONFIS Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        With vlrsHistoriaCentral
            .AddNew
            !intCveHistoria = vllngCveHistoria
            !VCHPRESION = vlrsHistoriaLocal!VCHPRESION
            !INTPULSO = vlrsHistoriaLocal!INTPULSO
            !INTRESPIRACIONES = vlrsHistoriaLocal!INTRESPIRACIONES
            !NUMTEMPERATURA = vlrsHistoriaLocal!NUMTEMPERATURA
            !NUMPESO = vlrsHistoriaLocal!NUMPESO
            !NUMTALLA = vlrsHistoriaLocal!NUMTALLA
            !VCHCABEZACUELLO = vlrsHistoriaLocal!VCHCABEZACUELLO
            !VCHTORAX = vlrsHistoriaLocal!VCHTORAX
            !VCHABDOMEN = vlrsHistoriaLocal!VCHABDOMEN
            !VCHGENITALES = vlrsHistoriaLocal!VCHGENITALES
            !VCHEXTREMIDADES = vlrsHistoriaLocal!VCHEXTREMIDADES
            !VCHRESULTADOS = vlrsHistoriaLocal!VCHRESULTADOS
            !VCHTERAPEUTICA = vlrsHistoriaLocal!VCHTERAPEUTICA
            !VCHINSPECCIONGRAL = vlrsHistoriaLocal!VCHINSPECCIONGRAL
            .Update
        End With
    End If
    '-------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMHISTORIANOPATOLOGICO (BD central) valores de EXHISTORIANOPATOLOGICO (BD local) |
    '-------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select INTCVEHISTORIA, INTCVEANTECEDENTE, CHROBSERVACION " & _
                                         " From EXHISTORIANOPATOLOGICO " & _
                                         " Where INTCVEHISTORIA = " & vllngCveHistoriaLocal)
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMHISTORIANOPATOLOGICO Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        While Not vlrsHistoriaLocal.EOF
            With vlrsHistoriaCentral
                .AddNew
                !intCveHistoria = vllngCveHistoria
                !INTCVEANTECEDENTE = vlrsHistoriaLocal!INTCVEANTECEDENTE
                !CHROBSERVACION = vlrsHistoriaLocal!CHROBSERVACION
                .Update
            End With
            vlrsHistoriaLocal.MoveNext
        Wend
    End If
    '-------------------------------------------------------------------------------------------------------
    '| Inserción en EXVMDIAGNOSTICOPACIENTE (BD central) valores de EXDIAGNOSTICOPACIENTE (BD local) |
    '-------------------------------------------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs(" Select EXDOCUMENTODIAGNOSTICODETALLE.INTIDDIAGNOSTICO, EXDOCUMENTODIAGNOSTICODETALLE.CHROBSERVACION " & _
                                             " FROM EXDOCUMENTODIAGNOSTICO " & _
                                             " INNER JOIN EXDOCUMENTODIAGNOSTICODETALLE on EXDOCUMENTODIAGNOSTICO.INTIDREGISTRO = EXDOCUMENTODIAGNOSTICODETALLE.INTIDREGISTRO " & _
                                             " WHERE EXDOCUMENTODIAGNOSTICO.INTNUMCUENTA = " & plngNumCta & " AND " & _
                                             "       EXDOCUMENTODIAGNOSTICO.CHRTIPOPACIENTE = '" & pstrTipoCta & "' AND " & _
                                             "       EXDOCUMENTODIAGNOSTICO.CHRTIPODOCUMENTO = 'HC' ")
        
    If vlrsHistoriaLocal.RecordCount > 0 Then
        Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXVMDIAGNOSTICOPACIENTE Where INTCVEHISTORIA = -1", adLockOptimistic, adOpenDynamic)
        While Not vlrsHistoriaLocal.EOF
            With vlrsHistoriaCentral
                .AddNew
                !intCveHistoria = vllngCveHistoria
                !intCveDiagno = vlrsHistoriaLocal!intCveDiagno
                !CHROBSERVACION = vlrsHistoriaLocal!CHROBSERVACION
                .Update
            End With
            vlrsHistoriaLocal.MoveNext
        Wend
    End If
    '--------------------------------------------------------------------
    '| Inserción en la tabla de la historia clínica compartida con PCE
    '--------------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs("Select * From ExHistoria Where intCveHistoria = " & CStr(vllngCveHistoriaLocal))
    Set vlrsHistoriaCentral = frsRegresaRs("Select * From EXHISTORIACLINICAGENERAL Where INTHISTORIAID = -1", adLockOptimistic, adOpenDynamic)
    With vlrsHistoriaCentral
        .AddNew
        !VCHFECHAHORA = vlrsHistoriaLocal!dtmFechaHoraHis
        !VCHMEDICOELABORA = vlrsHistoriaLocal!intCveMedico
        'RESPALDO *****
        '!VCHCVEGRABA = fRegresaParametro("vchIdHospital", "Parametros", 0)
        '**************
        !VCHCVEGRABA = frsSelParametros("SI", -1, "VCHIDHOSPITAL")
        !INTPERSONAID = vllngPersonaID
        vlstrCadenaInsercion = Space(25) & "PERSONALES  HEREDO FAMILIARES" & vbCrLf

        !VCHANTECEDENTESPATOLOGICOS = vlstrCadenaInsercion
        !VCHINTERROGATORIO = vlrsHistoriaLocal!VCHINTERROGATORIO
        .Update
    End With
    '--------------------------------------------------------------
    '| Actualiza el estado de la historia clínica a "REGISTRADA"  |
    '--------------------------------------------------------------
    Set vlrsHistoriaLocal = frsRegresaRs("Select VCHESTATUS From ExHistoria Where intCveHistoria = " & CStr(vllngCveHistoriaLocal), adLockOptimistic, adOpenDynamic)
    vlrsHistoriaLocal!VCHESTATUS = "REGISTRADA"
    vlrsHistoriaLocal.Update
    EntornoSIHO.ConeccionSIHO.CommitTrans
    Exit Sub
SinConexion:
    Exit Sub
NotificaError:
    EntornoSIHO.ConeccionSIHO.RollbackTrans
    Exit Sub
End Sub

'###########################################################
'##  Replica la hoja de evolución a la ubicación central  ##
'###########################################################
Public Sub pInsertaHojaEvolucion(plngNumCta As Long, pstrTipoCta As String)
    Dim vlstrSentencia As String
    Dim vlrsDatos As New ADODB.Recordset
    Dim vllngCveInternamiento As Long
    Dim vllngPersonaID As Long

On Error GoTo NotificaError
    
    '[  Marca las notas de evolución como que ya están listas para replicarse, esto es por si falla el proceso de replicación  ]
    vlstrSentencia = "                  Update ExEvolucion "
    vlstrSentencia = vlstrSentencia & " Set INTCVEINTERNAMIENTO = 0"
    vlstrSentencia = vlstrSentencia & " Where ExEvolucion.INTNUMCUENTA = " & plngNumCta & " And ExEvolucion.CHRTIPOPACIENTE = '" & pstrTipoCta & "' And INTCVEINTERNAMIENTO = -1"
    pEjecutaSentencia vlstrSentencia
    
    vlstrSentencia = "                  Select ExEvolucion.INTCVEINTERNAMIENTO"
    vlstrSentencia = vlstrSentencia & " From ExEvolucion"
    vlstrSentencia = vlstrSentencia & " Where ExEvolucion.INTNUMCUENTA = " & plngNumCta & " And ExEvolucion.CHRTIPOPACIENTE = '" & pstrTipoCta & "' And ExEvolucion.INTCVEINTERNAMIENTO = 0"
    Set vlrsDatos = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    '[  Si ya se replicó o no hay nada que replicar, see you  ]
    If vlrsDatos.RecordCount = 0 Then Exit Sub
    '--------------------------------------------------------------
    '| Obtiene la clave de la persona (intPersonaId) del paciente |
    '--------------------------------------------------------------
    If pstrTipoCta = "I" Then
        vlstrSentencia = " Select AdPaciente.INTPERSONAID "
        vlstrSentencia = vlstrSentencia & " From AdPaciente "
        vlstrSentencia = vlstrSentencia & "   Inner Join AdAdmision On (AdPaciente.NUMCVEPACIENTE = AdAdmision.NUMCVEPACIENTE) "
        vlstrSentencia = vlstrSentencia & " Where AdAdmision.NUMNUMCUENTA = " & plngNumCta
    Else
        vlstrSentencia = " Select Externo.INTPERSONAID "
        vlstrSentencia = vlstrSentencia & " From Externo "
        vlstrSentencia = vlstrSentencia & "   Inner Join RegistroExterno On (Externo.INTNUMPACIENTE = RegistroExterno.INTNUMPACIENTE) "
        vlstrSentencia = vlstrSentencia & " Where RegistroExterno.INTNUMCUENTA = " & plngNumCta
    End If
    Set vlrsDatos = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    '[  Si no se le asignado un identificador de persona único no se debe replicar  ]
    If IsNull(vlrsDatos!INTPERSONAID) Or vlrsDatos!INTPERSONAID <= 0 Then
        Exit Sub
    Else
        vllngPersonaID = vlrsDatos!INTPERSONAID
    End If
    '-------------------------------------------------------------
    '||  Inserta en la BD central los registros de la BD local  ||
    '-------------------------------------------------------------
    '[  Obtiene el número de secuencia (Clave de la historia) de la ubicación central  ]
    vlstrSentencia = "Select SEC_EXINTERNAMIENTO.NextVal@" & frsSelParametros("SI", -1, "VCHLINKBDCENTRALIZADA").Fields("Valor") & " as Id From DUAL"
    
    Set vlrsDatos = frsRegresaRs(vlstrSentencia, adOpenDynamic, adLockOptimistic)
    vllngCveInternamiento = vlrsDatos!id
    '[  Inicia transacción  ]
    EntornoSIHO.ConeccionSIHO.BeginTrans
    '[  Inserción en la BD central  ]
    vlstrSentencia = "               Insert Into ExVMEvolucion (INTCVEMEDICO, "
    vlstrSentencia = vlstrSentencia & "                         INTPERSONAID, "
    vlstrSentencia = vlstrSentencia & "                         INTCVEINTERNAMIENTO, "
    vlstrSentencia = vlstrSentencia & "                         CHRMEDICOENFERMERA, "
    vlstrSentencia = vlstrSentencia & "                         DTMFECHAHORA, "
    vlstrSentencia = vlstrSentencia & "                         VCHOBSERVACION, "
    vlstrSentencia = vlstrSentencia & "                         VCHHOSPITALID, "
    vlstrSentencia = vlstrSentencia & "                         VCHPERSONAGRABA)"
    vlstrSentencia = vlstrSentencia & " Select ExEvolucion.INTCVEMEDICO, "
    vlstrSentencia = vlstrSentencia & vllngPersonaID & ", "
    vlstrSentencia = vlstrSentencia & vllngCveInternamiento & ", "
    vlstrSentencia = vlstrSentencia & "     CHRMEDICOENFERMERA, "
    vlstrSentencia = vlstrSentencia & "     DTMFECHAHORA, "
    vlstrSentencia = vlstrSentencia & "     VCHOBSERVACION, "
    vlstrSentencia = vlstrSentencia & "'" & frsSelParametros("SI", -1, "VCHIDHOSPITAL").Fields("Valor") & "', "
    vlstrSentencia = vlstrSentencia & "     Case ExEvolucion.CHRMEDICOENFERMERA"
    vlstrSentencia = vlstrSentencia & "          When 'M' Then RTRIM(HoMedico.VCHNOMBRE) || ' ' || RTRIM(HoMedico.VCHAPELLIDOPATERNO) || ' ' || RTRIM(HoMedico.VCHAPELLIDOMATERNO)"
    vlstrSentencia = vlstrSentencia & "          When 'E' Then RTRIM(NoEmpleado.VCHNOMBRE) || ' ' || RTRIM(NoEmpleado.VCHAPELLIDOPATERNO) || ' ' || RTRIM(NoEmpleado.VCHAPELLIDOMATERNO)"
    vlstrSentencia = vlstrSentencia & "     End As NombreAutorizo "
    vlstrSentencia = vlstrSentencia & " From ExEvolucion"
    vlstrSentencia = vlstrSentencia & "   Left Outer Join HoMedico On (ExEvolucion.INTPERSONAGRABA = HoMedico.INTCVEMEDICO)"
    vlstrSentencia = vlstrSentencia & "   Left Outer Join NoEmpleado On (ExEvolucion.INTPERSONAGRABA = NoEmpleado.INTCVEEMPLEADO) "
    vlstrSentencia = vlstrSentencia & " Where ExEvolucion.INTNUMCUENTA = " & plngNumCta & " And ExEvolucion.CHRTIPOPACIENTE = '" & pstrTipoCta & "' And ExEvolucion.INTCVEINTERNAMIENTO = 0"
    pEjecutaSentencia vlstrSentencia
    '[  Actualización en la BD local  ]
    vlstrSentencia = "Update ExEvolucion Set INTCVEINTERNAMIENTO = " & vllngCveInternamiento & _
                     " Where ExEvolucion.INTNUMCUENTA = " & plngNumCta & " And ExEvolucion.CHRTIPOPACIENTE = '" & pstrTipoCta & "' "
    pEjecutaSentencia vlstrSentencia
    EntornoSIHO.ConeccionSIHO.CommitTrans
    Exit Sub
NotificaError:
    EntornoSIHO.ConeccionSIHO.RollbackTrans
    Exit Sub
End Sub

'##################################################################################
'##  Función que devuelve el valor de una secuencia en una base de datos remota  ##
'##################################################################################
Public Function flngObtieneIdentityRemoto(vlstrNombreSecuencia As String, vllngIdentity As Long) As Long
  'Declaración de variables locales
  Dim rsIdentity As New ADODB.Recordset
  Dim vlstrSentencia As String
  Dim vlrsParametro As New ADODB.Recordset
  Dim vlstrNombreEnlace As String
  Dim vlblnSinConexion As Boolean
  
  On Error GoTo Error
  flngObtieneIdentityRemoto = 0
  vlblnSinConexion = False
  If vgstrBaseDatosUtilizada = "ORACLE" Then
    Set vlrsParametro = frsRegresaRs("SELECT ISNULL(SIPARAMETRO.VCHVALOR, ' ') AS Enlace FROM SIPARAMETRO WHERE SIPARAMETRO.CHRMODULO = 'SI' AND SIPARAMETRO.VCHNOMBRE = 'VCHLINKBDCENTRALIZADA'", adLockOptimistic, adOpenForwardOnly)
    vlstrNombreEnlace = vlrsParametro!Enlace
    vlstrSentencia = "SELECT " & Trim(vlstrNombreSecuencia) & ".CURRVAL@" & vlstrNombreEnlace & " FROM DUAL"
    rsIdentity.Open vlstrSentencia, EntornoSIHO.ConeccionSIHO
    If rsIdentity.RecordCount > 0 Then
        flngObtieneIdentityRemoto = rsIdentity.Fields(0) * IIf(vlblnSinConexion, -1, 1)
    Else
        flngObtieneIdentityRemoto = -1
    End If
    rsIdentity.Close
  Else
    flngObtieneIdentityRemoto = vllngIdentity
  End If
  Exit Function
Error:
    vlblnSinConexion = True
    vlstrSentencia = "SELECT SEC_HISTORIATEMPORAL.CURRVAL FROM DUAL"
    Set rsIdentity = frsRegresaRs(vlstrSentencia)
    Resume Next
End Function

'###############################################################################
'##  "Deshace" la replicación de la historia clínica en la ubicación central  ##
'###############################################################################
Public Sub pDeshaceHistoriaCentralizada(plngNumCta As Long, pstrTipoCta As String)
    Dim vlstrSentencia As String
    Dim vlrsHistoriaCentral As New ADODB.Recordset
    Dim vllngCveHistoriaCentralizada As Long
    Dim vllngCveHistoriaLocal As Long
        
On Error GoTo NotificaError

    vlstrSentencia = " Select ExHistoria.INTCVEHISTORIACENTRALIZADA, ExHistoria.INTCVEHISTORIA "
    vlstrSentencia = vlstrSentencia & " From ExHistoria"
    vlstrSentencia = vlstrSentencia & " Where ExHistoria.intNumCuenta = " & plngNumCta & " And ExHistoria.chrTipoPaciente = '" & pstrTipoCta & "' "
    Set vlrsHistoriaCentral = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    '[  Si no existe nada que "desreplicar"... See you  ]
    If vlrsHistoriaCentral.RecordCount = 0 Then Exit Sub
    vllngCveHistoriaCentralizada = vlrsHistoriaCentral!INTCVEHISTORIACENTRALIZADA
    vllngCveHistoriaLocal = vlrsHistoriaCentral!intCveHistoria
    On Error GoTo NotificaError
    '[  Inicia transacción  ]
    EntornoSIHO.ConeccionSIHO.BeginTrans
    '**********************************************************

    
    '---------------------------------------------------------------
    '||  Eliminación de registros en EXVMHISTORIAANTECEDENTECIRU  ||
    '---------------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMHISTORIAANTECEDENTECIRU " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '---------------------------------------------------------------
    '||  Eliminación de registros en EXVMHISTORIAANTECEDENTEENFE  ||
    '---------------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMHISTORIAANTECEDENTEENFE " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '---------------------------------------------------------------
    '||  Eliminación de registros en EXVMHISTORIAANTECEDENTEOBST  ||
    '---------------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMHISTORIAANTECEDENTEOBST " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '---------------------------------------------------------------
    '||  Eliminación de registros en EXVMHISTORIAANTECEDENTESUBS  ||
    '---------------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMHISTORIAANTECEDENTESUBS " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '---------------------------------------------------------------
    '||  Eliminación de registros en EXVMHISTORIAANTECEDENTETRAN  ||
    '---------------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMHISTORIAANTECEDENTETRAN " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '---------------------------------------------------------------
    '||  Eliminación de registros en EXVMHISTORIAANTECEDENTEVACU  ||
    '---------------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMHISTORIAANTECEDENTEVACU " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '--------------------------------------------------------------
    '||  Eliminación de registros en EXVMHISTORIAAPARATOSISTEMA  ||
    '--------------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMHISTORIAAPARATOSISTEMA " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '--------------------------------------------------------------
    '||  Eliminación de registros en EXVMHISTORIAEXPLORACIONFIS  ||
    '--------------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMHISTORIAEXPLORACIONFIS " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '------------------------------------------------------------
    '||  Eliminación de registros en EXVMHISTORIANOPATOLOGICO  ||
    '------------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMHISTORIANOPATOLOGICO " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '-----------------------------------------------------------
    '||  Eliminación de registros en EXVMDIAGNOSTICOPACIENTE  ||
    '-----------------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From EXVMDIAGNOSTICOPACIENTE " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '--------------------------------------------------------------------------------------
    '||  Eliminación de registros en la tabla de la historia clínica compartida con PCE  ||
    '--------------------------------------------------------------------------------------
    '******************** < < <  P E N D I E N T E !!!!!!!  > > > **********************
    
    '------------------------------------------------
    '||  Eliminación de registros en ExVMHistoria  ||
    '------------------------------------------------
    vlstrSentencia = " Delete " & _
                     " From ExVMHistoria " & _
                     " Where INTCVEHISTORIA = " & vllngCveHistoriaCentralizada
    pEjecutaSentencia vlstrSentencia
    '----------------------------------------------------------------------------------
    '||  Actualiza la historia clínica local en estado de "aún no se debe replicar"  ||
    '----------------------------------------------------------------------------------
    vlstrSentencia = "Update ExHistoria set INTCVEHISTORIACENTRALIZADA = -1 Where INTCVEHISTORIA = " & vllngCveHistoriaLocal
    pEjecutaSentencia vlstrSentencia
    '[  Termina transacción  ]
    EntornoSIHO.ConeccionSIHO.CommitTrans
    Exit Sub
NotificaError:
    EntornoSIHO.ConeccionSIHO.RollbackTrans
    Exit Sub
End Sub

'###############################################################################
'##  "Deshace" la replicación de la hoja de evolución a la ubicación central  ##
'###############################################################################
Public Sub pDeshaceHojaEvolucion(plngNumCta As Long, pstrTipoCta As String)
    Dim vlstrSentencia As String
    Dim vlrsDatos As New ADODB.Recordset

On Error GoTo NotificaError
    
    EntornoSIHO.ConeccionSIHO.BeginTrans
    
    '[  "Desreplica" las notas de evolución  ]
    vlstrSentencia = "                  Delete From ExVMEvolucion "
    vlstrSentencia = vlstrSentencia & " Where ExVMEvolucion.INTCVEINTERNAMIENTO In (Select ExEvolucion.INTCVEINTERNAMIENTO"
    vlstrSentencia = vlstrSentencia & "                                          From ExEvolucion "
    vlstrSentencia = vlstrSentencia & "                                          Where ExEvolucion.CHRTIPOPACIENTE = '" & pstrTipoCta & "' And "
    vlstrSentencia = vlstrSentencia & "                                                ExEvolucion.INTNUMCUENTA = " & plngNumCta & ")"
    vlstrSentencia = vlstrSentencia & "                                                "
    pEjecutaSentencia vlstrSentencia
    '[  Pone la clave del internamiento como que aún no se deben replicar  ]
    vlstrSentencia = "                  Update ExEvolucion "
    vlstrSentencia = vlstrSentencia & " Set ExEvolucion.INTCVEINTERNAMIENTO = -1"
    vlstrSentencia = vlstrSentencia & " Where ExEvolucion.CHRTIPOPACIENTE = '" & pstrTipoCta & "' And "
    vlstrSentencia = vlstrSentencia & "    ExEvolucion.INTNUMCUENTA = " & plngNumCta
    pEjecutaSentencia vlstrSentencia
    
    EntornoSIHO.ConeccionSIHO.CommitTrans
    Exit Sub
NotificaError:
    EntornoSIHO.ConeccionSIHO.RollbackTrans
    Exit Sub
End Sub

Public Sub pInsertaValoracionProv(intIdProveedor As Long, intidcriterio As Integer, intidsubcriterio As Integer, _
            numvaloracion As Double, numidevento As Double)
  Dim sSQL As String
    
  sSQL = " INSERT INTO covaloresproveedores" & _
         " (intidproveedor, intidcriterio, intidsubcriterio, numvaloracion, numidevento) " & _
         " VALUES (" & intIdProveedor & " ," & intidcriterio & " , " & intidsubcriterio & "," & _
         Round(numvaloracion, 2) & "," & numidevento & ")"
  pEjecutaSentencia sSQL
  
End Sub

Public Function fintTraeValorSubCriterio(vlintParCriterio As Integer, vlintPartSubCrit As Integer) As Integer
On Error GoTo NotificaError
Dim rsCrit As New ADODB.Recordset
Dim vlstrsql As String

    fintTraeValorSubCriterio = 0
    
    vlstrsql = "SELECT NUMVALORACION  " & _
                " FROM COCRITERIOEVALUACIONDETALLE " & _
                " WHERE COCRITERIOEVALUACIONDETALLE.intidcriterio = " & vlintParCriterio & _
                " AND COCRITERIOEVALUACIONDETALLE.intOrden =  " & vlintPartSubCrit
                
    Set rsCrit = frsRegresaRs(vlstrsql)
    If rsCrit.RecordCount > 0 Then
        fintTraeValorSubCriterio = rsCrit!numvaloracion
    End If
    rsCrit.Close
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintTraeValorSubCriterio"))
End Function

Public Function fintTraePorcentajeCriterio(vlintParCriterio As Integer) As Integer
On Error GoTo NotificaError
Dim rsCrit As New ADODB.Recordset
Dim vlstrsql As String

    fintTraePorcentajeCriterio = 0
    
    vlstrsql = "SELECT NUMVALORACION  " & _
                " FROM COCRITERIOEVALUACION WHERE INTIDCRITERIO = " & vlintParCriterio
                
    Set rsCrit = frsRegresaRs(vlstrsql)
    If rsCrit.RecordCount > 0 Then
        fintTraePorcentajeCriterio = rsCrit!numvaloracion
    End If
    rsCrit.Close
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fintTraePorcentajeCriterio"))
End Function

'|  Inserta un registro en la tabla ImpresionRemota si al menos un artículo de la requisición es subrrogado  |
Public Sub pInsertaSubrrogados(plngCveReq As Long, lstrTipo As String)
    Dim vlstrSentencia As String
    Dim vlrsAticulosReq As New ADODB.Recordset
    Dim vlrsSubrogado As New ADODB.Recordset
    Dim lintInterfazFarmaciaSJP As Integer
    Dim rsParametro As ADODB.Recordset
    Dim rsDepto As ADODB.Recordset
    Dim llngDeptoSub As Long
    Dim llngDeptoSurte As Long
    
    'Tipos de requisicion que generan impresion remota de subrogados:
    'RS' = Requisicion por salida a departamento    DEPENDE DEL PARAMETRO
    'RR' = Requisicion por reubicacion              DEPENDE DEL PARAMETRO
    'RP' = Requisicion con cargo a paciente         SIEMPRE
    llngDeptoSurte = 0
    llngDeptoSub = 0
    Set rsParametro = frsSelParametros("IV", -1, "INTINTERFAZFARMACIASUBRROGADASJP")
    If Not rsParametro.EOF Then
        lintInterfazFarmaciaSJP = IIf(IsNull(rsParametro("Valor")), 0, rsParametro("Valor"))
    Else
        lintInterfazFarmaciaSJP = 0
    End If
    llngDeptoSub = 0
    If lintInterfazFarmaciaSJP = 1 Then
        'Consultar parametro de departamento subrogado
        Set rsParametro = frsSelParametros("IV", -1, "INTDEPTOINTERFAZFARMACIA")
        If Not rsParametro.EOF Then
            llngDeptoSub = IIf(IsNull(rsParametro("Valor")), 0, rsParametro("Valor"))
        Else
            llngDeptoSub = 0
        End If
        Set rsDepto = frsRegresaRs("select smicveDeptoAlmacen depto from IvRequisicionMaestro where numNumRequisicion = " & plngCveReq)
        If rsDepto.RecordCount <> 0 Then
            llngDeptoSurte = IIf(IsNull(rsDepto!DEPTO), 0, rsDepto!DEPTO)
        End If
    End If
     
    If lintInterfazFarmaciaSJP = 1 Or lstrTipo = "RP" Then
        '|  Localiza los artículos de la requisición  |
        vlstrSentencia = "Select IvRequisicionDetalle.CHRCVEARTICULO " & _
                         "From IvRequisicionMaestro Inner Join IvRequisicionDetalle On (IvRequisicionMaestro.NUMNUMREQUISICION = IvRequisicionDetalle.NUMNUMREQUISICION) " & _
                         "Where IvRequisicionMaestro.NUMNUMREQUISICION = " & CStr(plngCveReq)
        Set vlrsAticulosReq = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
        While Not vlrsAticulosReq.EOF
            '|  Si regresa algo el recordset significa que el artículo es subrrogado  |
            Set vlrsSubrogado = frsEjecuta_SP("|" & vlrsAticulosReq!chrcvearticulo & "|1", "sp_IVArticuloSub")
            If Not vlrsSubrogado.EOF Then
                If lintInterfazFarmaciaSJP = 0 Or (lintInterfazFarmaciaSJP = 1 And llngDeptoSub = llngDeptoSurte) Then
                    vlstrSentencia = "INSERT INTO ImpresionRemota (chrTipo, intClave, smiCveDepartamento, chrEstatus,dtmFecha) "
                    vlstrSentencia = vlstrSentencia + "VALUES('" + lstrTipo + "'," & plngCveReq & " ," & vlrsSubrogado!departamento & ", Null, getdate())"
                    pEjecutaSentencia vlstrSentencia
                    Exit Sub
                End If
             End If
            vlrsAticulosReq.MoveNext
        Wend
    End If

End Sub


Public Sub pImprimePoliza(vlstrNumPoliza As String, vlstrDestino As String, Optional vlintDesglosadoCuenta As Integer, Optional vlintOrdenamiento As Integer)
'Procedimiento para imprimir una póliza
' vlstrNumPoliza => Consecutivo de la póliza (CnPoliza.intNumeroPoliza)
' vlstrDestino   => "P" = vista previa, "I" = impresora

    Dim vgrptReporte As CRAXDRT.Report
    
    Dim rsReporte As New ADODB.Recordset

    Dim alstrParametros(1) As String
    
    Dim vlstrNumUsuario As String
    Dim vlstrEmpresa As String
    Dim vlstrNumDepartamento As String
    Dim vlstrNumEmpleado As String
    Dim vlstrTipoPoliza As String
    Dim vlstrAsentada As String
    Dim vlstrDescuadradas As String
    Dim vlstrDetallado As String
    Dim vlstrCuadre As String
    Dim vlstrNumCuentaCuadre As String
    Dim vlstrOrden As String
    Dim vlstrIncluirCuentaInmediata As String
    Dim vlstrFiltroFolios As String
    Dim vlstrFolioInicio As String
    Dim vlstrFolioFin As String
    Dim vlstrFiltroFechas As String
    Dim vlstrFechaInicio As String
    Dim vlstrFechaFin As String
    

    vlstrNumUsuario = "0"
    vlstrEmpresa = "0"
    vlstrNumDepartamento = "0"
    vlstrNumEmpleado = "0"
    vlstrTipoPoliza = "*"
    vlstrAsentada = "0"
    vlstrDescuadradas = "0"
    vlstrDetallado = "0"
    vlstrCuadre = "0"
    vlstrNumCuentaCuadre = "0"
    vlstrOrden = IIf(vlintOrdenamiento = 0, "4", CStr(vlintOrdenamiento))
    vlstrIncluirCuentaInmediata = "0"
    vlstrFiltroFolios = "0"
    vlstrFolioInicio = "0"
    vlstrFolioFin = "0"
    vlstrFiltroFechas = "0"
    vlstrFechaInicio = fstrFechaSQL(fdtmServerFecha, , True)
    vlstrFechaFin = fstrFechaSQL(fdtmServerFecha, , True)
    
    
    pInstanciaReporte vgrptReporte, "rptPoliza.rpt"
    vgrptReporte.DiscardSavedData
    
    vgstrParametrosSP = _
    vlstrNumPoliza & "|" & _
    vlstrNumUsuario & "|" & _
    vlstrEmpresa & "|" & _
    vlstrNumDepartamento & "|" & _
    vlstrNumEmpleado & "|" & _
    vlstrTipoPoliza & "|" & _
    vlstrAsentada & "|" & _
    vlstrDescuadradas & "|" & _
    vlstrDetallado & "|" & _
    vlstrCuadre & "|" & _
    vlstrNumCuentaCuadre & "|" & _
    vlstrOrden & "|" & _
    vlstrIncluirCuentaInmediata & "|" & _
    vlstrFiltroFolios & "|" & _
    vlstrFolioInicio & "|" & _
    vlstrFolioFin & "|" & _
    vlstrFiltroFechas & "|" & _
    vlstrFechaInicio & "|" & _
    vlstrFechaFin
    
    Set rsReporte = frsEjecuta_SP(vgstrParametrosSP, "sp_CnRptPoliza")
    Set rsReporte = frsUltimoRecordset(rsReporte)
    If rsReporte.RecordCount > 0 Then
        alstrParametros(0) = "DesglosadoCuenta;" & Trim(vlintDesglosadoCuenta)
        alstrParametros(1) = "IN_POLIZAPAGINA;" & "0"
        pCargaParameterFields alstrParametros, vgrptReporte

        pImprimeReporte vgrptReporte, rsReporte, vlstrDestino, "Póliza"
    Else
        'No existe información con esos parámetro
        MsgBox SIHOMsg(236), vbOKOnly + vbInformation, "Mensaje"
    End If
    rsReporte.Close
    
End Sub

Public Function flngFolioPoliza(vlintClaveEmpresa As Integer, vlstrTipoPoliza As String, vlintEjercicio As Integer, vlintMes As Integer, vlblnConsulta As Boolean) As Long
    'Función que regresa el consecutivo siguiente (CnPoliza.intClavePoliza) para las pólizas según la parametrización de la empresa
    'vlintClaveEmpresa = Clave de la empresa contable
    'vlstrTipoPoliza = Tipo de póliza D = diario, I = ingresos, E = egresos, O = orden
    'vlblnConsulta = true = solo regresar el folio, false = quemar el folio
    
    Dim vlstrTipoConsecutivo As String 'Consecutivo por periodo o por ejercicio
    Dim vlstrSentencia As String
    Dim rsParametros As New ADODB.Recordset
    Dim rsCnFolioPoliza As New ADODB.Recordset
    Dim rsFolioPoliza As New ADODB.Recordset
    Dim blnFolioAutomatico As Boolean
    Dim strTipoFolioAutomatico As String
    
    flngFolioPoliza = 0
    blnFolioAutomatico = False
    strTipoFolioAutomatico = ""
    Set rsParametros = frsSelParametros("CN", vlintClaveEmpresa, "BITFOLIOAUTOMATICO")
    If Not rsParametros.EOF Then
        blnFolioAutomatico = CBool(rsParametros!Valor)
    End If
    rsParametros.Close
    Set rsParametros = frsSelParametros("CN", vlintClaveEmpresa, "CHRTIPOFOLIOAUTOMATICO")
    If Not rsParametros.EOF Then
        strTipoFolioAutomatico = rsParametros!Valor
    End If
    rsParametros.Close
    
    If blnFolioAutomatico Then
        vlstrSentencia = "select * from CnFolioPoliza where tnyClaveEmpresa = " & vlintClaveEmpresa & " and chrTipoPoliza = '" & vlstrTipoPoliza & "' and smiEjercicio = " & vlintEjercicio
        If strTipoFolioAutomatico = "P" Then
            vlstrSentencia = vlstrSentencia & " and intPeriodo = " & vlintMes
        End If
        
        Set rsFolioPoliza = frsRegresaRs(vlstrSentencia)
        If rsFolioPoliza.RecordCount <> 0 Then
            flngFolioPoliza = rsFolioPoliza!intClavePoliza + 1
        Else
            flngFolioPoliza = 1
        End If
        If Not vlblnConsulta Then
            Set rsCnFolioPoliza = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
            With rsCnFolioPoliza
                If .RecordCount = 0 Then
                    .AddNew
                    !tnyclaveempresa = vlintClaveEmpresa
                    !smiEjercicio = vlintEjercicio
                    !chrTipoPoliza = vlstrTipoPoliza
                    !intPeriodo = IIf(strTipoFolioAutomatico = "P", vlintMes, 0)
                    !intClavePoliza = 0
                End If
                !intClavePoliza = !intClavePoliza + 1
                .Update
            End With
        End If
    End If

End Function

Public Function fblnSerieUnica() As Boolean
    Dim rs As ADODB.Recordset
    Set rs = frsRegresaRs("select intSerieUnicaNotas from CCParametro")
    If Not rs.EOF Then
        If rs!intserieUnicaNotas = 0 Then
            fblnSerieUnica = False
        Else
            fblnSerieUnica = True
        End If
    Else
        fblnSerieUnica = False
    End If
    rs.Close
End Function

Public Function flngInsertarPoliza(vldtmFecha As Date, vlstrTipoPoliza As String, vlStrConcepto, vllngEmpleado As Long) As Long
    '------------------------------------------------------------------------------------------------------------
    ' Función que inserta una póliza y regresa el consecutivo, esta función hace uso de dos variables globales:
    ' vgintNumeroDepartamento = Departamento que está insertando la póliza
    ' vgintClaveEmpresaContable = Clave de la empresa contable
    '------------------------------------------------------------------------------------------------------------
    Dim rsCnPoliza As New ADODB.Recordset
    Dim vlstrSentencia As String
    
    vlstrSentencia = "select * from CnPoliza where intNumeroPoliza = -1"
    Set rsCnPoliza = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    With rsCnPoliza
        .AddNew
        !tnyclaveempresa = vgintClaveEmpresaContable
        !smiEjercicio = Year(CDate(vldtmFecha))
        !tnyMes = Month(CDate(vldtmFecha))
        !intClavePoliza = flngFolioPoliza(vgintClaveEmpresaContable, vlstrTipoPoliza, Year(vldtmFecha), Month(vldtmFecha), False)
        !dtmFechaPoliza = vldtmFecha
        !chrTipoPoliza = vlstrTipoPoliza
        !vchConceptoPoliza = IIf(Len(Trim(vlStrConcepto)) > 250, Mid(Trim(vlStrConcepto), 1, 250), Trim(vlStrConcepto))
        !smicvedepartamento = vgintNumeroDepartamento
        !intCveEmpleado = vllngEmpleado
        !vchNumero = " "
        !bitAsentada = 0
        .Update
    End With
    flngInsertarPoliza = flngObtieneIdentity("SEC_CNPOLIZA", rsCnPoliza!INTNUMEROPOLIZA)
    rsCnPoliza.Close
    
End Function
Public Function flngInsertarPolizaDetalle(vllngNumPoliza As Long, vllngNumCuenta As Long, vldblCantidad As Double, vlintCargo As Integer, Optional strReferencia As String = "", Optional strConcepto As String = "") As Long
    '------------------------------------------------------------------------------------------------------------
    ' Función que inserta el detalle de la póliza y regresa el consecutivo de la tabla
    '------------------------------------------------------------------------------------------------------------
    Dim rsCnDetallePoliza As New ADODB.Recordset
    Dim vlstrSentencia As String
    vlstrSentencia = "select * from CnDetallePoliza where intNumeroPoliza = -1 "
    Set rsCnDetallePoliza = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    With rsCnDetallePoliza
        .AddNew
        !INTNUMEROPOLIZA = vllngNumPoliza
        !intNumeroCuenta = vllngNumCuenta
        !bitNaturalezaMovimiento = vlintCargo
        !mnyCantidadMovimiento = vldblCantidad
        !vchReferencia = IIf(Len(Trim(strReferencia)) > 50, Mid(Trim(strReferencia), 1, 50), Trim(strReferencia))
        !vchConcepto = IIf(Trim(strConcepto) = "", " ", Trim(strConcepto))
        .Update
    End With
    flngInsertarPolizaDetalle = flngObtieneIdentity("SEC_CNDETALLEPOLIZA", rsCnDetallePoliza!intNumeroRegistro)
    rsCnDetallePoliza.Close
End Function
Public Function fblnCuentaCerrada(pstrCuenta As String, pstrTipoPaciente As String) As Boolean
    Dim vlrsCuentaCerrada As New ADODB.Recordset
    Dim vlstrSentencia As String
    If pstrTipoPaciente = "I" Then
        vlstrSentencia = "select bitCuentaCerrada from ADAdmision where ADAdmision.numNumCuenta = " & pstrCuenta
    Else
        vlstrSentencia = "select bitCuentaCerrada from RegistroExterno where RegistroExterno.intNumCuenta = " & pstrCuenta
    End If
    Set vlrsCuentaCerrada = frsRegresaRs(vlstrSentencia)
    If vlrsCuentaCerrada.EOF Then
        fblnCuentaCerrada = True
    Else
        fblnCuentaCerrada = IIf(IsNull(vlrsCuentaCerrada!bitCuentaCerrada), False, vlrsCuentaCerrada!bitCuentaCerrada)
    End If
    vlrsCuentaCerrada.Close
End Function

Public Sub pCancelarPoliza(lngNumPoliza As Long, Optional strConceptoPoliza As String)
    '------------------------------------------------------------------------------------------------------------
    ' Procedimiento que cancela una póliza, deja el registro maestro CnPoliza con el concepto modificado
    ' y borra el detalle de la póliza, no se elimina de CnPoliza porque los consecutivos del tipo de póliza
    ' se verían afectados
    '------------------------------------------------------------------------------------------------------------
    Dim strSentencia As String
    
    If strConceptoPoliza <> "" Then
        strSentencia = "update CnPoliza set vchConceptoPoliza = '" & strConceptoPoliza & "' where intNumeroPoliza = " & str(lngNumPoliza)
        pEjecutaSentencia strSentencia
    End If
    
    strSentencia = "delete from CnDetallePoliza where intNumeroPoliza = " & str(lngNumPoliza)
    pEjecutaSentencia strSentencia

End Sub

Public Function fblnCuentaAfectable(strCuenta As String, intCveEmpresaContable As Integer) As Boolean
    '------------------------------------------------------------------------------------------------------------
    ' Función para verificar si una cuenta contable puede incluirse en una póliza, si es afectable o no
    '------------------------------------------------------------------------------------------------------------
    Dim strSentencia As String
    Dim rs As New ADODB.Recordset
    
    fblnCuentaAfectable = False
    
    strSentencia = _
    "select " & _
        "CnCuenta.bitEstatusMovimientos " & _
    "From " & _
        "CnCuenta " & _
    "Where " & _
        "CnCuenta.bitEstatusActiva = 1 " & _
        "and CnCuenta.vchCuentaContable = '" & strCuenta & "'" & _
        "and CnCuenta.tnyClaveEmpresa = " & str(intCveEmpresaContable)
    Set rs = frsRegresaRs(strSentencia)
    If rs.RecordCount <> 0 Then
        fblnCuentaAfectable = IIf(rs.Fields(0) = 1, True, False)
    End If
End Function

Public Function fblnRequisicionPaciente(vllngCuenta As Long, vlstrTipo As String) As Boolean
    '----------------------------------------------------------------------------------
    ' Verificar si el paciente tiene requisiciones pendientes de surtir
    '----------------------------------------------------------------------------------
    Dim vlstrSentencia As String
    Dim rsRequisiciones As New ADODB.Recordset
    Dim i As Integer
    
    fblnRequisicionPaciente = False
          
    vgstrParametrosSP = str(vllngCuenta) & "|" & vlstrTipo
    Set rsRequisiciones = frsEjecuta_SP(vgstrParametrosSP, "sp_PvSelRequisicionesPendietes")
    
    'Set rsRequisiciones = frsRegresaRs(vlstrSentencia)
    If rsRequisiciones.RecordCount <> 0 Then
        vstrRequisicion = ""
        fblnRequisicionPaciente = True
        For i = 1 To rsRequisiciones.RecordCount
            vstrRequisicion = vstrRequisicion & vbCrLf & rsRequisiciones!numNumRequisicion & "  " & rsRequisiciones!dtmFechaRequisicion & "  " & rsRequisiciones!SMICVEDEPTOREQUISDESC
            rsRequisiciones.MoveNext
        Next
        
    End If

End Function

Public Sub pLlenarCboSentencia( _
vlcboNombre As ComboBox, _
vlstrSentencia As String, _
vlintColList As Integer, _
vlintColItemData As Integer, _
Optional vlstrRenglonEspecial As String, _
Optional vllngRenglonEspecial As Long)
'vlcboNombre = Nombre del combo
'vlstrSentencia = Sentencia con la cual se cargará el recordset
'vlintColList = Columna que se pondrá en el List
'vlintColItemData = Columna que se pondrá en el ItemData
'Optional vlstrRenglonEspecial = Si se incluye un renglón especial. Ejemplo: <TODOS>
'Optional vllngRenglonEspecial = ItemData para vlstrRenglonEspecial

    On Error GoTo NotificaError

    Dim vllngContador As Long
    Dim rs As New ADODB.Recordset
    
    vlcboNombre.Clear
    Set rs = frsRegresaRs(vlstrSentencia)
    If rs.RecordCount <> 0 Then
        Do While Not rs.EOF
            vlcboNombre.AddItem rs.Fields(vlintColList)
            vlcboNombre.ItemData(vlcboNombre.newIndex) = rs.Fields(vlintColItemData)
            rs.MoveNext
        Loop
    End If
    If Trim(vlstrRenglonEspecial) <> "" Then
        vlcboNombre.AddItem vlstrRenglonEspecial, 0
        vlcboNombre.ItemData(vlcboNombre.newIndex) = vllngRenglonEspecial
    End If
    If vlcboNombre.ListCount <> 0 Then
        vlcboNombre.ListIndex = 0
    End If
    rs.Close

Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pLlenarCboSentencia"))
End Sub

Public Sub pImprimeSolicitudExamenes(vllngNumSolicitud As Long, vlstrDestino As String, ObjForm As Form, vlstrEdad As String)
Dim alstrParametros(0) As String
Dim vgrptReporte As CRAXDRT.Report
pInstanciaReporte vgrptReporte, "rptSolicitudExamen.rpt"
Dim rsReporte As ADODB.Recordset
vgrptReporte.DiscardSavedData

    alstrParametros(0) = "STR_EDAD;" & vlstrEdad
    pCargaParameterFields alstrParametros, vgrptReporte

    Set rsReporte = frsEjecuta_SP(str(vllngNumSolicitud), "SP_LARPTSOLICITUDEXAMEN")
    pImprimeReporte vgrptReporte, rsReporte, vlstrDestino, "Solicitud de examenes"
  
End Sub

Public Sub pVerificarInformacionFaltantePaciente(vlintCuentaPaciente As Long)
Dim rsVerificaPaciente As New ADODB.Recordset
Dim rsParametro As New ADODB.Recordset
Dim vlstrsql As String

    Set rsParametro = frsSelParametros("EX", -1, "BITMOSTRARAVISOINFOFALTANTE")
    If Not rsParametro.EOF Then
        If IsNull(rsParametro!Valor) Then
            rsParametro.Close
            Exit Sub
        Else
            If rsParametro!Valor = "0" Then
                rsParametro.Close
                Exit Sub
            End If
        End If
    Else
        rsParametro.Close
        Exit Sub
    End If
    rsParametro.Close

    vlstrsql = "SELECT count(*) AS NoExiste FROM ExLogMsgPaciente WHERE intCuentaPaciente = " & vlintCuentaPaciente
    Set rsVerificaPaciente = frsRegresaRs(vlstrsql, adLockOptimistic, adOpenDynamic)

    If rsVerificaPaciente.EOF Then
        rsVerificaPaciente.Close
        Exit Sub
    End If

    If rsVerificaPaciente!NoExiste <> 0 Then
        rsVerificaPaciente.Close
        Exit Sub
    End If

    frmInformacionFaltantePaciente.vgintCuentaPaciente = vlintCuentaPaciente
    frmInformacionFaltantePaciente.Show vbModal

    rsVerificaPaciente.Close

End Sub

Public Function frsPoliza(strNumPoliza As String) As Recordset
    Dim strNumUsuario As String
    Dim strEmpresa As String
    Dim strNumDepartamento As String
    Dim strNumEmpleado As String
    Dim strTipoPoliza As String
    Dim strAsentada As String
    Dim strDescuadradas As String
    Dim strDetallado As String
    Dim strCuadre As String
    Dim strNumCuentaCuadre As String
    Dim strOrden As String
    Dim strIncluirCuentaInmediata As String
    Dim strFiltroFolios As String
    Dim strFolioInicio As String
    Dim strFolioFin As String
    Dim strFiltroFechas As String
    Dim strFechaInicio As String
    Dim strFechaFin As String
    
    
    strNumUsuario = "0"
    strEmpresa = "0"
    strNumDepartamento = "0"
    strNumEmpleado = "0"
    strTipoPoliza = "*"
    strAsentada = "0"
    strDescuadradas = "0"
    strDetallado = "0"
    strCuadre = "0"
    strNumCuentaCuadre = "0"
    strOrden = "3" ' la póliza se carga en la forma en que fue capturada
    strIncluirCuentaInmediata = "0"
    strFiltroFolios = "0"
    strFolioInicio = "0"
    strFolioFin = "0"
    strFiltroFechas = "0"
    strFechaInicio = fstrFechaSQL(fdtmServerFecha)
    strFechaFin = fstrFechaSQL(fdtmServerFecha)
    
    vgstrParametrosSP = _
    strNumPoliza & "|" & _
    strNumUsuario & "|" & _
    strEmpresa & "|" & _
    strNumDepartamento & "|" & _
    strNumEmpleado & "|" & _
    strTipoPoliza & "|" & _
    strAsentada & "|" & _
    strDescuadradas & "|" & _
    strDetallado & "|" & _
    strCuadre & "|" & _
    strNumCuentaCuadre & "|" & _
    strOrden & "|" & _
    strIncluirCuentaInmediata & "|" & _
    strFiltroFolios & "|" & _
    strFolioInicio & "|" & _
    strFolioFin & "|" & _
    strFiltroFechas & "|" & _
    strFechaInicio & "|" & _
    strFechaFin
    
    Set frsPoliza = frsEjecuta_SP(vgstrParametrosSP, "sp_CnRptPoliza")

End Function


Public Sub pCargaParametroAlmacen()
    'Procedimiento que carga en las variables globales los parámetros del módulo de almacén
    
    Dim rs As New ADODB.Recordset
    
    vgstrParametrosSP = vgintClaveEmpresaContable
    Set rs = frsEjecuta_SP(vgstrParametrosSP, "sp_IvSelParametro")
    If rs.RecordCount <> 0 Then
        glngCveDepartamentoPapeleria = IIf(IsNull(rs!smiCveDepartamentoPapeleria), 0, rs!smiCveDepartamentoPapeleria)
        gstrConfiguracionActivo = IIf(IsNull(rs!chrConfiguracionActivo), "", rs!chrConfiguracionActivo)
        gstrConfiguracionCosto = IIf(IsNull(rs!chrConfiguracionCosto), "", rs!chrConfiguracionCosto)
        gstrConfiguracionGasto = IIf(IsNull(rs!chrConfiguracionGasto), "", rs!chrConfiguracionGasto)
        gstrFormatoCveArticulo = IIf(IsNull(rs!chrformatocvearticulo), "", rs!chrformatocvearticulo)
        gintBonificacionCostoCero = IIf(IsNull(rs!bitBonificacionCostoCero), 0, rs!bitBonificacionCostoCero)
        gstrTipoCuentaAjuste = IIf(IsNull(rs!chrTipoCuentaAjuste), "", rs!chrTipoCuentaAjuste)
        gintAutorizaReqReubica = IIf(IsNull(rs!bitAutorizaReqReubica), 0, rs!bitAutorizaReqReubica)
        gintMuestraCodBar = IIf(IsNull(rs!bitMuestraCodBar), 0, rs!bitMuestraCodBar)
        gintInventarioFisicoDUMMY = IIf(IsNull(rs!bitInventarioFisicoDUMMY), 0, rs!bitInventarioFisicoDUMMY)
        gintCopiaReqSurtida = IIf(IsNull(rs!bitCopiaReqSurtida), 0, rs!bitCopiaReqSurtida)
        gstrTipoCuentaReubicacionStock = IIf(IsNull(rs!chrTipoCuentaReubicacionStock), "", rs!chrTipoCuentaReubicacionStock)

    End If
    rs.Close
    
End Sub

Public Function frsEjecuta_SP_ConApostrofe(p_vlstrParametros As String, p_vlstrSP As String, Optional vlblnNORegresaRS As Boolean, Optional vllngValorRegresado As Long, Optional vlaryParametrosSalida As Variant, Optional vlblnTiempoEspera As Boolean, Optional vlblnNOQuitarApostrofes As Boolean) As ADODB.Recordset
  '---------------------------------------------------------------
  'Fecha de creación  :  04/11/2003
  '---------------------------------------------------------------
  'Modificación:  21/01/2004
  'Motivo: Se estandarizaron las variables y se definieron las que no tenian tipo, además se resolvio el problema del
  '        envio de strings como parametros en MSSQL
  '---------------------------------------------------------------
  'Modificación: 05/03/2004
  'Motivo: Se adaptó el procedimiento para que pueda regresar parámetros de salida de un SP por medio de un arreglo
  '---------------------------------------------------------------


  'Declaración de variables locales
  Dim vlIntCont As Long
  Dim vlstrValParam As String               'Valor de los parametros
  Dim vlstrNumParam As String               'Numero de parametros
  Dim vlstrAuxiliar As String               'Sirve para eliminar las apostrofes en caso de que sea Oracle
  Dim vlstrParJuntos As String
  Dim vlcmdCommand As ADODB.Command
  Dim vlrsRecordSet As ADODB.Recordset
  Dim vlprmNameParam As ADODB.Parameter
  Dim i As Long
  Dim a As Integer
  Dim vlintNumParams As Integer
  Dim vlintRenglonArreglo As Integer
  Dim vlintApostrofe As Integer
  
  vlstrErrorLister = 0
  Set vlcmdCommand = CreateObject("ADODB.Command")
  
  'SI es true, le da un valor de 0 al timeout, para que no marque error de timeout el sp
  If vlblnTiempoEspera = True Then
        vlcmdCommand.CommandTimeout = 0
  End If
  
  On Error GoTo NotificaError
    
  'Inicializacion de variables
  vlstrParJuntos = ""
  vlstrNumParam = ""
  vlstrValParam = ""
  vlstrAuxiliar = ""

  ' Elimina la s apostrofes en caso de que sea ORACLE / MSSQL'
  If Not vlblnNOQuitarApostrofes Then
    vlintApostrofe = 1
    For vlIntCont = 1 To Len(p_vlstrParametros)
      If Mid(p_vlstrParametros, vlIntCont, 1) <> "'" Then
        vlstrAuxiliar = vlstrAuxiliar & Mid(p_vlstrParametros, vlIntCont, 1)
      Else
        If vlintApostrofe = 8 Then
            vlstrAuxiliar = vlstrAuxiliar & "'"
        End If
      End If
      If Mid(p_vlstrParametros, vlIntCont, 1) = "|" Then
        vlintApostrofe = vlintApostrofe + 1
      End If
      
    Next vlIntCont
    p_vlstrParametros = vlstrAuxiliar
  End If
 
  If vgstrBaseDatosUtilizada = "MSSQL" Then
    With vlcmdCommand
          .CommandType = adCmdStoredProc
          Set .ActiveConnection = EntornoSIHO.ConeccionSIHO
          .ActiveConnection.CursorLocation = adUseClient
          .CommandText = p_vlstrSP
          .Prepared = True
          .Parameters.Refresh
    End With
    If Len(p_vlstrParametros) > 0 Then
      a = 1
      For i = 1 To Len(p_vlstrParametros) + 1
        'Busca el valor del parametro
        If (Mid(p_vlstrParametros, i, 1) <> "|") And (Len(p_vlstrParametros) >= i) Then
          vlstrValParam = vlstrValParam & Mid(p_vlstrParametros, i, 1)
        Else
            'Aqui te trae el tipo de dato del parametro del sp
            If vlcmdCommand.Parameters(a).Type = adDBTimeStamp Or vlcmdCommand.Parameters(a).Type = adDBDate Or vlcmdCommand.Parameters(a).Type = adDate Or vlcmdCommand.Parameters(a).Type = adDBTime Then
              If IsDate(Mid(vlstrValParam, 4, 3) & Mid(vlstrValParam, 1, 3) & Mid(vlstrValParam, 7, Len(vlstrValParam) - 6)) Then
                vlstrValParam = Mid(vlstrValParam, 4, 3) & Mid(vlstrValParam, 1, 3) & Mid(vlstrValParam, 7, Len(vlstrValParam) - 6)
              End If
              vlcmdCommand.Parameters(a).Value = CDate(vlstrValParam)
            Else
                If vlcmdCommand.Parameters(a).Type = adInteger Then
                    vlcmdCommand.Parameters(a).Value = IIf(vlstrValParam = "", Null, vlstrValParam)
                Else
                    vlcmdCommand.Parameters(a).Value = vlstrValParam
                End If
            End If
          vlstrValParam = ""
          a = a + 1
        End If
      Next i
    End If
    'Ciclo que carga los parametros de salida
    If IsArray(vlaryParametrosSalida) Then
        vlintNumParams = 0
        For i = 0 To vlcmdCommand.Parameters.Count - 1
            If vlcmdCommand.Parameters(i).Direction = adParamInputOutput Then
                If vlaryParametrosSalida(0, vlintNumParams) <> "" Then
                    vlcmdCommand.Parameters(i).Value = vlaryParametrosSalida(0, vlintNumParams)
                End If
                vlintNumParams = vlintNumParams + 1
            End If
        Next i
    End If

  Else  'ORACLE
    ' Si se configura para que regrese
    If vllngValorRegresado = 1 Then
      vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("Return_value", adInteger, adParamReturnValue, 10, 0)
    End If
    If Len(p_vlstrParametros) > 0 Then
      For i = 1 To Len(p_vlstrParametros) + 1
      'Busca el valor del parametro
        If (Mid(p_vlstrParametros, i, 1) <> "|") And (Len(p_vlstrParametros) >= i) Then
          vlstrValParam = vlstrValParam & Mid(p_vlstrParametros, i, 1)
        Else
          'Crea y carga el parametro en el Command
          Set vlprmNameParam = vlcmdCommand.CreateParameter(, adBSTR, adParamInput, , vlstrValParam)
          vlcmdCommand.Parameters.Append vlprmNameParam
          vlstrNumParam = vlstrNumParam & "?,"
          vlstrParJuntos = vlstrParJuntos & vlstrValParam & ","
          vlstrValParam = ""
        End If
      Next i
      'Elimina la coma final
      vlstrNumParam = Mid(vlstrNumParam, 1, (Len(vlstrNumParam) - 1))
      vlstrParJuntos = Mid(vlstrParJuntos, 1, (Len(vlstrParJuntos) - 1))
    End If
   
    With vlcmdCommand
      .CommandType = adCmdStoredProc
       Set .ActiveConnection = EntornoSIHO.ConeccionSIHO
      .CommandText = p_vlstrSP
    End With
    'Ciclo que carga los parametros de salida
    If IsArray(vlaryParametrosSalida) Then
        For vlintRenglonArreglo = 0 To UBound(vlaryParametrosSalida, 2) - 1
            '************************* N O T A   I M P O R T A N T E ***********************
            'Dado que el WorkBench creo los SP que tenian parámetros de salida como "IN OUT"
            'independientemente de si eran solo de salida, se asume que ningún SP tiene
            'parámetros solo "OUT", si este procedimiento genera un "error de conversión..."
            'se deben cambiar los parámetros del SP de "OUT" a "IN OUT"
            If vlaryParametrosSalida(1, vlintRenglonArreglo) = "8" Then 'Si es un string se debe especificar el tamaño
                If vlaryParametrosSalida(0, vlintRenglonArreglo) <> "" Then
                    vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("ParametroSalida" & vlintRenglonArreglo, CInt(vlaryParametrosSalida(1, vlintRenglonArreglo)), adParamInputOutput, 4000, vlaryParametrosSalida(0, vlintRenglonArreglo))
                Else
                    vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("ParametroSalida" & vlintRenglonArreglo, CInt(vlaryParametrosSalida(1, vlintRenglonArreglo)), adParamInputOutput, 4000, "x")
                End If
            Else
                If vlaryParametrosSalida(0, vlintRenglonArreglo) <> "" Then
                    vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("ParametroSalida" & vlintRenglonArreglo, CInt(vlaryParametrosSalida(1, vlintRenglonArreglo)), adParamInputOutput, , vlaryParametrosSalida(0, vlintRenglonArreglo))
                Else
                    vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("ParametroSalida" & vlintRenglonArreglo, CInt(vlaryParametrosSalida(1, vlintRenglonArreglo)), adParamInputOutput, , 0)
                End If
            End If
        Next vlintRenglonArreglo
    End If
  End If  'Fin oracle
  
  With vlcmdCommand
    If vlblnNORegresaRS Then
        Set vlrsRecordSet = Nothing
       .Execute
    Else
        Set vlrsRecordSet = .Execute()
    End If
    
    vlintNumParams = 0
    'Ciclo que carga los parametros de salida
    If IsArray(vlaryParametrosSalida) Then
        For i = 0 To .Parameters.Count - 1
            If (.Parameters(i).Direction = adParamOutput) Or (.Parameters(i).Direction = adParamInputOutput) Then
                vlaryParametrosSalida(0, vlintNumParams) = .Parameters(i).Value
                vlintNumParams = vlintNumParams + 1
            End If
        Next i
    End If
    
    If vllngValorRegresado = 1 Then
      vllngValorRegresado = .Parameters(0).Value
    End If
  End With
  Set frsEjecuta_SP_ConApostrofe = vlrsRecordSet
  
   'Le devuelve el timeout a 30
  If vlblnTiempoEspera = True Then
        vlcmdCommand.CommandTimeout = 30
  End If
  
Exit Function
NotificaError:
    vlstrErrorLister = InStr(Err.Description, "TicketError")

    If vlstrErrorLister > 0 Then
'      vlstrErrorLister = 0
'      EntornoSIHO.ConeccionSIHO.RollbackTrans
      MsgBox "No es posible hacer esta operación, ya se ha generado un ticket en la farmacia subrogada.", vbExclamation, "Mensaje"
    Else
        Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":frsEjecuta_SP_ConApostrofe" & " " & p_vlstrSP), p_vlstrParametros)
    End If
End Function

Public Function frsEjecuta_SP(p_vlstrParametros As String, p_vlstrSP As String, Optional vlblnNORegresaRS As Boolean, Optional vllngValorRegresado As Long, Optional vlaryParametrosSalida As Variant, Optional vlblnTiempoEspera As Boolean, Optional vlblnNOQuitarApostrofes As Boolean) As ADODB.Recordset
  '---------------------------------------------------------------
  'Fecha de creación  :  04/11/2003
  '---------------------------------------------------------------
  'Modificación:  21/01/2004
  'Motivo: Se estandarizaron las variables y se definieron las que no tenian tipo, además se resolvio el problema del
  '        envio de strings como parametros en MSSQL
  '---------------------------------------------------------------
  'Modificación: 05/03/2004
  'Motivo: Se adaptó el procedimiento para que pueda regresar parámetros de salida de un SP por medio de un arreglo
  '---------------------------------------------------------------


  'Declaración de variables locales
  Dim vlIntCont As Long
  Dim vlstrValParam As String               'Valor de los parametros
  Dim vlstrNumParam As String               'Numero de parametros
  Dim vlstrAuxiliar As String               'Sirve para eliminar las apostrofes en caso de que sea Oracle
  Dim vlstrParJuntos As String
  Dim vlcmdCommand As ADODB.Command
  Dim vlrsRecordSet As ADODB.Recordset
  Dim vlprmNameParam As ADODB.Parameter
  Dim i As Long
  Dim a As Integer
  Dim vlintNumParams As Integer
  Dim vlintRenglonArreglo As Integer
  
  vlstrErrorLister = 0
  Set vlcmdCommand = CreateObject("ADODB.Command")
  
  'SI es true, le da un valor de 0 al timeout, para que no marque error de timeout el sp
  If vlblnTiempoEspera = True Then
        vlcmdCommand.CommandTimeout = 0
  End If
  
  On Error GoTo NotificaError
    
  'Inicializacion de variables
  vlstrParJuntos = ""
  vlstrNumParam = ""
  vlstrValParam = ""
  vlstrAuxiliar = ""

  ' Elimina la s apostrofes en caso de que sea ORACLE / MSSQL'
  If Not vlblnNOQuitarApostrofes Then
    For vlIntCont = 1 To Len(p_vlstrParametros)
      If Mid(p_vlstrParametros, vlIntCont, 1) <> "'" Then vlstrAuxiliar = vlstrAuxiliar & Mid(p_vlstrParametros, vlIntCont, 1)
    Next vlIntCont
    p_vlstrParametros = vlstrAuxiliar
  End If
  
  If vgstrBaseDatosUtilizada = "MSSQL" Then
    With vlcmdCommand
          .CommandType = adCmdStoredProc
          Set .ActiveConnection = EntornoSIHO.ConeccionSIHO
          .ActiveConnection.CursorLocation = adUseClient
          .CommandText = p_vlstrSP
          .Prepared = True
          .Parameters.Refresh
    End With
    If Len(p_vlstrParametros) > 0 Then
      a = 1
      For i = 1 To Len(p_vlstrParametros) + 1
        'Busca el valor del parametro
        If (Mid(p_vlstrParametros, i, 1) <> "|") And (Len(p_vlstrParametros) >= i) Then
          vlstrValParam = vlstrValParam & Mid(p_vlstrParametros, i, 1)
        Else
            'Aqui te trae el tipo de dato del parametro del sp
            If vlcmdCommand.Parameters(a).Type = adDBTimeStamp Or vlcmdCommand.Parameters(a).Type = adDBDate Or vlcmdCommand.Parameters(a).Type = adDate Or vlcmdCommand.Parameters(a).Type = adDBTime Then
              If IsDate(Mid(vlstrValParam, 4, 3) & Mid(vlstrValParam, 1, 3) & Mid(vlstrValParam, 7, Len(vlstrValParam) - 6)) Then
                vlstrValParam = Mid(vlstrValParam, 4, 3) & Mid(vlstrValParam, 1, 3) & Mid(vlstrValParam, 7, Len(vlstrValParam) - 6)
              End If
              vlcmdCommand.Parameters(a).Value = CDate(vlstrValParam)
            Else
                If vlcmdCommand.Parameters(a).Type = adInteger Then
                    vlcmdCommand.Parameters(a).Value = IIf(vlstrValParam = "", Null, vlstrValParam)
                Else
                    vlcmdCommand.Parameters(a).Value = vlstrValParam
                End If
            End If
          vlstrValParam = ""
          a = a + 1
        End If
      Next i
    End If
    'Ciclo que carga los parametros de salida
    If IsArray(vlaryParametrosSalida) Then
        vlintNumParams = 0
        For i = 0 To vlcmdCommand.Parameters.Count - 1
            If vlcmdCommand.Parameters(i).Direction = adParamInputOutput Then
                If vlaryParametrosSalida(0, vlintNumParams) <> "" Then
                    vlcmdCommand.Parameters(i).Value = vlaryParametrosSalida(0, vlintNumParams)
                End If
                vlintNumParams = vlintNumParams + 1
            End If
        Next i
    End If

  Else  'ORACLE
    ' Si se configura para que regrese
    If vllngValorRegresado = 1 Then
      vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("Return_value", adInteger, adParamReturnValue, 10, 0)
    End If
    If Len(p_vlstrParametros) > 0 Then
      For i = 1 To Len(p_vlstrParametros) + 1
      'Busca el valor del parametro
        If (Mid(p_vlstrParametros, i, 1) <> "|") And (Len(p_vlstrParametros) >= i) Then
          vlstrValParam = vlstrValParam & Mid(p_vlstrParametros, i, 1)
        Else
          'Crea y carga el parametro en el Command
          Set vlprmNameParam = vlcmdCommand.CreateParameter(, adBSTR, adParamInput, , vlstrValParam)
          vlcmdCommand.Parameters.Append vlprmNameParam
          vlstrNumParam = vlstrNumParam & "?,"
          vlstrParJuntos = vlstrParJuntos & vlstrValParam & ","
          vlstrValParam = ""
        End If
      Next i
      'Elimina la coma final
      vlstrNumParam = Mid(vlstrNumParam, 1, (Len(vlstrNumParam) - 1))
      vlstrParJuntos = Mid(vlstrParJuntos, 1, (Len(vlstrParJuntos) - 1))
    End If
    
    With vlcmdCommand
      .CommandType = adCmdStoredProc
       Set .ActiveConnection = EntornoSIHO.ConeccionSIHO
      .CommandText = p_vlstrSP
    End With
    'Ciclo que carga los parametros de salida
    If IsArray(vlaryParametrosSalida) Then
        For vlintRenglonArreglo = 0 To UBound(vlaryParametrosSalida, 2) - 1
            '************************* N O T A   I M P O R T A N T E ***********************
            'Dado que el WorkBench creo los SP que tenian parámetros de salida como "IN OUT"
            'independientemente de si eran solo de salida, se asume que ningún SP tiene
            'parámetros solo "OUT", si este procedimiento genera un "error de conversión..."
            'se deben cambiar los parámetros del SP de "OUT" a "IN OUT"
            If vlaryParametrosSalida(1, vlintRenglonArreglo) = "8" Then 'Si es un string se debe especificar el tamaño
                If vlaryParametrosSalida(0, vlintRenglonArreglo) <> "" Then
                    vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("ParametroSalida" & vlintRenglonArreglo, CInt(vlaryParametrosSalida(1, vlintRenglonArreglo)), adParamInputOutput, 4000, vlaryParametrosSalida(0, vlintRenglonArreglo))
                Else
                    vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("ParametroSalida" & vlintRenglonArreglo, CInt(vlaryParametrosSalida(1, vlintRenglonArreglo)), adParamInputOutput, 4000, "x")
                End If
            Else
                If vlaryParametrosSalida(0, vlintRenglonArreglo) <> "" Then
                    vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("ParametroSalida" & vlintRenglonArreglo, CInt(vlaryParametrosSalida(1, vlintRenglonArreglo)), adParamInputOutput, , vlaryParametrosSalida(0, vlintRenglonArreglo))
                Else
                    vlcmdCommand.Parameters.Append vlcmdCommand.CreateParameter("ParametroSalida" & vlintRenglonArreglo, CInt(vlaryParametrosSalida(1, vlintRenglonArreglo)), adParamInputOutput, , 0)
                End If
            End If
        Next vlintRenglonArreglo
    End If
  End If  'Fin oracle
  
  With vlcmdCommand
    If vlblnNORegresaRS Then
        Set vlrsRecordSet = Nothing
       .Execute
    Else
        Set vlrsRecordSet = .Execute()
    End If
    
    vlintNumParams = 0
    'Ciclo que carga los parametros de salida
    If IsArray(vlaryParametrosSalida) Then
        For i = 0 To .Parameters.Count - 1
            If (.Parameters(i).Direction = adParamOutput) Or (.Parameters(i).Direction = adParamInputOutput) Then
                vlaryParametrosSalida(0, vlintNumParams) = .Parameters(i).Value
                vlintNumParams = vlintNumParams + 1
            End If
        Next i
    End If
    
    If vllngValorRegresado = 1 Then
      vllngValorRegresado = .Parameters(0).Value
    End If
  End With
  Set frsEjecuta_SP = vlrsRecordSet
  
   'Le devuelve el timeout a 30
  If vlblnTiempoEspera = True Then
        vlcmdCommand.CommandTimeout = 30
  End If
  
Exit Function
NotificaError:
    vlstrErrorLister = InStr(Err.Description, "TicketError")

    If vlstrErrorLister > 0 Then
'      vlstrErrorLister = 0
'      EntornoSIHO.ConeccionSIHO.RollbackTrans
      MsgBox "No es posible hacer esta operación, ya se ha generado un ticket en la farmacia subrogada.", vbExclamation, "Mensaje"
    Else
        Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":frsEjecuta_SP" & " " & p_vlstrSP), p_vlstrParametros)
    End If
End Function

Public Function flngFormatoDepto(intCveDepto As Integer, intNumFormato As Integer, strTipoPaciente As String) As Long
    'Regresa el número de formato preimpreso que está configurado para el departamento
    Dim rs As New ADODB.Recordset
    
    flngFormatoDepto = 0
    
    vgstrParametrosSP = str(intCveDepto) & "|" & str(intNumFormato) & "|" & strTipoPaciente
    Set rs = frsEjecuta_SP(vgstrParametrosSP, "sp_GnSelFormatoDepto")
    If rs.RecordCount <> 0 Then
        flngFormatoDepto = rs!intNumFormato
    End If
        
End Function

Public Function fblnAsignaImpresora(intCveDepto As Integer, strTipoDocto As String) As Boolean
    'Asigna la impresora configurada al objeto <Printer>
    Dim rs As New ADODB.Recordset
    Dim prtImpresora As Printer
    
    fblnAsignaImpresora = False
    
    vgstrParametrosSP = str(intCveDepto) & "|" & strTipoDocto
    
    Set rs = frsEjecuta_SP(vgstrParametrosSP, "sp_GnSelImpresoraDepto")
    If rs.RecordCount <> 0 Then
        For Each prtImpresora In Printers
            If UCase(Trim(prtImpresora.DeviceName)) = UCase(Trim(rs!chrNombreImpresora)) Then
                 Set Printer = prtImpresora
                 fblnAsignaImpresora = True
                 Exit For
            End If
        Next
    End If
End Function

Public Function flngBloqueaArticulo(vlchrarticulo As String, vlingdepartamento As Integer) As Integer
Dim vllngContinuar As Long
    '-----------------------------------------------------------------------------------------------------------------
    '|Guardar en la tabla IvTmpDeptoArticulo el articulo y el departamento para indicar que esta en una transaccion
    '-----------------------------------------------------------------------------------------------------------------
    vllngContinuar = 1
    vgstrParametrosSP = vlchrarticulo & "|" & vlingdepartamento & "|" & 1
    frsEjecuta_SP vgstrParametrosSP, "Sp_IvUpdTmpDeptoArticulo", True, vllngContinuar
    
    flngBloqueaArticulo = CInt(vllngContinuar)
    
End Function

Public Function flngLiberaArticulo(vlchrarticulo As String, vlingdepartamento As Integer) As Integer
Dim vllngContinuar As Long
    '-----------------------------------------------------------------------------------------------------------------
    '|Guardar en la tabla IvTmpDeptoArticulo el articulo y el departamento para indicar que esta en una transaccion
    '-----------------------------------------------------------------------------------------------------------------
    vllngContinuar = 1
    vgstrParametrosSP = vlchrarticulo & "|" & vlingdepartamento & "|" & 2
    frsEjecuta_SP vgstrParametrosSP, "Sp_IvUpdTmpDeptoArticulo", True, vllngContinuar
    
    flngLiberaArticulo = CInt(vllngContinuar)
    
End Function

'-------------------------------------------------------------------------------------
'|  Función que evalúa si una cadena es nula, y regresa una cadena no nula
'-------------------------------------------------------------------------------------
Public Function fstrIsNull(strCadena As Variant, Optional strReemplazo As String) As String
    Dim strCadenaReemplazo As String
    
    '|  Si no se mandó el parámetro opcional, la cadena de reemplazo será un vacío
    strCadenaReemplazo = IIf(IsNull(strReemplazo), "", strReemplazo)
    fstrIsNull = IIf(IsNull(strCadena), strCadenaReemplazo, strCadena)
End Function

'-------------------------------------------------------------------------------------
'|  Función que evalúa si un número es nulo, y regresa un número no nulo.
'-------------------------------------------------------------------------------------
Public Function fintIsNull(intNumero As Variant, Optional intReemplazo As Integer) As Integer
    Dim intNumeroReemplazo As Integer
    
    '|  Si no se mandó el parámetro opcional, el número de reemplazo será un 0
    intNumeroReemplazo = IIf(IsNull(intReemplazo), 0, intReemplazo)
    fintIsNull = IIf(IsNull(intNumero), intNumeroReemplazo, intNumero)
End Function

'-------------------------------------------------------------------------------
'|  Esta rutina usa un API y abre un cuadro de diálogo para seleccionar
'|  el directorio donde se almacenarán los archivos generados para el IDSE
'-------------------------------------------------------------------------------
Public Function fstrSeleccionaDirectorio(frmForma As Form, strTitulo As String) As String

    Dim lpIDList As Long
    Dim sBuffer As String
    Dim szTitle As String
    Dim tBrowseInfo As BrowseInfo

    szTitle = strTitulo
    With tBrowseInfo
       .hWndOwner = frmForma.hwnd
       .lpszTitle = lstrcat(szTitle, "")
       .ulFlags = BIF_RETURNONLYFSDIRS
       '+ BIF_DONTGOBELOWDOMAIN
    End With

    lpIDList = SHBrowseForFolder(tBrowseInfo)
    fstrSeleccionaDirectorio = ""
    If (lpIDList) Then
       sBuffer = Space(MAX_PATH)
       SHGetPathFromIDList lpIDList, sBuffer
       sBuffer = Left(sBuffer, InStr(sBuffer, vbNullChar) - 1)
       fstrSeleccionaDirectorio = sBuffer
    End If
End Function
Public Function Encode(sString As String) As String

    Dim bTrans(63) As Byte, lPowers8(255) As Long, lPowers16(255) As Long, bOut() As Byte, bIn() As Byte
    Dim lChar As Long, lTrip As Long, iPad As Integer, lLen As Long, lTemp As Long, lPos As Long, lOutSize As Long
    
    For lTemp = 0 To 63                                 'Fill the translation table.
        Select Case lTemp
            Case 0 To 25
                bTrans(lTemp) = 65 + lTemp              'A - Z
            Case 26 To 51
                bTrans(lTemp) = 71 + lTemp              'a - z
            Case 52 To 61
                bTrans(lTemp) = lTemp - 4               '1 - 0
            Case 62
                bTrans(lTemp) = 43                      'Chr(43) = "+"
            Case 63
                bTrans(lTemp) = 47                      'Chr(47) = "/"
        End Select
    Next lTemp

    For lTemp = 0 To 255                                'Fill the 2^8 and 2^16 lookup tables.
        lPowers8(lTemp) = lTemp * cl2Exp8
        lPowers16(lTemp) = lTemp * cl2Exp16
    Next lTemp

    iPad = Len(sString) Mod 3                           'See if the length is divisible by 3
    If iPad Then                                        'If not, figure out the end pad and resize the input.
        iPad = 3 - iPad
        sString = sString & String(iPad, Chr(0))
    End If

    bIn = StrConv(sString, vbFromUnicode)               'Load the input string.
    lLen = ((UBound(bIn) + 1) \ 3) * 4                  'Length of resulting string.
    lTemp = lLen \ 72                                   'Added space for vbCrLfs.
    lOutSize = ((lTemp * 2) + lLen) - 1                 'Calculate the size of the output buffer.
    ReDim bOut(lOutSize)                                'Make the output buffer.
    
    lLen = 0                                            'Reusing this one, so reset it.
    
    For lChar = LBound(bIn) To UBound(bIn) Step 3
        lTrip = lPowers16(bIn(lChar)) + lPowers8(bIn(lChar + 1)) + bIn(lChar + 2)    'Combine the 3 bytes
        lTemp = lTrip And clOneMask                     'Mask for the first 6 bits
        bOut(lPos) = bTrans(lTemp \ cl2Exp18)           'Shift it down to the low 6 bits and get the value
        lTemp = lTrip And clTwoMask                     'Mask for the second set.
        bOut(lPos + 1) = bTrans(lTemp \ cl2Exp12)       'Shift it down and translate.
        lTemp = lTrip And clThreeMask                   'Mask for the third set.
        bOut(lPos + 2) = bTrans(lTemp \ cl2Exp6)        'Shift it down and translate.
        bOut(lPos + 3) = bTrans(lTrip And clFourMask)   'Mask for the low set.
        If lLen = 68 Then                               'Ready for a newline
            bOut(lPos + 4) = 13                         'Chr(13) = vbCr
            bOut(lPos + 5) = 10                         'Chr(10) = vbLf
            lLen = 0                                    'Reset the counter
            lPos = lPos + 6
        Else
            lLen = lLen + 4
            lPos = lPos + 4
        End If
    Next lChar
    
    If bOut(lOutSize) = 10 Then lOutSize = lOutSize - 2 'Shift the padding chars down if it ends with CrLf.
    
    If iPad = 1 Then                                    'Add the padding chars if any.
        bOut(lOutSize) = 61                             'Chr(61) = "="
    ElseIf iPad = 2 Then
        bOut(lOutSize) = 61
        bOut(lOutSize - 1) = 61
    End If
    
    Encode = StrConv(bOut, vbUnicode)                 'Convert back to a string and return it.
    
End Function

Public Function Decode(sString As String) As String

    Dim bOut() As Byte, bIn() As Byte, bTrans(255) As Byte, lPowers6(63) As Long, lPowers12(63) As Long
    Dim lPowers18(63) As Long, lQuad As Long, iPad As Integer, lChar As Long, lPos As Long, sOut As String
    Dim lTemp As Long

    sString = Replace(sString, vbCr, vbNullString)      'Get rid of the vbCrLfs.  These could be in...
    sString = Replace(sString, vbLf, vbNullString)      'either order.

    lTemp = Len(sString) Mod 4                          'Test for valid input.
    If lTemp Then
        Call Err.Raise(vbObjectError, "MyDecode", "Vigencia SiHO alterada o no válida")
    End If
    
    If InStrRev(sString, "==") Then                     'InStrRev is faster when you know it's at the end.
        iPad = 2                                        'Note:  These translate to 0, so you can leave them...
    ElseIf InStrRev(sString, "=") Then                  'in the string and just resize the output.
        iPad = 1
    End If
     
    For lTemp = 0 To 255                                'Fill the translation table.
        Select Case lTemp
            Case 65 To 90
                bTrans(lTemp) = lTemp - 65              'A - Z
            Case 97 To 122
                bTrans(lTemp) = lTemp - 71              'a - z
            Case 48 To 57
                bTrans(lTemp) = lTemp + 4               '1 - 0
            Case 43
                bTrans(lTemp) = 62                      'Chr(43) = "+"
            Case 47
                bTrans(lTemp) = 63                      'Chr(47) = "/"
        End Select
    Next lTemp

    For lTemp = 0 To 63                                 'Fill the 2^6, 2^12, and 2^18 lookup tables.
        lPowers6(lTemp) = lTemp * cl2Exp6
        lPowers12(lTemp) = lTemp * cl2Exp12
        lPowers18(lTemp) = lTemp * cl2Exp18
    Next lTemp

    bIn = StrConv(sString, vbFromUnicode)               'Load the input byte array.
    ReDim bOut((((UBound(bIn) + 1) \ 4) * 3) - 1)       'Prepare the output buffer.
    
    For lChar = 0 To UBound(bIn) Step 4
        lQuad = lPowers18(bTrans(bIn(lChar))) + lPowers12(bTrans(bIn(lChar + 1))) + _
                lPowers6(bTrans(bIn(lChar + 2))) + bTrans(bIn(lChar + 3))           'Rebuild the bits.
        lTemp = lQuad And clHighMask                    'Mask for the first byte
        bOut(lPos) = lTemp \ cl2Exp16                   'Shift it down
        lTemp = lQuad And clMidMask                     'Mask for the second byte
        bOut(lPos + 1) = lTemp \ cl2Exp8                'Shift it down
        bOut(lPos + 2) = lQuad And clLowMask            'Mask for the third byte
        lPos = lPos + 3
    Next lChar

    sOut = StrConv(bOut, vbUnicode)                     'Convert back to a string.
    If iPad Then sOut = Left$(sOut, Len(sOut) - iPad)   'Chop off any extra bytes.
    Decode = sOut

End Function


Public Sub Main()

    On Error GoTo NotificaError
    vglngTerminalServerSessionId = TerminalServerSessionId
    pSetDefaultSystemPrinter
    EntornoSIHO.ConeccionSIHO.Open fstrRegresaConeccion
    If Not blnSLC Then End
    '| Compara la fecha del equipo local con la del servidor y si la diferencia es mayor a 5 minutos envía mensaje de alerta
    If Abs((Now() - fdtmServerFechaHora) * 24 * 60) > 5 Then
        If MsgBox("La hora de este equipo no está sincronizada con la hora del servidor." & vbCrLf & "Favor de avisar al área de sistemas." & vbCrLf & "¿Desea continuar?", vbExclamation + vbYesNo, "Mensaje") = vbNo Then
            End
        End If
    End If

    frmLogin.Show

NotificaError:
  If Err.Number <> 0 Then
    If (Err.Number = -2147467259 Or Err.Number = -2147217887) And Not vgblnTerminate Then
      vgblnVieneError = True
      MsgBox Err.Description, vbCritical, "Mensaje"
      frmConeccion.Show vbModal
      If Not vgblnTerminate Then
        Main
      Else
        End
      End If
    Else
      End
    End If
  End If

End Sub

Public Function pMostrarAyuda(strAyuda As String) As Integer
 Dim hwnd
   Dim StartDoc
   pMostrarAyuda = shellexecute(0, "open", strAyuda, "", App.Path, SW_SHOWNORMAL)
End Function

Private Function blnSLC() As Boolean
    Dim intObjetos As Integer
    Dim vlstrSentencia As String
    Dim SLC As Object
    Dim rs As ADODB.Recordset
    If vgstrBaseDatosUtilizada = "ORACLE" Then
        vlstrSentencia = "select sequence_name from all_sequences where sequence_name = 'SEC_SICCONTROL'"
        Set rs = EntornoSIHO.ConeccionSIHO.Execute(vlstrSentencia)
        If Not rs.EOF Then
            intObjetos = intObjetos + 1
        End If
        rs.Close
        vlstrSentencia = "select sequence_name from all_sequences where sequence_name = 'SEC_SICONTINUA'"
        Set rs = EntornoSIHO.ConeccionSIHO.Execute(vlstrSentencia)
        If Not rs.EOF Then
            intObjetos = intObjetos + 1
        End If
        rs.Close
        vlstrSentencia = "select table_name from all_tables where table_name = 'ADACTIVADO'"
        Set rs = EntornoSIHO.ConeccionSIHO.Execute(vlstrSentencia)
        If Not rs.EOF Then
            intObjetos = intObjetos + 1
        End If
        rs.Close
        vlstrSentencia = "select table_name from all_tables where table_name = 'ADINICIO'"
        Set rs = EntornoSIHO.ConeccionSIHO.Execute(vlstrSentencia)
        If Not rs.EOF Then
            intObjetos = intObjetos + 1
        End If
        rs.Close
        vlstrSentencia = "select table_name from all_tables where table_name = 'EXSALIDA'"
        Set rs = EntornoSIHO.ConeccionSIHO.Execute(vlstrSentencia)
        If Not rs.EOF Then
            intObjetos = intObjetos + 1
        End If
        rs.Close
        If intObjetos = 0 Then
           blnSLC = True
           Exit Function
        End If
        On Error Resume Next
        Set SLC = CreateObject("SLCServer.Licence")
        If Err.Number <> 0 Then
            blnSLC = False
            Exit Function
        End If
        If SLC.isValid("tusocioeninformatica.com") = "101116053054110050087113" & fstrConvierteChr("051052052053102055114") Then
            blnSLC = True
        Else
            blnSLC = False
        End If
    Else
        blnSLC = True
    End If
End Function

Public Sub pImpFormato(rsDatos As Recordset, intIdTipoFormato As Integer, lngIdFormato As Long)
    Dim rsFormato As New ADODB.Recordset
    
    Dim strSentencia As String
    Dim strDato As String
    
    Dim intcontador As Integer
    Dim intImpresiones As Integer
    Dim intCuentaColumna As Integer
    Dim intRenglon As Integer
    Dim intColumna As Integer
    Dim intAncho As Integer
    Dim intLargo As Integer
    Dim intMaximoRenglon As Integer
    
    Dim blnColEncontrada As Boolean
    Dim blnerror As Boolean

    If rsDatos.RecordCount = 0 Then Exit Sub
    EntornoSIHO.ConeccionSIHO.BeginTrans
    
    '-----------------------------------------------------------------
    '1.- Vaciar las columnas del RS en una tabla temporal <#GnColumna>
    '-----------------------------------------------------------------
    strSentencia = "delete from GnColumnatemporal"
    pEjecutaSentencia strSentencia
    
    intcontador = 0
    Do While intcontador <= rsDatos.Fields.Count - 1
        strSentencia = "insert into GnColumnatemporal values ('" & rsDatos.Fields(intcontador).Name & "')"
        pEjecutaSentencia strSentencia
        intcontador = intcontador + 1
    Loop
        
    '-----------------------------------------------------------------
    '2.- Cargar los datos del formato preimpreso
    '-----------------------------------------------------------------
    vgstrParametrosSP = str(intIdTipoFormato) & "|" & str(lngIdFormato)
    Set rsFormato = frsEjecuta_SP(vgstrParametrosSP, "sp_GnSelFormato")
    If rsFormato.RecordCount <> 0 Then
        'Impresión del formato
        
        intMaximoRenglon = 0
    
        intLargo = CInt(rsFormato!intLargo)
        intAncho = CInt(rsFormato!intAncho)
    
        Printer.ScaleMode = vbCharacters
        Printer.Font.Name = rsFormato!vchFont
        Printer.Font.Size = rsFormato!INTLETRA
        
        intCuentaColumna = 0
        Do While intCuentaColumna <= rsDatos.Fields.Count - 1
        
            blnColEncontrada = False
            rsFormato.MoveFirst
            Do While Not rsFormato.EOF And Not blnColEncontrada
                If Trim(UCase(rsDatos.Fields(intCuentaColumna).Name)) = Trim(UCase(rsFormato!vchColumna)) Then
                    
                    intImpresiones = IIf(rsFormato!chrEstatusMaestroDetalle = "M", 0, rsDatos.RecordCount - 1)
                    
                    intRenglon = rsFormato!intCoordenadaY
                    intColumna = rsFormato!intCoordenadaX
                    
                    blnerror = False
                    rsDatos.MoveFirst
                    intcontador = 0
                    Do While intcontador <= intImpresiones And Not blnerror
                        If Not (intRenglon > intLargo And intLargo <> 0) Then
                            If Not (intColumna > intAncho And intAncho <> 0) Then
                                Printer.CurrentX = intColumna
                                Printer.CurrentY = intRenglon
                                            
                                If intRenglon > intMaximoRenglon Then
                                    intMaximoRenglon = intRenglon
                                End If
                            
                                Select Case rsFormato!chrTipoDato
                                Case "A"    'alfanumérico
                                    strDato = rsDatos.Fields(intCuentaColumna)
                                Case "M"    'moneda
                                    strDato = Space(14 - Len(Format(rsDatos.Fields(intCuentaColumna), "$##,###,###.00"))) & Format(rsDatos.Fields(intCuentaColumna), "$##,###,###.00")
                                Case "N"    'numérico
                                    strDato = Format(rsDatos.Fields(intCuentaColumna), "###########")
                                Case "F"    'fecha
                                    strDato = Format(rsDatos.Fields(intCuentaColumna), "dd/mmm/yyyy")
                                End Select
                                If intColumna + Len(strDato) > intAncho And intAncho <> 0 Then
                                    strDato = Mid(strDato, 1, intAncho - intColumna)
                                End If

                                On Error Resume Next
                                Printer.Print strDato
                                If Err.Number <> 0 Then
                                    EntornoSIHO.ConeccionSIHO.RollbackTrans
                                    Exit Sub
                                End If
                                
                            Else
                                'la columna excede el ancho del formato
                                blnerror = True
                            End If
                        Else
                            'el renglón excede las líneas del formato
                            blnerror = True
                        End If
                        intcontador = intcontador + 1
                        intRenglon = intRenglon + 1
                        rsDatos.MoveNext
                    Loop
                    blnColEncontrada = True
                End If
                rsFormato.MoveNext
            Loop
            intCuentaColumna = intCuentaColumna + 1
        Loop
    
        If intLargo > 0 And intMaximoRenglon < intLargo Then
            For intcontador = intMaximoRenglon + 1 To intLargo
                Printer.CurrentY = intcontador
                Printer.CurrentX = 1
                Printer.Print "  "
            Next intcontador
        End If
        Printer.EndDoc
    Else
        'No existe contenido para el tipo de formato.
        MsgBox SIHOMsg(271), vbExclamation + vbOKOnly, "Mensaje"
    End If
    rsFormato.Close
    EntornoSIHO.ConeccionSIHO.CommitTrans
End Sub

Public Sub pCuartosActuales()
    On Error GoTo NotificaError
    Dim rs As ADODB.Recordset
    Dim intNoCensables As Integer
    Dim intCensables As Integer
    gintNumeroCuartosNoCensablesActuales = 0
    gintNumeroCuartosCensablesActuales = 0
    Set rs = frsRegresaRs("select count(*) from ADCuarto where intCensable <> 0 and tnyCveEstadoCuarto = " & vglngCveEstadoCuartoOcupado)
    If Not rs.EOF Then
        gintNumeroCuartosNoCensablesActuales = rs.Fields(0).Value
    End If
    rs.Close
    Set rs = frsRegresaRs("select count(*) from ADCuarto where intCensable = 0 and tnyCveEstadoCuarto = " & vglngCveEstadoCuartoOcupado)
      If Not rs.EOF Then
        gintNumeroCuartosCensablesActuales = rs.Fields(0).Value
    End If
    rs.Close
    Exit Sub
NotificaError:
     Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pCuartosActuales"))
End Sub

Public Function fblnVerficaLicenciaCuartos(strNumCuarto As String) As Boolean
    Dim rs As ADODB.Recordset
    Dim strSql As String
    Dim blnCensable As Boolean
    fblnVerficaLicenciaCuartos = True
    If strNumCuarto <> "" Then
        pCuartosActuales
        strSql = "select * from ADCuarto where vchNumCuarto = '" & strNumCuarto & "'"
        Set rs = frsRegresaRs(strSql)
        If Not rs.EOF Then
            blnCensable = rs!intCensable
        End If
        rs.Close
    End If
    '0=Censable
    '1=No censable
    If Not blnCensable Or strNumCuarto = "" Then
        If gintNumeroCuartosCensablesPermitidos > -1 Then
            If gintNumeroCuartosCensablesActuales >= gintNumeroCuartosCensablesPermitidos Then
                fblnVerficaLicenciaCuartos = False
            End If
        End If
    End If
    
End Function
Public Function fblnVerficaLicenciaCuartosexternos(strNumCuarto As String) As Boolean
    Dim rs As ADODB.Recordset
    Dim strSql As String
    Dim blnCensable As Boolean
    fblnVerficaLicenciaCuartosexternos = True
    If strNumCuarto <> "" Then
        pCuartosActuales
        strSql = "select * from ADCuarto where vchNumCuarto = '" & strNumCuarto & "'"
        Set rs = frsRegresaRs(strSql)
        If Not rs.EOF Then
            blnCensable = rs!intCensable
        End If
        rs.Close
    End If

    If blnCensable Or strNumCuarto = "" Then
        If gintNumeroCuartosNoCensablesPermitidos > -1 Then
            If gintNumeroCuartosNoCensablesActuales >= gintNumeroCuartosNoCensablesPermitidos Then
                fblnVerficaLicenciaCuartosexternos = False
            End If
        End If
    End If

End Function

Public Function fstrMesLetra(intMes As Integer, blnCompleto As Boolean) As String
    On Error GoTo NotificaError
    
    Select Case intMes
        Case 1
            fstrMesLetra = IIf(blnCompleto, "Enero", "Ene")
        Case 2
            fstrMesLetra = IIf(blnCompleto, "Febrero", "Feb")
        Case 3
            fstrMesLetra = IIf(blnCompleto, "Marzo", "Mar")
        Case 4
            fstrMesLetra = IIf(blnCompleto, "Abril", "Abr")
        Case 5
            fstrMesLetra = IIf(blnCompleto, "Mayo", "May")
        Case 6
            fstrMesLetra = IIf(blnCompleto, "Junio", "Jun")
        Case 7
            fstrMesLetra = IIf(blnCompleto, "Julio", "Jul")
        Case 8
            fstrMesLetra = IIf(blnCompleto, "Agosto", "Ago")
        Case 9
            fstrMesLetra = IIf(blnCompleto, "Septiembre", "Sep")
        Case 10
            fstrMesLetra = IIf(blnCompleto, "Octubre", "Oct")
        Case 11
            fstrMesLetra = IIf(blnCompleto, "Noviembre", "Nov")
        Case 12
            fstrMesLetra = IIf(blnCompleto, "Diciembre", "Dic")
    End Select

    Exit Function
NotificaError:
     Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrMesLetra"))
End Function

Public Function fdblPrintZPL(strArgs As String) As Double
    Dim lngResult As Long
    lngResult = shellexecute(0, "open", "java.exe", "PrintZPL " & strArgs, App.Path, SW_HIDE)
End Function

Public Sub pImprimeFormatoProc(lngNumeroFormato As Long, lngRenglonesDetalle As Long, lngTotalDocumentos As Long, rsDatos As ADODB.Recordset, arrFolios() As String)
    On Error GoTo NotificaError
    Dim colTotales As New Collection
    Dim colVariables As New Collection
    Dim lngIndex As Integer
    Dim intCicloFinal As Integer
    Dim intRegistroActual As Integer
    Dim blnSalir As Boolean
    Dim blnTotales As Boolean
    Dim rsContenidoFormato As New ADODB.Recordset
    Dim strCadenaImprimir As String
    Dim lngRenglon As Long
    Dim lngColumna As Long
    Dim dblAcumulados As Double
    Dim intLongitudArray As Integer
    Dim intLongitudCampo As Integer
    Dim strCadenaEspacios As String
    Dim strCadenaInicial As String
    Dim strCadenaFinal As String
    Dim intContadorCicloEspacios As Integer
    
    Set rsContenidoFormato = frsEjecuta_SP(CStr(lngNumeroFormato), "sp_PVSelFormato")
    If Not rsContenidoFormato.EOF Then
        Do Until rsContenidoFormato.EOF
            rsContenidoFormato.MoveNext
        Loop
        For lngIndex = 1 To lngTotalDocumentos
            rsContenidoFormato.MoveFirst
            blnSalir = False
            intRegistroActual = 0
            intLongitudArray = 0
            intLongitudCampo = 0
            ReDim aMontos(0)
            blnTotales = False
            'Prepara impresora
            If lngIndex = 1 Then
                Printer.ScaleMode = vbCharacters
                Printer.Font.Name = rsContenidoFormato!vchFont
                Printer.Font.Size = rsContenidoFormato!INTLETRA
            End If
            Do Until rsDatos.EOF Or blnSalir
                intRegistroActual = intRegistroActual + 1
                If lngIndex = 1 And intRegistroActual = 1 Then
                    Do Until rsContenidoFormato.EOF
                        'Variables, no se imprimen, se envian a funciones de formato
                        If rsContenidoFormato!chrEstatusMaestroDetalle = "V" Then
                            colVariables.Add IIf(IsNull(rsDatos.Fields(rsContenidoFormato.Fields("vchColumna").Value).Value), "", rsDatos.Fields(rsContenidoFormato.Fields("vchColumna").Value).Value), rsContenidoFormato!vchSentencia
                        End If
                        rsContenidoFormato.MoveNext
                    Loop
                End If
                rsContenidoFormato.MoveFirst
                Do Until rsContenidoFormato.EOF
                    strCadenaImprimir = ""
                    lngColumna = rsContenidoFormato!intCoordenadaX
                    lngRenglon = rsContenidoFormato!intCoordenadaY
                    'Incremento de totales
                    If rsContenidoFormato!chrEstatusMaestroDetalle = "S" Or rsContenidoFormato!chrEstatusMaestroDetalle = "T" Or rsContenidoFormato!chrEstatusMaestroDetalle = "A" Then
                        If lngIndex = 1 And intRegistroActual = 1 Then
                            colTotales.Add 0, "K_" & rsContenidoFormato!intNumeroContenidoFormato
                        End If
                        If intRegistroActual = 1 And (rsContenidoFormato!chrEstatusMaestroDetalle = "S" Or rsContenidoFormato!chrEstatusMaestroDetalle = "A") Then
                            colTotales.Remove ("K_" & rsContenidoFormato!intNumeroContenidoFormato)
                            colTotales.Add 0, "K_" & rsContenidoFormato!intNumeroContenidoFormato
                        End If
                        dblAcumulados = colTotales("K_" & rsContenidoFormato!intNumeroContenidoFormato)
                        dblAcumulados = dblAcumulados + IIf(IsNull(rsDatos.Fields(rsContenidoFormato.Fields("vchColumna").Value).Value), 0, rsDatos.Fields(rsContenidoFormato.Fields("vchColumna").Value).Value)
                        colTotales.Remove ("K_" & rsContenidoFormato!intNumeroContenidoFormato)
                        colTotales.Add dblAcumulados, "K_" & rsContenidoFormato!intNumeroContenidoFormato
                    End If
                    'Seccion maestro
                    If intRegistroActual = 1 Then
                        If rsContenidoFormato!chrEstatusMaestroDetalle = "M" Or rsContenidoFormato!chrEstatusMaestroDetalle = "P" Or rsContenidoFormato!chrEstatusMaestroDetalle = "U" Then
                            If rsContenidoFormato!chrEstatusContenido = "T" Then
                                strCadenaImprimir = rsContenidoFormato!vchSentencia
                            End If
                            If rsContenidoFormato!chrEstatusContenido = "D" Then
                                strCadenaImprimir = IIf(IsNull(rsDatos.Fields(rsContenidoFormato.Fields("vchColumna").Value).Value), "", rsDatos.Fields(rsContenidoFormato.Fields("vchColumna").Value).Value)
                            End If
                            If rsContenidoFormato!chrEstatusContenido = "M" Then
                                strCadenaImprimir = lngTotalDocumentos
                            End If
                            If rsContenidoFormato!chrEstatusContenido = "N" Then
                                strCadenaImprimir = lngIndex
                            End If
                            If rsContenidoFormato!chrEstatusContenido = "A" Then
                                strCadenaImprimir = arrFolios(lngIndex)
                            End If
                            If rsContenidoFormato!chrEstatusContenido = "I" Then
                                strCadenaImprimir = arrFolios(1)
                            End If
                            If rsContenidoFormato!chrEstatusContenido = "F" Then
                                strCadenaImprimir = arrFolios(UBound(arrFolios, 1))
                            End If
                            If rsContenidoFormato!chrEstatusMaestroDetalle = "P" And lngIndex > 1 Then
                                strCadenaImprimir = ""
                            End If
                            If rsContenidoFormato!chrEstatusMaestroDetalle = "U" And lngIndex < lngTotalDocumentos Then
                                strCadenaImprimir = ""
                            End If
                        End If
                    End If
                    'Seccion detalle
                    If rsContenidoFormato!chrEstatusMaestroDetalle = "D" Then
                        lngRenglon = lngRenglon + intRegistroActual - 1
                        If rsContenidoFormato!chrEstatusContenido = "T" Then
                            strCadenaImprimir = rsContenidoFormato!vchSentencia
                        End If
                        If rsContenidoFormato!chrEstatusContenido = "D" Then
                            strCadenaImprimir = IIf(IsNull(rsDatos.Fields(rsContenidoFormato.Fields("vchColumna").Value).Value), "", rsDatos.Fields(rsContenidoFormato.Fields("vchColumna").Value).Value)
                        End If
                    End If
                    If strCadenaImprimir <> "" Then
                        'Aplica formato
                        Select Case Trim(rsContenidoFormato!vchFuncionFormato)
                            Case "Format"
                                strCadenaImprimir = Format(strCadenaImprimir, rsContenidoFormato!vchFormato)
                            Case "fstrNumeroenLetras"
                                strCadenaImprimir = fstrNumeroenLetras(CDbl(strCadenaImprimir), colVariables("MONEDA"), colVariables("AGREGADOMONEDA"))
                            Case "fstrNumeroJustificado"
                                strCadenaImprimir = fstrNumeroJustificado(CDbl(strCadenaImprimir), 14)
                            Case "fstrNumeroJustificado/Espacio"
                                If strCadenaImprimir = "0" Then
                                    strCadenaImprimir = " "
                                Else
                                    strCadenaImprimir = fstrNumeroJustificado(CDbl(strCadenaImprimir), 14)
                                End If
                            Case "fstrNumeroJustificadoFormato"
                                strCadenaImprimir = fstrNumeroJustificadoFormato(IIf(IsNull(CDbl(strCadenaImprimir)), 0, CDbl(strCadenaImprimir)), Trim(rsContenidoFormato!vchFormato))
                            Case "fstrNdeM"
                                strCadenaImprimir = Trim(strCadenaImprimir) & " " & lngIndex & " de " & lngTotalDocumentos
                            Case "fstrNdeMU"
                                strCadenaImprimir = Trim(strCadenaImprimir) & " " & lngIndex & " DE " & lngTotalDocumentos
                            Case "fstrdelNalM"
                                strCadenaImprimir = Trim(strCadenaImprimir) & " del " & arrFolios(1) & " al " & arrFolios(UBound(arrFolios, 1))
                            Case "fstrdelNalMU"
                                strCadenaImprimir = Trim(strCadenaImprimir) & " DEL " & arrFolios(1) & " AL " & arrFolios(UBound(arrFolios, 1))
                        End Select
                        
                        If ((Left(rsContenidoFormato!vchFormato, 1) = "$") And (rsContenidoFormato!intNumeroTipoFormato = 2)) Then
                            intLongitudArray = intLongitudArray + 1
                            ReDim Preserve aMontos(intLongitudArray)
                            aMontos(intLongitudArray).lngX = lngColumna
                            aMontos(intLongitudArray).lngY = lngRenglon
                            aMontos(intLongitudArray).strPorImprimir = strCadenaImprimir
                            If (Len(strCadenaImprimir) > intLongitudCampo) Then
                                intLongitudCampo = Len(strCadenaImprimir)
                            End If
                            strCadenaImprimir = ""
                        End If
                        
                        'Corta al ancho establecido
                        If Not IsNull(rsContenidoFormato!intAnchoContenido) Then
                            If Int(rsContenidoFormato!intAnchoContenido) > 0 And rsContenidoFormato!intAnchoContenido < Len(Trim(strCadenaImprimir)) Then
                                strCadenaImprimir = Mid(strCadenaImprimir, 1, rsContenidoFormato!intAnchoContenido)
                            End If
                        End If
                        'Imprime
                        If strCadenaImprimir <> "" Then
                            Printer.CurrentY = lngRenglon
                            Printer.CurrentX = lngColumna
                            Printer.Print strCadenaImprimir
                        End If
                    End If
                    rsContenidoFormato.MoveNext
                Loop
                If intRegistroActual = lngRenglonesDetalle Then
                    blnSalir = True
                End If
                rsDatos.MoveNext
            Loop
            rsContenidoFormato.MoveFirst
            'Totales
            Do Until rsContenidoFormato.EOF
                strCadenaImprimir = ""
                lngColumna = rsContenidoFormato!intCoordenadaX
                lngRenglon = rsContenidoFormato!intCoordenadaY
                'Seccion subtotales
                If rsContenidoFormato!chrEstatusMaestroDetalle = "S" Or rsContenidoFormato!chrEstatusMaestroDetalle = "A" Then
                    strCadenaImprimir = CStr(colTotales("K_" & rsContenidoFormato!intNumeroContenidoFormato))
                    If rsContenidoFormato!chrEstatusMaestroDetalle = "S" And lngIndex = lngTotalDocumentos Then
                        strCadenaImprimir = ""
                    End If
                End If
                'Seccion totales
                If lngIndex = lngTotalDocumentos Then
                    If rsContenidoFormato!chrEstatusMaestroDetalle = "T" Then
                       strCadenaImprimir = CStr(colTotales("K_" & rsContenidoFormato!intNumeroContenidoFormato))
                    End If
                End If
                If strCadenaImprimir <> "" Then
                    'Aplica formato
                    Select Case Trim(rsContenidoFormato!vchFuncionFormato)
                        Case "Format"
                            strCadenaImprimir = Format(strCadenaImprimir, rsContenidoFormato!vchFormato)
                        Case "fstrNumeroenLetras"
                            strCadenaImprimir = fstrNumeroenLetras(CDbl(strCadenaImprimir), colVariables("MONEDA"), colVariables("AGREGADOMONEDA"))
                        Case "fstrNumeroJustificado"
                            strCadenaImprimir = fstrNumeroJustificado(CDbl(strCadenaImprimir), 14)
                        Case "fstrNumeroJustificado/Espacio"
                            If strCadenaImprimir = "0" Then
                                strCadenaImprimir = " "
                            Else
                                strCadenaImprimir = fstrNumeroJustificado(CDbl(strCadenaImprimir), 14)
                            End If
                        Case "fstrNumeroJustificadoFormato"
                            strCadenaImprimir = fstrNumeroJustificadoFormato(IIf(IsNull(CDbl(strCadenaImprimir)), 0, CDbl(strCadenaImprimir)), Trim(rsContenidoFormato!vchFormato))
                        Case "fstrNdeM"
                            strCadenaImprimir = Trim(strCadenaImprimir) & " " & lngIndex & " de " & lngTotalDocumentos
                        Case "fstrNdeMU"
                            strCadenaImprimir = Trim(strCadenaImprimir) & " " & lngIndex & " DE " & lngTotalDocumentos
                        Case "fstrdelNalM"
                            strCadenaImprimir = Trim(strCadenaImprimir) & " del " & arrFolios(1) & " al " & arrFolios(UBound(arrFolios, 1))
                        Case "fstrdelNalMU"
                            strCadenaImprimir = Trim(strCadenaImprimir) & " DEL " & arrFolios(1) & " AL " & arrFolios(UBound(arrFolios, 1))
                    End Select
                    
                    If ((Left(rsContenidoFormato!vchFormato, 1) = "$") And (rsContenidoFormato!intNumeroTipoFormato = 2)) Then
                        intLongitudArray = intLongitudArray + 1
                        ReDim Preserve aMontos(intLongitudArray)
                        aMontos(intLongitudArray).lngX = lngColumna
                        aMontos(intLongitudArray).lngY = lngRenglon
                        aMontos(intLongitudArray).strPorImprimir = strCadenaImprimir
                        If (Len(strCadenaImprimir) > intLongitudCampo) Then
                            intLongitudCampo = Len(strCadenaImprimir)
                        End If
                        strCadenaImprimir = ""
                    End If

                    'Corta al ancho establecido
                    If Not IsNull(rsContenidoFormato!intAnchoContenido) Then
                        If Int(rsContenidoFormato!intAnchoContenido) > 0 And rsContenidoFormato!intAnchoContenido < Len(Trim(strCadenaImprimir)) Then
                            strCadenaImprimir = Mid(strCadenaImprimir, 1, rsContenidoFormato!intAnchoContenido)
                        End If
                    End If
                    'Imprime
                    If strCadenaImprimir <> "" Then
                        Printer.CurrentY = lngRenglon
                        Printer.CurrentX = lngColumna
                        Printer.Print strCadenaImprimir
                    End If
                End If
                rsContenidoFormato.MoveNext
            Loop
            'Imprime valores currency justificados
            For intCicloFinal = 1 To intLongitudArray
                strCadenaEspacios = ""
                
                Printer.CurrentX = aMontos(intCicloFinal).lngX
                Printer.CurrentY = aMontos(intCicloFinal).lngY
                
                strCadenaInicial = Left$(aMontos(intCicloFinal).strPorImprimir, 1)
                
                For intContadorCicloEspacios = 1 To (((intLongitudCampo) - (Len(aMontos(intCicloFinal).strPorImprimir))) + 1)
                    strCadenaEspacios = strCadenaEspacios & " "
                Next
                
                strCadenaFinal = Right$(aMontos(intCicloFinal).strPorImprimir, (Len(aMontos(intCicloFinal).strPorImprimir) - 2))
                
                Printer.Print strCadenaInicial & strCadenaEspacios & strCadenaFinal
            Next
            'Fin Documento
            Printer.EndDoc
        Next
    End If
    rsContenidoFormato.Close
    rsDatos.Close
    Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pImprimeFormatoProc"))
End Sub

Public Function fblnObtieneDatosFormatoProc(lngNumeroFormato As Long, lngIdentificador As Long, ByRef lngRenglonesDetalle As Long, ByRef lngTotalDocumentos As Long, ByRef rsDatos As ADODB.Recordset) As Boolean
    Dim blnFormatoProc As Boolean
    Dim rsFormato As ADODB.Recordset
    Dim lngTotalRenglones As Long
    Dim strFormatoSP As String
    blnFormatoProc = False
    lngTotalDocumentos = 0
    lngRenglonesDetalle = 0
    Set rsFormato = frsRegresaRs("select * from Formato inner join TipoFormato on TipoFormato.intNumeroTipoFormato = Formato.intNumeroTipoFormato where intNumeroFormato = " & lngNumeroFormato)
    If Not rsFormato.EOF Then
        If IIf(IsNull(rsFormato!bitAgruparCargos), 0, rsFormato!bitAgruparCargos) <> 0 Then
            strFormatoSP = rsFormato!VCHPROCEDIMIENTO
            lngRenglonesDetalle = rsFormato!intRenglonesDetalle
            Set rsDatos = frsEjecuta_SP(CStr(lngIdentificador), strFormatoSP)
            If Not rsDatos.EOF Then
                lngTotalRenglones = rsDatos.RecordCount
                lngTotalDocumentos = (lngTotalRenglones \ lngRenglonesDetalle) + IIf((lngTotalRenglones Mod lngRenglonesDetalle) > 0, 1, 0)
            End If
            blnFormatoProc = True
        Else
            lngTotalDocumentos = 1
            blnFormatoProc = False
        End If
    End If
    rsFormato.Close
    fblnObtieneDatosFormatoProc = blnFormatoProc
End Function

Public Sub pImprimeFormato(vllngxNumeroFormato As Long, vllngxIdentificador As Long)
'---------------------------------------------------------------------------------------
' Imprimir un formato en las coordenadas dadas por el usuario
' Ultima Modificación: 08/Ago/2001 --> 18/Sep/2001 --> 11/Oct/2001 --> 17/09/2004 --> 13/01/2008
'---------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    Dim rsContenidoFormato As New ADODB.Recordset
    Dim rsResultadoSelect As New ADODB.Recordset
    Dim vlstrSubcadena As String
    Dim vlstrPorImprimir As String
    Dim vlintContDetalles As Integer
    Dim vlintContSdoDetalle As Integer
    Dim vlintRenglonInicio As Integer
    Dim vlintAnchoFormato As Integer
    Dim vlintTotalLineas As Integer
    Dim vlintColSubCad As Integer
    Dim lngRenglon As Long
    Dim lngColumna As Long
    '--------------------------------------------------
    '13/01/2008 Guarda la máxima longitud de los montos
    Dim vlintLongitudCampo As Integer
    '-----------------------------------------------------
    '13/01/2008 Almacena la variable contador del último
    'ciclo para imprimir los montos alineados a la derecha
    Dim vlintCicloFinal As Integer
    Dim vlblnBanderaEsFactura As Boolean 'Bandera para saber si es factura
    Dim vlblnBanderaImprimeMontos As Boolean 'Bandera para saber si imprimir los montos
    Dim vlintLongitudArray As Integer 'Variable para almacenar la longitud temporal del arreglo dinámico
    Dim vlstrCadenaInicial As String 'Cadena inicial de los montos (Factura)
    Dim vlstrCadenaEspacios As String 'Espacios para justificar a la derecha el monto (Factura)
    Dim vlstrCadenaFinal As String 'Cadena final de los montos (Factura)
    Dim vlintContadorCicloEspacios As Integer 'Contador para el ciclo que concatena el monto (Factura)
    Dim lngRenglonTemp As Long 'Renglon
    Dim vlstrInstruccion As String
    
    '-----------------------------------------------------
    Set rsContenidoFormato = frsEjecuta_SP(str(vllngxNumeroFormato), "SP_PVSELFORMATO")
    
    vlblnBanderaImprimeMontos = False 'Se inicializa la variable a FALSE de la bandera para imprimir los MONTOS
    
    If rsContenidoFormato.RecordCount <> 0 Then
        
        vlintLongitudArray = 0 'Se inicializa en 0 la longitud del array dinámico
        
        vlintAnchoFormato = rsContenidoFormato!intAncho
        vlintTotalLineas = rsContenidoFormato!intLargo

        '--------------------------------
        ' Prepara impresora
        '--------------------------------
        Printer.ScaleMode = vbCharacters
        Printer.Font.Name = rsContenidoFormato!vchFont
        Printer.Font.Size = rsContenidoFormato!INTLETRA

        rsContenidoFormato.MoveFirst
        
        lngRenglonTemp = 0
        
        Do While Not rsContenidoFormato.EOF
        
            vlblnBanderaEsFactura = False 'Se inicializa la variable a FALSE de la bandera FACTURA
            
            vlintRenglonInicio = lngRenglon
            
            If rsContenidoFormato!chrEstatusContenido = "D" Then
            
              vlstrInstruccion = fstrArmaInstruccion(rsContenidoFormato!vchSentencia, str(vllngxIdentificador)) & " " + rsContenidoFormato!vchOrderby
              If Trim(vlstrInstruccion) <> "" Then
                Set rsResultadoSelect = frsRegresaRs(vlstrInstruccion, adLockOptimistic, adOpenDynamic)
                
                If rsResultadoSelect.RecordCount <> 0 Then
                
                    lngColumna = rsContenidoFormato!intCoordenadaX
                    
                    'Definición del renglón a comenzar:
                    If rsContenidoFormato!bitMantenerRenglon = 1 Then
                        'Si se mantiene el renglon, entonces el siguiente renglon es el último calculado
                        lngRenglon = lngRenglonTemp
                    Else
                        If rsContenidoFormato!bitRenglonSiguiente = 1 Then
                            'Se continúa en el siguiente renglón:
                            lngRenglonTemp = lngRenglon
                        Else
                            'Se toma el renglón que trae asignado en el formato:
                            lngRenglon = rsContenidoFormato!intCoordenadaY
                        End If
                    End If
                            
                    rsResultadoSelect.MoveFirst
                    vlintContDetalles = 0
                    
                    Do While Not rsResultadoSelect.EOF
                    
                        If Not IsNull(rsResultadoSelect.Fields(0).Value) Then
                        
                            '--------------------------------------------------
                            ' Da formato a texto de acuerdo a configuracion
                            '--------------------------------------------------
                            vlstrPorImprimir = ""
                            Select Case Trim(rsContenidoFormato!vchFuncionFormato)
                            Case ""
                                vlstrPorImprimir = rsResultadoSelect.Fields(0)
                            Case "Format"
                            
                                vlstrPorImprimir = Format(rsResultadoSelect.Fields(0), rsContenidoFormato!vchFormato)
                                
                                '13/01/2008 Agregado para meter a memoria los montos (Factura)------------------------------------
                                'Si es un tipo FACTURA y tiene formato de pesos, que almacene el monto en el arreglo dinámico
                                If ((Left(rsContenidoFormato!vchFormato, 1) = "$") And (rsContenidoFormato!intNumeroTipoFormato = 2)) Then
                                    
                                    vlblnBanderaEsFactura = True
                                    vlblnBanderaImprimeMontos = True
                                    vlintLongitudArray = vlintLongitudArray + 1
                                    ReDim Preserve aMontos(vlintLongitudArray)
                                    aMontos(vlintLongitudArray).lngX = lngColumna
                                    aMontos(vlintLongitudArray).lngY = lngRenglon
                                    aMontos(vlintLongitudArray).strPorImprimir = vlstrPorImprimir
                                    
                                    If (Len(vlstrPorImprimir) > vlintLongitudCampo) Then
                                        vlintLongitudCampo = Len(vlstrPorImprimir)
                                    End If
                                    
                                End If
                                '----------------------------------------------------------------------------------------
                            Case "fstrNumeroenLetras"
                                vlstrPorImprimir = fstrNumeroenLetras(CDbl(rsResultadoSelect.Fields(0)), rsResultadoSelect.Fields(1), rsResultadoSelect.Fields(2))
                            Case "fstrNumeroJustificado"
                                vlstrPorImprimir = fstrNumeroJustificado(CDbl(rsResultadoSelect.Fields(0)), 14)
                            Case "fstrNumeroJustificado/Espacio"
                                If rsResultadoSelect.Fields(0) = 0 Then
                                    Printer.Print " "
                                Else
                                    vlstrPorImprimir = fstrNumeroJustificado(CDbl(rsResultadoSelect.Fields(0)), 14)
                                End If
                            Case "fstrNumeroJustificadoFormato"
                                vlstrPorImprimir = fstrNumeroJustificadoFormato(IIf(IsNull(CDbl(rsResultadoSelect.Fields(0))), 0, CDbl(rsResultadoSelect.Fields(0))), Trim(rsContenidoFormato!vchFormato))
                            Case Else
                                If IsNull(rsContenidoFormato!vchFuncionFormato) Then vlstrPorImprimir = rsResultadoSelect.Fields(0)
                                 
                            End Select
                            
                            If Not IsNull(rsContenidoFormato!intAnchoContenido) Then
                                If Int(rsContenidoFormato!intAnchoContenido) > 0 And rsContenidoFormato!intAnchoContenido < Len(Trim(vlstrPorImprimir)) Then
                                    vlstrPorImprimir = Mid(vlstrPorImprimir, 1, rsContenidoFormato!intAnchoContenido)
                                End If
                            End If
                            '---------------------------------------------------------------
                            ' Verifica si espacio a la derecha es suficiente para cadena
                            ' si no va dividir esta cadena en subcadenas
                            '---------------------------------------------------------------

                            vlintColSubCad = 1
                            
                            If vlintAnchoFormato > 0 Then
                                vlstrSubcadena = Mid(Trim(vlstrPorImprimir), vlintColSubCad, (vlintAnchoFormato - lngColumna))
                            Else
                                vlstrSubcadena = Trim(vlstrPorImprimir)
                            End If
                            
                            vlintContSdoDetalle = 0
                            
                            'Si el monto es de una factura, que no lo imprima
                            If vlblnBanderaEsFactura = False Then
                                Do While vlstrSubcadena <> ""
                                        Printer.CurrentY = lngRenglon
                                        Printer.CurrentX = lngColumna
                                        Printer.Print vlstrSubcadena
                                        lngRenglon = lngRenglon + 1
                                        vlintColSubCad = vlintColSubCad + (vlintAnchoFormato - lngColumna)
                                        
                                        If vlintAnchoFormato > 0 Then
                                            vlstrSubcadena = Mid(Trim(vlstrPorImprimir), vlintColSubCad, (vlintAnchoFormato - lngColumna))
                                        Else
                                            vlstrSubcadena = ""
                                        End If
                                Loop
                            End If
                            '--------------------------------------------------------------------
                            ' Prepara informacion para la siguiente impresión
                            '--------------------------------------------------------------------
                            vlintContDetalles = vlintContDetalles + 1
                            If rsContenidoFormato!bitRenglonSiguiente = 0 Then
                                If rsContenidoFormato!bitMantenerRenglon = 1 Then
                                    lngRenglon = lngRenglon + 1
                                Else
                                    lngRenglon = rsContenidoFormato!intCoordenadaY + vlintContDetalles
                                End If
                            End If
                        End If
                        rsResultadoSelect.MoveNext
                    Loop
                End If
               End If
            Else
                If rsContenidoFormato!bitRenglonSiguiente = 0 Then
                    Printer.CurrentY = rsContenidoFormato!intCoordenadaY
                Else
                    Printer.CurrentY = lngRenglon + 1
                End If
                Printer.CurrentX = rsContenidoFormato!intCoordenadaX
                Printer.Print rsContenidoFormato!vchSentencia
            End If
            rsContenidoFormato.MoveNext
        Loop
        
        '13/01/2008 Imprime los montos que están en memoria (Facturas) --------------------------
        'Si el arreglo dinámico tiene datos, imprime los montos alineados a la derecha
        If vlblnBanderaImprimeMontos Then
            For vlintCicloFinal = 1 To vlintLongitudArray
                
                vlstrCadenaEspacios = ""
                
                Printer.CurrentX = aMontos(vlintCicloFinal).lngX
                Printer.CurrentY = aMontos(vlintCicloFinal).lngY
                
                vlstrCadenaInicial = Left$(aMontos(vlintCicloFinal).strPorImprimir, 1)
                
                For vlintContadorCicloEspacios = 1 To (((vlintLongitudCampo) - (Len(aMontos(vlintCicloFinal).strPorImprimir))) + 1)
                    vlstrCadenaEspacios = vlstrCadenaEspacios & " "
                Next vlintContadorCicloEspacios
                
                vlstrCadenaFinal = Right$(aMontos(vlintCicloFinal).strPorImprimir, (Len(aMontos(vlintCicloFinal).strPorImprimir) - 2))
                
                Printer.Print vlstrCadenaInicial & vlstrCadenaEspacios & vlstrCadenaFinal
            Next vlintCicloFinal
        End If
        '-------------------------------------------------------------------------------------
        
        If vlintTotalLineas > 0 And lngRenglon < vlintTotalLineas Then
            For lngColumna = 1 To vlintTotalLineas - lngRenglon
                Printer.CurrentY = lngRenglon + lngColumna
                Printer.CurrentX = 1
                Printer.Print "  "
            Next lngColumna
        End If
        
        Printer.EndDoc
        
    End If
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pImprimeFormato"))
End Sub

Public Sub pImprimePulsera(intCveDoc, lngCveCuenta, strTipo As String)
    Dim rs As ADODB.Recordset
    Dim strPrinter As String
    Dim strRutaZPL As String
    Dim strNombreArchivo As String
    Dim intIndex As Integer
    Dim strParams As String
    Dim strEdad As String
    Set rs = frsRegresaRs("select * from SIDocumentoZPL where intCveDocumento = " & intCveDoc)
    If Not rs.EOF Then
        strPrinter = rs!vchNombreImpresora
        strNombreArchivo = rs!vchNombreArchivo
        If fblnAutoVerificacion Then
            strRutaZPL = fstrRutaReportes(strNombreArchivo)
        End If
        If strRutaZPL = "" Then
            strRutaZPL = App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & strNombreArchivo
        End If
    End If
    rs.Close
    strRutaZPL = Replace(strRutaZPL, " ", "^")
    strPrinter = Replace(strPrinter, " ", "^")
    If strRutaZPL <> "" Then
        strParams = strRutaZPL & " " & strPrinter
        Set rs = frsEjecuta_SP(CStr(lngCveCuenta) & "|" & strTipo, "sp_ADSelDatosPulsera")
        If Not rs.EOF Then
            For intIndex = 0 To rs.Fields.Count - 1
                If rs.Fields(intIndex).Name = "Edad" Then
                    If IsNull(rs.Fields(intIndex).Value) Then
                        strEdad = "-"
                    Else
                        strEdad = Replace(fstrObtieneEdad(rs.Fields(intIndex).Value, Now), "Ñ", "\A5")
                    End If
                    strParams = strParams & " " & Replace(strEdad, " ", "^")
                Else
                    strParams = strParams & " " & Replace(Replace(IIf(IsNull(rs.Fields(intIndex).Value), "-", rs.Fields(intIndex).Value), " ", "^"), "Ñ", "\A5")
                End If
            Next
        End If
        rs.Close
        strParams = Trim(strParams)
        fdblPrintZPL strParams
    End If
End Sub

'Función que devuelve uno o todos los parámetros de un módulo
'strModulo -> Iniciales del módulo
'intcveempresa -> Empresa contable si el parámetro es por empresa, -1 si es general
'strNombreParametro -> Parámetro opcional si se requiere solo ese parámetro
Public Function frsSelParametros(strModulo As String, intcveempresa As Integer, Optional strNombreParametro As String) As ADODB.Recordset
    Set frsSelParametros = frsEjecuta_SP(intcveempresa & "|" & strModulo & "|" & strNombreParametro, "sp_GNSelParametro")
End Function

'Procedimiento que actualiza un parámetro específico en la base de datos
'Parametros:
'   intCveEmpresa - Si el parámetro es configurable por empresa, se pasa el número de empresa contable, si es general se pasa -1
'   strNombreParametro - Valor de SIPARAMETRO.vchNombre
'   strNombreModulo - Iniciales del módulo del parámetro a afectar
'   vrtValor - Nuevo valor del parámetro (SIPARAMETRO.vchValor)
Public Sub pActualizaParametro(intcveempresa As Integer, strNombreParametro As String, strNombreModulo As String, vrtValor As Variant, Optional strComentario As String)
    On Error GoTo NotificaError
    
    vgstrParametrosSP = intcveempresa & "|" & _
                        strNombreParametro & "|" & _
                        strNombreModulo & "|" & _
                        vrtValor & "|" & _
                        strComentario
    
    frsEjecuta_SP vgstrParametrosSP, "sp_GNUpdParametro"
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pActualizaParametro"))
End Sub

Public Function fblnManejaCatalogoCargos(intcveempresa As Integer) As Boolean
    Dim rs As New ADODB.Recordset
    Dim llngCargos As Long
    fblnManejaCatalogoCargos = False
    llngCargos = 1
    vgstrParametrosSP = intcveempresa & "|-1|*|1"
    frsEjecuta_SP vgstrParametrosSP, "Sp_Ccintcargoempresa", True, llngCargos
    If llngCargos > 0 Then
        fblnManejaCatalogoCargos = True
    End If
End Function

Public Function fblnCargosFueraCatalogo(lngCuentaGrupo As Long, strTipo As String, intcveempresa As Integer) As Boolean
'lngCuentaGrupo - Cuenta del paciente o clave del grupo
'strTipo - I Interno, E Externo, G Grupo
'intCveEmpresa - Clave de la empresa a la que pertenece el paciente o el grupo
    Dim rsReporte As New ADODB.Recordset
    Dim vlrsFacturarConCargosFueraCatalogo As New ADODB.Recordset
    Dim alstrParametros(0) As String
    Dim rptReporte As CRAXDRT.Report
    Dim blnFacturarConCargosFueraCatalogo As Boolean
    
    
    '|  Identifica si se permitirá facturar aunque existan cargos que no estén configurados en el catálogo de carogos por empresas
    blnFacturarConCargosFueraCatalogo = False
    Set vlrsFacturarConCargosFueraCatalogo = frsSelParametros("PV", vgintClaveEmpresaContable, "BITFACTURARCARGOSFUERACATALOGO")
    If vlrsFacturarConCargosFueraCatalogo.RecordCount <> 0 Then
        If vlrsFacturarConCargosFueraCatalogo!Valor = "1" Then
            blnFacturarConCargosFueraCatalogo = True
        End If
    End If
    
    If Not blnFacturarConCargosFueraCatalogo Then
        fblnCargosFueraCatalogo = False
        pInstanciaReporte rptReporte, "rptCargosFueraCatalogoEmp.rpt"
        vgstrParametrosSP = strTipo & "|" & lngCuentaGrupo & "|" & intcveempresa
        Set rsReporte = frsEjecuta_SP(vgstrParametrosSP, "Sp_PvSELCARGOSFUERACATALOGO")
        If Not rsReporte.EOF Then
            fblnCargosFueraCatalogo = True
            '|  Existen cargos que no tienen código registrado o que no están en el catálogo de la empresa.
            '|  ¿Desea obtener un listado con los cargos?
            If MsgBox(SIHOMsg(999), vbQuestion + vbYesNo, "Mensaje") = vbYes Then
                rptReporte.DiscardSavedData
                alstrParametros(0) = "NombreHospital;" & Trim(vgstrNombreHospitalCH)
                pCargaParameterFields alstrParametros, rptReporte
                pImprimeReporte rptReporte, rsReporte, "P", "Cargos fuera del catálogo de la empresa", False
            End If
        End If
        rsReporte.Close
    End If
End Function

Public Function flngBloqueaArticulo2(vlchrarticulo As String, vlingdepartamento As Integer, strModulo As String, strforma As String) As Integer

    Dim vllngContinuar As Long
    '-----------------------------------------------------------------------------------------------------------------
    '|Guardar en la tabla IvTmpDeptoArticulo el articulo y el departamento para indicar que esta en una transaccion
    '-----------------------------------------------------------------------------------------------------------------
    vllngContinuar = 1
    vgstrParametrosSP = vlchrarticulo & "|" & vlingdepartamento & "|" & strModulo & "|" & strforma & "|" & 1
    frsEjecuta_SP vgstrParametrosSP, "Sp_IvUpdTmpDeptoArticulo2", True, vllngContinuar
    
    flngBloqueaArticulo2 = CInt(vllngContinuar)
    
End Function

'-----------------------------------------------------------------------------------------------------------------
'-----------------------------------------------------------------------------------------------------------------
'|         E M I S I Ó N    D E    C O M P R O B A N T E S    F I S C A L E S    D I G I T A L E S
'-----------------------------------------------------------------------------------------------------------------
'-----------------------------------------------------------------------------------------------------------------
Public Function fintTipoEmisionComprobante(vlstrTipoDocto As String, vllngNumeroTipoFormato As Long, Optional vlIntFolioUnicoNotas As Long) As Integer
    ' vlstrTipoDocto, Tipo de Documento
        '"FA" = Factura, "NA" = Nota de Cargo, "NC" = Nota de Credito
        '"RE" = Recibo, "SD" = Salida de Dinero, "TI" = Ticket
    ' vllngNumeroTipoFormato Numero de Formato
    
    ' La Funcion revisa Folios, Formatos y Datos de CFD para determinar como se facturara
    ' Regresa 0, Si Existen Errores en Configuracion o faltan Datos de comprobantes
    ' Regresa 1, Si Existen Folios y Formato Fisico, Se Facturara Fisicamente
    ' Regresa 2, Si Existen Folios y Formato Digital, Se Facturara Digitalmente

    Dim strSql As String
    Dim strEncriptado As String
    Dim strTipoDocto As String
    Dim blnFolioDigital As Boolean
    Dim blnFormatoDigital As Boolean
    Dim blnLicenciamiento As Boolean
    Dim rsTemp As Recordset
    
    strTipoDocto = IIf(vlstrTipoDocto = "FA", " Factura", IIf(vlstrTipoDocto = "NA", " Nota de Cargo", IIf(vlstrTipoDocto = "NC", " Nota de Credito", IIf(vlstrTipoDocto = "RE", " Recibo", IIf(vlstrTipoDocto = "SD", " Salida de Dinero", IIf(vlstrTipoDocto = "TI", " Ticket", IIf(vlstrTipoDocto = "DO", " Donativo", "")))))))
    
    fintTipoEmisionComprobante = 0
    strSql = ""
    
'******************************************* VALIDACIÓN DE LICIENCIA *******************************************
'----------------------------------------------------------------------------------------------------------------------------------------------------------------
'--------------------------------------------- La validación de licencia se movió a la función fintTipoCFD ---------------------------------------------
'----------------------------------------------------------------------------------------------------------------------------------------------------------------

'    'Determina si se adquirio licencia para CFD
'    strSQL = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC, TRIM(SIPARAMETRO.VCHVALOR) AS VALOR " & _
'        "FROM SIPARAMETRO,CNEMPRESACONTABLE WHERE " & _
'        "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable & " AND SIPARAMETRO.VCHNOMBRE = 'VCHCOMPROBANTESFISCALESDIGITALES' AND SIPARAMETRO.INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable
'    Set rsTemp = frsRegresaRs(strSQL)
'    If rsTemp.EOF Then
'        blnLicenciamiento = False
'    Else
'        strEncriptado = fstrEncrypt(rsTemp!RFC, "SIHO041099")
'        blnLicenciamiento = IIf(rsTemp!Valor = strEncriptado, True, False)
'    End If

'*************************************************************************************************************

    'Se establece la licencia a TRUE por default, ya que se movió la validación de licencia a fintTipoCFD
    blnLicenciamiento = True

    If vlstrTipoDocto = "DO" Then 'Si se trata de Donativos
        'Revisa el tipo de folio (Fisico = 0, Digital = 1)
        strSql = "SELECT BitTipo FROM REGISTROFOLIO" & _
                  " WHERE ChrTipoDocumento = '" + Trim(vlstrTipoDocto) + "'" & _
                  " AND SmiDepartamento = " + str(vgintNumeroDepartamento) & _
                  " AND IntNumeroActual <= IntNumeroFinal"
        Set rsTemp = frsRegresaRs(strSql)
        If rsTemp.EOF Then
            ' No existen folios activos para este documento.
            MsgBox SIHOMsg(291) & strTipoDocto, vbExclamation, "Mensaje"
            Exit Function
        Else
            blnFolioDigital = IIf(rsTemp!BitTipo = 0, False, True)
        End If
        
        If Not blnFolioDigital Then
            fintTipoEmisionComprobante = 1
            Exit Function
        Else
            If blnLicenciamiento Then ' Se adquirio Licencia para CFD
                fintTipoEmisionComprobante = 2
                Exit Function
            Else
                ' ¡No se adquirió licencia para emitir comprobantes fiscales digitales!
                MsgBox SIHOMsg(1030), vbExclamation, "Mensaje"
                Exit Function
            End If
        End If
    Else
        'Revisa el tipo de folio (Fisico = 0, Digital = 1)
        strSql = "SELECT BitTipo FROM REGISTROFOLIO" & _
                  " WHERE ChrTipoDocumento = '" & Trim(vlstrTipoDocto) & "' " & _
                  " AND SmiDepartamento = " + str(vgintNumeroDepartamento) & _
                  " AND IntNumeroActual <= IntNumeroFinal"
        If (Trim(vlstrTipoDocto) = "NC" Or Trim(vlstrTipoDocto) = "NA") And vlIntFolioUnicoNotas > 0 Then
            strSql = "SELECT BitTipo FROM REGISTROFOLIO" & _
                            " WHERE ChrTipoDocumento = 'CC' " & _
                            " AND SmiDepartamento = " + str(vgintNumeroDepartamento) & _
                            " AND IntNumeroActual <= IntNumeroFinal"
        End If
        Set rsTemp = frsRegresaRs(strSql)
        If rsTemp.EOF Then
            ' No existen folios activos para este documento.
            MsgBox SIHOMsg(291) & strTipoDocto, vbExclamation, "Mensaje"
            Exit Function
        Else
            blnFolioDigital = IIf(rsTemp!BitTipo = 0, False, True)
        End If
    
        'Revisa el tipo de formato (Fisico = 0, Digital = 1)
        strSql = "SELECT bitComprobantefiscaldigital FROM FORMATO" & _
                  " WHERE INTNUMEROFORMATO = " & vllngNumeroTipoFormato
        Set rsTemp = frsRegresaRs(strSql)
        If rsTemp.EOF Then
            ' No existen registrados formatos de impresión
            MsgBox SIHOMsg(277), vbExclamation, "Mensaje"
            Exit Function
        Else
            blnFormatoDigital = IIf(rsTemp!bitComprobantefiscaldigital = 0, False, True)
        End If
        
        If blnFolioDigital And blnFormatoDigital Then
            If blnLicenciamiento Then ' Se adquirio Licencia para CFD
                strSql = "SELECT BlbCertificado, BlbLlave, VchContrasena FROM CNEMPRESACONTABLE" & _
                        " WHERE TnyClaveEmpresa = " & vgintClaveEmpresaContable
                Set rsTemp = frsRegresaRs(strSql)
                      
                If (IsNull(rsTemp!BLBCERTIFICADO)) Or (IsNull(rsTemp!BLBLLAVE)) Or (IsNull(rsTemp!vchContrasena)) Then
                    ' Falta información en la empresa contable....
                    MsgBox "Falta información en la empresa contable: " & vbNewLine & vbNewLine & IIf(IsNull(rsTemp!BLBCERTIFICADO), Chr(13) & "Certificado digital" & vbNewLine, "") & IIf(IsNull(rsTemp!BLBLLAVE), Chr(13) & " - Llave digital" & vbNewLine, "") & IIf(IsNull(rsTemp!vchContrasena), Chr(13) & " - Contraseña" & vbNewLine, ""), vbExclamation, "Mensaje"
                    Exit Function
                Else
                    fintTipoEmisionComprobante = 2
                    Exit Function
                End If
            Else
                ' ¡No se adquirió licencia para emitir comprobantes fiscales digitales!
                MsgBox SIHOMsg(1030), vbExclamation, "Mensaje"
                Exit Function
            End If
        End If
        
        If Not blnFolioDigital And Not blnFormatoDigital Then
            fintTipoEmisionComprobante = 1
            Exit Function
        End If
        
        If blnFolioDigital And Not blnFormatoDigital Then
            ' No está permitido facturar un formato físico con folios digitales
            MsgBox SIHOMsg(1023), vbExclamation, "Mensaje"
            Exit Function
        End If
        
        If Not blnFolioDigital And blnFormatoDigital Then
            ' No está permitido facturar un formato digital con folios físicos
            MsgBox SIHOMsg(1022), vbExclamation, "Mensaje"
            Exit Function
        End If
    End If
End Function
'----------------------------------------------------------------------------------------------------------------------------------
'----------------------------------------------------------------------------------------------------------------------------------
'|    COMPARA EL TIPO DE COMPROBANTE FISCAL DIGITAL (CFD = 0, CFDi = 1, FÍSICO = 2, ERROR = 3)
'----------------------------------------------------------------------------------------------------------------------------------
'----------------------------------------------------------------------------------------------------------------------------------
Public Function fintTipoCFD(vlstrTipoDocto As String, vllngNumeroTipoFormato As Long, Optional vlIntFolioUnicoNotas As Long) As Integer

    ' vlstrTipoDocto, Tipo de Documento
        '"FA" = Factura, "NA" = Nota de Cargo, "NC" = Nota de Credito
        '"RE" = Recibo, "SD" = Salida de Dinero, "TI" = Ticket
    
    Dim strSql As String
    Dim strTipoDocto As String
    Dim rsTemp As Recordset
    Dim blnLicenciamiento As Boolean
    Dim strEncriptado As String
    
    strTipoDocto = IIf(vlstrTipoDocto = "FA", " Factura", IIf(vlstrTipoDocto = "NA", " Nota de Cargo", IIf(vlstrTipoDocto = "NC", " Nota de Credito", IIf(vlstrTipoDocto = "RE", " Recibo", IIf(vlstrTipoDocto = "SD", " Salida de Dinero", IIf(vlstrTipoDocto = "TI", " Ticket", IIf(vlstrTipoDocto = "DO", " Donativo", "")))))))
    
    'Inicializa como error
    fintTipoCFD = 3
    strSql = ""
    
    If vlstrTipoDocto = "DO" Then 'Si se trata de Donativos
        'Revisa el tipo de CFD (0= CFD, 1=CFDi, 2=Físico)
        strSql = "SELECT BitCFDi FROM REGISTROFOLIO" & _
                  " WHERE ChrTipoDocumento = '" + Trim(vlstrTipoDocto) + "'" & _
                  " AND SmiDepartamento = " + str(vgintNumeroDepartamento) & _
                  " AND IntNumeroActual <= IntNumeroFinal"
        Set rsTemp = frsRegresaRs(strSql)
        If rsTemp.EOF Then
            ' No existen folios activos para este documento.
            MsgBox SIHOMsg(291) & strTipoDocto, vbExclamation, "Mensaje"
            Exit Function
        Else
            fintTipoCFD = rsTemp!BitCFDi
        End If
        
    Else
        'Revisa el tipo de CFD (0= CFD, 1=CFDi, 2=Físico)
        strSql = "SELECT BitCFDi FROM REGISTROFOLIO" & _
                  " WHERE ChrTipoDocumento = '" & Trim(vlstrTipoDocto) & "' " & _
                  " AND SmiDepartamento = " + str(vgintNumeroDepartamento) & _
                  " AND IntNumeroActual <= IntNumeroFinal"
        If (Trim(vlstrTipoDocto) = "NC" Or Trim(vlstrTipoDocto) = "NA") And vlIntFolioUnicoNotas > 0 Then
            strSql = "SELECT BitCFDi FROM REGISTROFOLIO" & _
                      " WHERE ChrTipoDocumento = 'CC' " & _
                      " AND SmiDepartamento = " + str(vgintNumeroDepartamento) & _
                      " AND IntNumeroActual <= IntNumeroFinal"
        End If
        Set rsTemp = frsRegresaRs(strSql)
        If rsTemp.EOF Then
            ' No existen folios activos para este documento.
            MsgBox SIHOMsg(291) & strTipoDocto, vbExclamation, "Mensaje"
            Exit Function
        Else
            fintTipoCFD = rsTemp!BitCFDi
        End If
    
    End If
    
    '******************************************* VALIDACIÓN DE LICIENCIA *******************************************
    
    'Determina si se adquirio licencia para CFD o CFDi
    strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC, TRIM(SIPARAMETRO.VCHVALOR) AS VALOR " & _
        "FROM SIPARAMETRO,CNEMPRESACONTABLE WHERE " & _
        "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable & " AND SIPARAMETRO.VCHNOMBRE = 'VCHCOMPROBANTESFISCALESDIGITALES' AND SIPARAMETRO.INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable

    Set rsTemp = frsRegresaRs(strSql)
    If rsTemp.EOF And (fintTipoCFD = 0 Or fintTipoCFD = 1) Then
        blnLicenciamiento = False
    Else
        If fintTipoCFD = 0 Then 'Se valida la licencia para CFD
            strEncriptado = fstrEncrypt(rsTemp!RFC, "SIHO041099")
            blnLicenciamiento = IIf(rsTemp!Valor = strEncriptado, True, False)
        ElseIf fintTipoCFD = 1 Then 'Se valida la licencia para CFDi
            If vgstrVersionCFDI = "3.3" Then
                If fblnLicenciaCFDI33(True) Then
                    blnLicenciamiento = True
                Else
                    fintTipoCFD = 3
                    Exit Function
                End If
            Else
                strEncriptado = fstrEncrypt(rsTemp!RFC, "2011SiHOCFDi")
                blnLicenciamiento = IIf(rsTemp!Valor = strEncriptado, True, False)
            End If
        End If

        'Si el licenciamiento es falso se verifica si tiene licencia "completa" (CFD + CFDi)
        If blnLicenciamiento = False Then
            strEncriptado = fstrEncrypt(rsTemp!RFC, "CFDx2099SiHO")
            blnLicenciamiento = IIf(rsTemp!Valor = strEncriptado, True, False)
        End If
    End If

    'Se muestra el mensaje de error dependiendo del tipo de licencia
    If blnLicenciamiento = False And fintTipoCFD = 0 Then
        ' No se adquirió licencia para emitir CFD
        MsgBox SIHOMsg(1086), vbCritical, "Mensaje"
        fintTipoCFD = 3
        Exit Function
    ElseIf blnLicenciamiento = False And fintTipoCFD = 1 Then
        ' No se adquirió licencia para emitir CFDi
        MsgBox SIHOMsg(1087), vbCritical, "Mensaje"
        fintTipoCFD = 3
        Exit Function
    End If
    
    '*************************************************************************************************************
End Function
Public Function fblLicenciaAddenda(vllngAddenda As Long) As Boolean
On Error GoTo NotificaError

Dim strSql As String
Dim rsTemp As New ADODB.Recordset
Dim rsAddenda As New ADODB.Recordset
Dim strLicenciaCorrecta As String
Dim strLicenciaAlmacenada As String
Dim vlstrDescripcionAddenda As String

    'Se inicializa la funcion en falso
    fblLicenciaAddenda = False
    
    'Se valida en base al RFC de la empresa contable seleccionada
    strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC " & _
        "FROM CNEMPRESACONTABLE WHERE " & _
        "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
    Set rsTemp = frsRegresaRs(strSql)
        
    'Se obtiene la licencia almacenada y la descripción de la addenda
    strSql = "SELECT TRIM(GNADDENDA.VCHDOCUMENTACION) AS DescripcionAddenda, TRIM(GNADDENDAEMPRESA.VCHLICENCIAADDENDA) AS LicenciaAlmacenada, TRIM(GNADDENDAEMPRESA.INTCVEEMPRESA) as Empresa " & _
        "FROM GNADDENDA INNER JOIN GNADDENDAEMPRESA ON GNADDENDAEMPRESA.INTCVEADDENDA = GNADDENDA.INTCVEADDENDA WHERE " & _
        "GNADDENDA.INTCVEADDENDA = " & vllngAddenda & " AND GNADDENDAEMPRESA.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
    Set rsAddenda = frsRegresaRs(strSql)
    
    If rsTemp.RecordCount > 0 And rsAddenda.RecordCount > 0 Then
        'Se eliminan los espacios de la descripción de la addenda para evitar errores por espacios
        vlstrDescripcionAddenda = rsAddenda!DescripcionAddenda
        'vlstrDescripcionAddenda = Replace(rsAddenda!DescripcionAddenda, " ", "")
        
        'Se obtiene la licencia correcta ------------------------------------------------------------------->
            'Se codifica utilizando el RFC,la descripción de la addenda y la clave de la empresa a la que corresponde
            strLicenciaCorrecta = Trim(rsTemp!RFC) & Trim(rsAddenda!DescripcionAddenda) & Trim(rsAddenda!empresa)
            
            'Se decodifica la licencia a partir de strLicenciaCorrecta (1a vez)
            strLicenciaCorrecta = Encode(Trim(strLicenciaCorrecta))
            
            'Se decodifica la licencia a partir de strLicenciaCorrecta (2a vez)
            strLicenciaCorrecta = Encode(strLicenciaCorrecta)
            
            'Se reemplazan los caracteres especiales ("U"<-"?"   "l"<-"ñ"   "="<-"Ñ"   "=="<-"Ñ?")
            strLicenciaCorrecta = Replace(strLicenciaCorrecta, "U", "?")
            strLicenciaCorrecta = Replace(strLicenciaCorrecta, "l", "ñ")
            strLicenciaCorrecta = Replace(strLicenciaCorrecta, "==", "Ñ?")
            strLicenciaCorrecta = Replace(strLicenciaCorrecta, "=", "Ñ")
            strLicenciaCorrecta = Replace(Replace(Trim(strLicenciaCorrecta), Chr(10), ""), Chr(13), "") 'Elimina los saltos de linea
            
            'Agrega los caracteres especiales a la cadena codificada (12 al inicio y 10 al final)
            strLicenciaCorrecta = "Fx50Fd3bR660" & strLicenciaCorrecta & "0F3Rn4N20x"
        '<------------------------------------------------------------------- Se obtiene la licencia correcta
        
        'Se asigna el valor de la licencia almacenada en la variable
        strLicenciaAlmacenada = Trim(IIf(IsNull(rsAddenda!LicenciaAlmacenada), " ", rsAddenda!LicenciaAlmacenada))
         
        'Se compara la licencia correcta con la licencia almacenada
        If (Trim(strLicenciaCorrecta) = Trim(strLicenciaAlmacenada)) And Trim(strLicenciaCorrecta) <> "" And Trim(strLicenciaAlmacenada) <> "" Then
            fblLicenciaAddenda = True
        Else
            fblLicenciaAddenda = False
        End If
    End If
    
    rsTemp.Close
    rsAddenda.Close
    
Exit Function
NotificaError:
    fblLicenciaAddenda = False
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblLicenciaAddenda"))
End Function
Public Function fblnLicenciaWS(vllngInterfaz As Long) As Boolean
On Error GoTo NotificaError

Dim strSql As String
Dim rsTemp As New ADODB.Recordset
Dim rsInterfaz As New ADODB.Recordset
Dim strLicenciaCorrecta As String
Dim strLicenciaAlmacenada As String
Dim vlstrDescripcionInterfaz As String

    'Se inicializa la funcion en falso
    fblnLicenciaWS = False
    
    'Se valida en base al RFC de la empresa contable seleccionada
    strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC " & _
        "FROM CNEMPRESACONTABLE WHERE " & _
        "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
    Set rsTemp = frsRegresaRs(strSql)
        
    'Se obtiene la licencia almacenada y la descripción de la interfaz
    strSql = "SELECT TRIM(GNINTERFAZWS.VCHDESCRIPCION) AS DescripcionInterfaz, TRIM(GNINTERFAZWS.VCHLICENCIA) AS LicenciaAlmacenada, TRIM(GNINTERFAZWS.VCHCVEPROVEEDORAXA) AS Proveedor " & _
                    "FROM GNINTERFAZWS  " & _
                    "WHERE GNINTERFAZWS.INTCVEINTERFAZ = " & vllngInterfaz
    Set rsInterfaz = frsRegresaRs(strSql)
    
    If rsTemp.RecordCount > 0 And rsInterfaz.RecordCount > 0 Then
        'Se eliminan los espacios de la descripción de la addenda para evitar errores por espacios
        vlstrDescripcionInterfaz = rsInterfaz!DescripcionInterfaz
        'vlstrDescripcionInterfaz = Replace(rsInterfaz!DescripcionInterfaz, " ", "")
        
        'Se obtiene la licencia correcta ------------------------------------------------------------------->
            'Se codifica utilizando el RFC,la descripción de la addenda y la clave de la empresa a la que corresponde
            strLicenciaCorrecta = Trim(rsTemp!RFC) & Trim(rsInterfaz!DescripcionInterfaz) & Trim(rsInterfaz!proveedor)
            
            'Se decodifica la licencia a partir de strLicenciaCorrecta (1a vez)
            strLicenciaCorrecta = Encode(Trim(strLicenciaCorrecta))
            
            'Se decodifica la licencia a partir de strLicenciaCorrecta (2a vez)
            strLicenciaCorrecta = Encode(strLicenciaCorrecta)
            
            'Se reemplazan los caracteres especiales ("U"<-"?"   "l"<-"ñ"   "="<-"Ñ"   "=="<-"Ñ?")
            strLicenciaCorrecta = Replace(strLicenciaCorrecta, "U", "?")
            strLicenciaCorrecta = Replace(strLicenciaCorrecta, "l", "ñ")
            strLicenciaCorrecta = Replace(strLicenciaCorrecta, "==", "Ñ?")
            strLicenciaCorrecta = Replace(strLicenciaCorrecta, "=", "Ñ")
            strLicenciaCorrecta = Replace(Replace(Trim(strLicenciaCorrecta), Chr(10), ""), Chr(13), "") 'Elimina los saltos de linea
            
            'Agrega los caracteres especiales a la cadena codificada (12 al inicio y 10 al final)
            strLicenciaCorrecta = "Fx50Fd3bR660" & strLicenciaCorrecta & "0F3Rn4N20x"
        '<------------------------------------------------------------------- Se obtiene la licencia correcta
        
        'Se asigna el valor de la licencia almacenada en la variable
        strLicenciaAlmacenada = Trim(IIf(IsNull(rsInterfaz!LicenciaAlmacenada), " ", rsInterfaz!LicenciaAlmacenada))
         
        'Se compara la licencia correcta con la licencia almacenada
        If (Trim(strLicenciaCorrecta) = Trim(strLicenciaAlmacenada)) And Trim(strLicenciaCorrecta) <> "" And Trim(strLicenciaAlmacenada) <> "" Then
            fblnLicenciaWS = True
        Else
            fblnLicenciaWS = False
        End If
    End If
    
    rsTemp.Close
    rsInterfaz.Close
    
Exit Function
NotificaError:
    fblnLicenciaWS = False
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnLicenciaWS"))
End Function


Public Function fblnVerificaForzarLoteYCaduc() As Boolean 'Función que determina si se forzará la captura de lote y caducidades
    On Error GoTo Errores
    Dim rsVeri As ADODB.Recordset

    Set rsVeri = frsSelParametros("SI", -1, "BITFORZARLOTEYCADUCIDAD")
    If Not rsVeri.EOF Then
        fblnVerificaForzarLoteYCaduc = IIf(IIf(IsNull(rsVeri("Valor")), 0, rsVeri("Valor")) = 0, False, True)
    Else
        fblnVerificaForzarLoteYCaduc = False
    End If
    rsVeri.Close
    Exit Function
Errores:
    fblnVerificaForzarLoteYCaduc = False
End Function



Public Function fintDifDiasRecepcion(intCveEmpresaContable As Integer) As Integer
    Dim rs As ADODB.Recordset
    
    Set rs = frsRegresaRs("SELECT smidiferenciadiasrecepcion FROM IVPARAMETRO WHERE tnyclaveempresa = " & intCveEmpresaContable, adLockReadOnly, adOpenForwardOnly)
    If Not rs.EOF Then
        fintDifDiasRecepcion = rs!smidiferenciadiasrecepcion
    Else
        fintDifDiasRecepcion = 0
    End If
    rs.Close
End Function
Public Sub pCargaLotes(vlintNumMov As Long, vlStrReferencia As String, vlstrTabla As String, vlintDeptLote As Integer, vlblnLimpiarArreglo As Boolean, Optional vlstrFiltros As String)
' Para manejo de caducidad de articulos
' vlstrTabla para saber si es la tabla 'O' Original o la 'T' Temporal(para inventario fisico)
' si vlstrTabla es Temporal, VlintNumMov es contiene clave de departamento
   Dim rslotes As New ADODB.Recordset
   Dim vlIntCont As Long
   Dim vlstrx As String
   Dim vlintContInicial As Integer
   Dim vlparam As String
     
    If vlblnLimpiarArreglo Then
        ReDim agLotes(0)
        vgLngTotalLotesxMov = 0
    End If

    vlparam = "'" & Trim(vlstrTabla) & "'|'" & Trim(vlStrReferencia) & "'|" & vlintNumMov
    If vlstrTabla = "T" Then
        vlparam = vlparam & "|" & Trim(vlstrFiltros)
    Else
        vlparam = vlparam & "|" & vlintDeptLote & "|||||||"
    End If

    Set rslotes = frsEjecuta_SP(vlparam, "SP_IVSELKARDEXMOVLOTE", , , , True)

    If rslotes.RecordCount <> 0 Then
        
        If vlblnLimpiarArreglo Then
            vlintContInicial = 1
            vgLngTotalLotesxMov = rslotes.RecordCount
        Else
            vlintContInicial = vgLngTotalLotesxMov + 1
            vgLngTotalLotesxMov = vgLngTotalLotesxMov + rslotes.RecordCount
        End If
        
        rslotes.MoveFirst
        For vlIntCont = vlintContInicial To vgLngTotalLotesxMov
            ReDim Preserve agLotes(vlIntCont)
            agLotes(vlIntCont).Articulo = rslotes!chrcvearticulo
            agLotes(vlIntCont).CantidadUM = rslotes!relCantidadUM
            agLotes(vlIntCont).CantidadUV = rslotes!relCantidadUV
            agLotes(vlIntCont).CantidadUMInicio = rslotes!relCantidadUM
            agLotes(vlIntCont).CantidadUVInicio = rslotes!relCantidadUV
            agLotes(vlIntCont).fechaCaducidad = rslotes!dtmFechaCaducidad
            agLotes(vlIntCont).lote = rslotes!chrlote
            agLotes(vlIntCont).TablaRelacion = rslotes!vchTablaRelacion
            agLotes(vlIntCont).TipoAccion = rslotes!inttipoaccion
            rslotes.MoveNext
        Next vlIntCont
    End If
End Sub
Public Function flngContenido(vlstrCveArticulo As String) As Long
On Error GoTo NotificaError

    flngContenido = frsRegresaRs("SELECT intContenido FROM IVARTICULO WHERE chrCveArticulo = '" & Trim(vlstrCveArticulo) & "'").Fields(0)

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngContenido"))
End Function

Public Function fblnManejaLotes(vlstrCveArticulo As String) As Long
On Error GoTo NotificaError

    fblnManejaLotes = frsRegresaRs("SELECT bitmanejacaducidad FROM IVARTICULO WHERE chrCveArticulo = '" & Trim(vlstrCveArticulo) & "'").Fields(0)

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnManejaLotes"))
End Function

Public Sub pBorraArtsLote(vlstrArt As String)
'Marca articulos a borrar en un paquete de lotes que se tenga cargado
Dim vllngContad As Long
    
    If vgLngTotalLotesxMov > 0 Then
        For vllngContad = 1 To vgLngTotalLotesxMov
            If Trim(agLotes(vllngContad).Articulo) = Trim(vlstrArt) And Trim(agLotes(vllngContad).Borrado) <> "*" Then
                agLotes(vllngContad).Borrado = "*"
                agLotes(vllngContad).CantidadUM = 0
                agLotes(vllngContad).CantidadUV = 0
                agLotes(vllngContad).Movimiento = 0
                agLotes(vllngContad).Devolucion = 0
            End If
        Next vllngContad
    End If
End Sub

Public Sub pGrabaLotes(vllngNumMov As Long, vlStrReferencia As String, vlintDeptoLote As Integer, vlstrTipoES As String, vlblnLimpiaArreglo As Boolean)
'Para manejo de caducidad de articulos
Dim rslotes As New ADODB.Recordset
Dim rsExistencia As New ADODB.Recordset
Dim rsKardex As New ADODB.Recordset
Dim vlstrx As String
Dim vllngContad As Long
Dim vlstrParametros As String
Dim vllngResultado As Long
Dim llngNumMovimientoKardex As Long
Dim strFechaHoraMov As String

    vlstrx = "Select * from ivKardexInventarioLote where 1 = 2 "    'Solo para llenarlo
    Set rslotes = frsRegresaRs(vlstrx, adLockOptimistic, adOpenDynamic)
    
    If vgLngTotalLotesxMov > 0 Then
        For vllngContad = 1 To vgLngTotalLotesxMov
            ' solo los que no han sido marcados como borrados
            If Trim(agLotes(vllngContad).Borrado) <> "*" Then
                vllngResultado = 1
                vlstrParametros = vlintDeptoLote & "|'" & Trim(agLotes(vllngContad).Articulo) & "'|'" & Trim(agLotes(vllngContad).lote) & "'|"
                'PRIMERO SER ACTUALIZA LO ORIGINAL Y LUEGO SE ACTUALIZA CON LO QUE SE CAPTURO
                If vlstrTipoES = "E" Then
                    If agLotes(vllngContad).CantidadUMInicio > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUMInicio & "|'M'", "SP_IVDESCUENTALOTEUBICACION", True, vllngResultado
                    If agLotes(vllngContad).CantidadUVInicio > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUVInicio & "|'A'", "SP_IVDESCUENTALOTEUBICACION", True, vllngResultado
                    If agLotes(vllngContad).CantidadUM > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUM & "|'M'" & "|" & fstrFechaSQL(CStr(agLotes(vllngContad).fechaCaducidad), "23:59:59", True), "SP_IVAUMENTALOTEUBICACION"
                    If agLotes(vllngContad).CantidadUV > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUV & "|'A'" & "|" & fstrFechaSQL(CStr(agLotes(vllngContad).fechaCaducidad), "23:59:59", True), "SP_IVAUMENTALOTEUBICACION"
                Else
                    If agLotes(vllngContad).CantidadUMInicio > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUMInicio & "|'M'" & "|" & fstrFechaSQL(CStr(agLotes(vllngContad).fechaCaducidad), "23:59:59", True), "SP_IVAUMENTALOTEUBICACION"
                    If agLotes(vllngContad).CantidadUVInicio > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUVInicio & "|'A'" & "|" & fstrFechaSQL(CStr(agLotes(vllngContad).fechaCaducidad), "23:59:59", True), "SP_IVAUMENTALOTEUBICACION"
                    If agLotes(vllngContad).CantidadUM > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUM & "|'M'", "SP_IVDESCUENTALOTEUBICACION", True, vllngResultado
                    If agLotes(vllngContad).CantidadUV > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUV & "|'A'", "SP_IVDESCUENTALOTEUBICACION", True, vllngResultado
                End If
                
                vlstrx = "Select ki.dtmFechaHoraMov, ki.intNumMovimiento from IvKardexInventario ki " & _
                         " where ki.intNumMovimiento = (select max(INTNUMMOVIMIENTO) movimiento from ivkardexinventario where " & _
                              "CHRCVEARTICULO ='" & agLotes(vllngContad).Articulo & "' and VCHTABLARELACION ='" & Trim(vlStrReferencia) & "' and NUMNUMREFERENCIA = " & vllngNumMov & " and smicvedepartamento = " & vlintDeptoLote & ")"
                Set rsKardex = frsRegresaRs(vlstrx)
                If rsKardex.RecordCount = 0 Then
                   llngNumMovimientoKardex = 0
                   strFechaHoraMov = ""
                Else
                   llngNumMovimientoKardex = IIf(IsNull(rsKardex!intNumMovimiento), 0, rsKardex!intNumMovimiento)
                   strFechaHoraMov = fstrFechaSQL(Format(rsKardex!DTMFECHAHORAMOV, "YYYY-MM-DD"), Format(rsKardex!DTMFECHAHORAMOV, "hh:mm:ss"))
                End If
                    
                vlstrx = "Select * from ivLoteUbicacion where smicvedepartamento= " & vlintDeptoLote & _
                         " and chrcveArticulo = '" & agLotes(vllngContad).Articulo & "' and trim(chrlote) = '" & Trim(agLotes(vllngContad).lote) & "'"
                Set rsExistencia = frsRegresaRs(vlstrx)
                
                With rslotes
                    .AddNew
                    !numNumReferencia = vllngNumMov
                    !chrcvearticulo = agLotes(vllngContad).Articulo
                    !chrlote = agLotes(vllngContad).lote
                    !relCantidadUM = agLotes(vllngContad).CantidadUM
                    !relCantidadUV = agLotes(vllngContad).CantidadUV
                    !vchTablaRelacion = Trim(vlStrReferencia)
                    !smicvedepartamento = vlintDeptoLote
                    If rsExistencia.RecordCount <> 0 Then
                        !RELEXISTENCIAUM = IIf(IsNull(rsExistencia!intexistenciadeptoum), 0, rsExistencia!intexistenciadeptoum)
                        !RELEXISTENCIAUV = IIf(IsNull(rsExistencia!intExistenciaDeptouv), 0, rsExistencia!intExistenciaDeptouv)
                    End If
                    !intnummovimientokardex = llngNumMovimientoKardex
                    .Update
                End With
            Else
            ' SI FUE BORRADO PERO TENIA ALGO AL MOMENTO DE CARGAR
                vllngResultado = 1
                vlstrParametros = vlintDeptoLote & "|'" & Trim(agLotes(vllngContad).Articulo) & "'|'" & Trim(agLotes(vllngContad).lote) & "'|"
                If vlstrTipoES = "E" Then
                    If agLotes(vllngContad).CantidadUMInicio > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUMInicio & "|'M'", "SP_IVDESCUENTALOTEUBICACION", True, vllngResultado
                    If agLotes(vllngContad).CantidadUVInicio > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUVInicio & "|'A'", "SP_IVDESCUENTALOTEUBICACION", True, vllngResultado
                Else
                    If agLotes(vllngContad).CantidadUMInicio > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUMInicio & "|'M'" & "|" & fstrFechaSQL(CStr(agLotes(vllngContad).fechaCaducidad), , True), "SP_IVAUMENTALOTEUBICACION"
                    If agLotes(vllngContad).CantidadUVInicio > 0 Then frsEjecuta_SP vlstrParametros & agLotes(vllngContad).CantidadUVInicio & "|'A'" & "|" & fstrFechaSQL(CStr(agLotes(vllngContad).fechaCaducidad), , True), "SP_IVAUMENTALOTEUBICACION"
                End If
            End If
        Next vllngContad
    End If
    
    If vlblnLimpiaArreglo Then
        ReDim agLotes(0)
        vgLngTotalLotesxMov = 0
    End If
End Sub
Public Function flngContenidoEmpaque(lngCveEmpaque) As Long
    Dim rs As ADODB.Recordset
    
    Set rs = frsRegresaRs("SELECT intContenido FROM COTipoEmpaque WHERE intCveTipoEmpaque = " & lngCveEmpaque, adLockReadOnly, adOpenForwardOnly)
    If Not rs.EOF Then
        flngContenidoEmpaque = rs!intContenido
    Else
        flngContenidoEmpaque = 0
    End If
    rs.Close
End Function
Public Function fblnGeneraComprobanteDigital(lngComprobante As Long, _
                                                    strTipo As String, _
                                          intTipoAgrupacion As Integer, _
                                           IntAnoAprobacion As Integer, _
                                        strNumeroAprobacion As String, _
                                                    blnCFDI As Boolean, _
                                       Optional blnGrabaCFD As Boolean = True, _
                                       Optional lngCveAddenda As Long, _
                                       Optional BanTimbrar As Boolean = True) As Boolean
    Dim strParametros As String
    Dim strArchivoXMLBase As String
    Dim alstrParametroSalida() As String
    Dim lngError As Long
    Dim lngCveFormato As Long
    Dim rsTipoPaciente As New ADODB.Recordset
    Dim lngCveTipoPaciente As Long
    Dim strTipoPaciente As String
    Dim intTipoAgrupa As Integer
    Dim strSentencia As String
    Dim strSentenciaExcluir As String
    Dim strSentenciaRazonSocial As String
    Dim rsNota As New Recordset
    Dim rsRutas As New Recordset
    Dim fsoComprobante As New FileSystemObject
    Dim strRutaXML As String
    Dim strRutaPDF As String
    Dim vlBuscaCarpeta As Object
    Dim XMLSolicitudTimbrado As MSXML2.DOMDocument
    Dim UUID As String
    Dim rsRuta As New ADODB.Recordset
    Dim rsEmpresaCFD As New ADODB.Recordset
    Dim vlintEmpresaCFD As Long
    Dim dblTotal As Double
    Dim strMoneda As String
    Dim strCantidadLetras As String
    Dim RsComprobante As New ADODB.Recordset
    Dim RsComprobantePredial As New ADODB.Recordset
    Dim strError As String 'Esta variable almacena el proceso en el cual se presenta un error, para poder ser detectado más rápidamente
    Dim blnMostrarMsjNotificaError As Boolean 'Esta varialble indica si se mostrará un mensaje de error, en caso de que se presente alguno
    Dim ObjRS As New ADODB.Recordset          'Se agrega para consultar si existe ya el registro del comprobante en gncomprobantefiscaldigital
    Dim intlineaGoto As Integer               'Identificar la linea donde ocurre algún error
    Dim RsBlnCFD As New ADODB.Recordset
    Dim rsComprobanteExluir As New ADODB.Recordset
    Dim rsComprobanteRazonSocial As New ADODB.Recordset
    
On Error GoTo NotificaError:

    'Se pone el cursor del mouse en modo de espera...
    Screen.MousePointer = vbHourglass
    
    'Se inicializan las variables de control
    fblnGeneraComprobanteDigital = True
    strError = ""
    blnMostrarMsjNotificaError = True
    vgIntBanderaTImbradoPendiente = 0
    '---------------------------------------
    CFDiblnHaytimbre = False     ' no hay timbre
    CFDiblnBanError = False      ' no hay error
    CFDistrProcesoError = ""     ' no hay proceso de error
    CFDiintLineaError = 0        ' no hay linea de error
    CFDilngNumError = 0          ' no hay error
    CFDistrDescripError = ""     ' no hay descripcion de error
    CFDiintResultadoTimbrado = 0 ' el proceso esta en su inicio, si al final sigue en 0 quiere decir que todo salió bien
    intlineaGoto = 0             ' linea en la que se activa el GOTO(esta variable es local)
    
    '----------------------------------------------------------------
    'Revisamos si ya existe el registro en gncomprobantefiscaldigital
    '----------------------------------------------------------------
1    strSentencia = "SELECT count(*) FROM GNCOMPROBANTEFISCALDIGITAL " & _
                   " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                   "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "' and clbComprobanteFiscal is not null"
    
2    Set ObjRS = frsRegresaRs(strSentencia, adLockOptimistic)
    'ObjRs.Fields(0) = 0 quiere decir que no existe registro en gncomprobantefiscaldigital
    'ObjRs.Fields(0) = 1 quiere decir que ya existe el registro en gncomprobantefiscaldigital
    '----------------------------------------------------------------------------------------
    
3    If ObjRS.Fields(0) = 0 Then
4       If blnGrabaCFD Then
            
            'si es factura y no tiene agrupacion, debemos obtenerla
91          If strTipo = "FA" And intTipoAgrupacion = 0 Then
92             intTipoAgrupacion = fintTipoAgrupacionFactura(lngComprobante)
93             If intTipoAgrupacion = 0 Then
                  strError = "Error al intentar obtener la agrupación de la factura"
                  intlineaGoto = 94
94                GoTo NotificaError
               End If
            End If

            If Not blnCFDI And IntAnoAprobacion = 0 Then
95             strSentencia = "SELECT BITCFDI,NVL(trim(VCHNUMAPROBACION),' ') NUMAPROBACION ,NVL(to_char(DTMFECHAAPROBACION, 'yyyy'), 0) ANOAPROBACION From PVFACTURA INNER JOIN REGISTROFOLIO ON (TRIM(REGISTROFOLIO.CHRCVEDOCUMENTO) = PVFACTURA.VCHSERIE) " & _
                             "AND (PVFACTURA.INTFOLIO BETWEEN REGISTROFOLIO.INTNUMEROINICIAL AND REGISTROFOLIO.INTNUMEROFINAL) " & _
                             "AND (REGISTROFOLIO.SMIDEPARTAMENTO = PVFACTURA.SMIDEPARTAMENTO) " & _
                             "Where CHRTIPODOCUMENTO = 'FA' AND PVFACTURA.INTCONSECUTIVO = " & lngComprobante
              
96             Set RsBlnCFD = frsRegresaRs(strSentencia, adLockOptimistic)
97             If RsBlnCFD.RecordCount > 0 Then
98                 If IsNull(RsBlnCFD!BitCFDi) Then
99                       strError = "Error al intentar obtener el tipo de comprobante"
100                      intlineaGoto = 101
101                      GoTo NotificaError
                   Else
102                    If RsBlnCFD!BitCFDi = 2 Then
103                          strError = "Error al intentar obtener el tipo de comprobante"
104                          intlineaGoto = 105
105                          GoTo NotificaError
                       Else
106                          blnCFDI = IIf(RsBlnCFD!BitCFDi = 0, False, True)
                             If Not blnCFDI Then
                                IntAnoAprobacion = CInt(RsBlnCFD!ANOAPROBACION)
                                strNumeroAprobacion = RsBlnCFD!NUMAPROBACION
                             End If
                       End If
                   End If
               Else
107                strError = "Error al intentar obtener el tipo de comprobante"
108                intlineaGoto = 109
109                GoTo NotificaError
               End If
            End If

            '-----------------------------------------------------------------------------------------
            '|  Obtiene toda la información del comprobante y lo inserta en GNCOMPROBANTEFISCALDIGITAL
            '-----------------------------------------------------------------------------------------
5           pCargaArreglo alstrParametroSalida, lngError & "|" & ADODB.adBSTR
6           strParametros = lngComprobante & "|" & strTipo & "|" & IIf(IntAnoAprobacion = 0, " ", IntAnoAprobacion) & "|" & strNumeroAprobacion & "|" & intTipoAgrupacion & "|" & IIf(blnCFDI = True, 1, 0) & "|" & IIf(blnCFDI = True, vgstrVersionCFDI, "2.2")
7           frsEjecuta_SP strParametros, "SP_PVSELDATOSCFD", True, , alstrParametroSalida
8           pObtieneValores alstrParametroSalida, lngError
9           If lngError <> 0 Then
                  strError = "Error al ingresar información en SP_PVSELDATOSCFD, Error " & lngError
10                pMuestraErrorDatosXML (lngError)
11                blnMostrarMsjNotificaError = False
                  intlineaGoto = 13
13                GoTo NotificaError
            End If
            If vgstrVersionCFDI = "4.0" And vgstrTipoNotaSig = "CR" Or vgstrTipoNotaSig = "CA" Then
                If Trim(vgblRazonSocial) = "" Then 'solo si trae algo la variable que haga esa actualización de la razón social o nombre
                    pEjecutaSentencia "UPDATE GNCOMPROBANTEFISCALDIGITAL SET VCHCODIGOPOSTALDFRECEPTOR = '" & vgstrCodigoPostalSig & "', VCHREGIMENFISCALRECEPTOR = '" & vgstrRegimenFiscalSig & "' WHERE CHRTIPOCOMPROBANTE = '" & vgstrTipoNotaSig & "' AND INTCOMPROBANTE = " & vglngIdComprobanteSig
                Else
                    pEjecutaSentencia "UPDATE GNCOMPROBANTEFISCALDIGITAL SET VCHCODIGOPOSTALDFRECEPTOR = '" & vgstrCodigoPostalSig & "', VCHREGIMENFISCALRECEPTOR = '" & vgstrRegimenFiscalSig & "', VCHNOMBRERECEPTOR = '" & vgblRazonSocial & "' WHERE CHRTIPOCOMPROBANTE = '" & vgstrTipoNotaSig & "' AND INTCOMPROBANTE = " & vglngIdComprobanteSig
                End If
                
                vgblRazonSocial = "" 'se limpia para que no arrastre información la variable para otro movimiento posterior
            End If
            
            If vgstrVersionCFDI = "4.0" And vgStrPeriodicidad <> "" And vgStrMesesGlobal <> "" And vgStrAñoGlobal <> "" Then
                pEjecutaSentencia "UPDATE GNCOMPROBANTEFISCALDIGITAL SET VCHPERIODICIDAD = '" & vgStrPeriodicidad & "', VCHMESESGLOBAL = '" & vgStrMesesGlobal & "', VCHAÑOGLOBAL = '" & vgStrAñoGlobal & "' WHERE CHRTIPOCOMPROBANTE = 'FA' AND INTCOMPROBANTE = " & lngComprobante
                vgStrPeriodicidad = ""
                vgStrMesesGlobal = ""
                vgStrAñoGlobal = ""
            End If
            
            '---------------------------------------------------------
            'Agrega el importe en letras en GNCOMPROBANTEFISCALDIGITAL
            '---------------------------------------------------------
14          strSentencia = "SELECT INTADDENDACOMPROBANTE, CHRTIPOCOMPROBANTE, VCHCANTIDADCONLETRAADDENDA, NumTotalComprobante, VCHMONEDAADDENDA, vchagregadomonedaaddenda, NUMDESCUENTOCOMPROBANTE " & _
                           "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                           " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                           "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
15          Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
16          dblTotal = IIf(IsNull(RsComprobante!numTotalComprobante), 0, RsComprobante!numTotalComprobante)
17          strMoneda = UCase(RsComprobante!VCHMONEDAADDENDA)
18          strCantidadLetras = fstrNumeroenLetras(dblTotal, strMoneda, "") & " " & IIf(IsNull(RsComprobante!VCHAGREGADOMONEDAADDENDA), "", RsComprobante!VCHAGREGADOMONEDAADDENDA)
19          With RsComprobante
20                !VCHCANTIDADCONLETRAADDENDA = Trim(strCantidadLetras)
21                !intAddendaComprobante = lngCveAddenda
22                .Update
23          End With

        '---------------------------------
        '* Inclusion de el numero predial
        '---------------------------------
        Dim strSentenciaNumPredial As String
        If vgblnhaynumpredial Then
            strSentenciaNumPredial = "SELECT VCHNUMEROPREDIAL, CHRTIPOCOMPROBANTE, INTCOMPROBANTE " & _
                           "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                           " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                           "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
         Set RsComprobantePredial = frsRegresaRs(strSentenciaNumPredial, adLockOptimistic, adOpenDynamic)
         With RsComprobantePredial
               !VCHNUMEROPREDIAL = Trim(VGLNUMPREDIAL)
                .Update
         End With
        End If
        
        'Excluir datos del paciente
        strSentenciaExcluir = "SELECT BITEXCLUIRNOMBREPACIENTE " & _
                           "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                           " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                           "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
        Set rsComprobanteExluir = frsRegresaRs(strSentenciaExcluir, adLockOptimistic, adOpenDynamic)
        With rsComprobanteExluir
            !BITEXCLUIRNOMBREPACIENTE = IIf(vlblnExcluirPaciente, 1, 0)
            .Update
        End With
        
        'Utilizar Razon social cuando es RFC generico
        strSentenciaRazonSocial = "SELECT BITUSARRAZONSOCIAL " & _
                           "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                           " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                           "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
        Set rsComprobanteRazonSocial = frsRegresaRs(strSentenciaRazonSocial, adLockOptimistic, adOpenDynamic)
        With rsComprobanteRazonSocial
            !BITUSARRAZONSOCIAL = IIf(vlblnUsarRazonSocial, 1, 0)
            .Update
        End With


24      End If
       '-----------------------------------------------------------------------------
       '|  Genera XML sin firma y lo introduce en la tabla GNCOMPROBANTEFISCALDIGITAL
       '-----------------------------------------------------------------------------
25
26       strError = "Error en la generación del archivo XML base."
27       If blnCFDI Then
            strParametros = strTipo & "|" & lngComprobante
28          frsEjecuta_SP strParametros, "SP_GNUPDCOMPROBANTEFIDIIN", True   '--------------- CFDi
         Else
            strParametros = lngComprobante & "|" & strTipo
30          frsEjecuta_SP strParametros, "SP_GNINSXMLSINFIRMAR", True       '--------------- CFD
         End If
     End If 'ObjRs.Fields(0) = 0
     ObjRS.Close
     
     If Not BanTimbrar Then Exit Function 'esta condición se usa para cuando nada más queremos que se ingresen los datos del comprobante a GNCOMPROBANTEFISCALDIGITAL, sin timbrar
    
     '------------------------
     '|  Genera XML con firma
     '------------------------
     If lngCveAddenda <> -1 Then
31       If Not fblnGeneraCFD(lngComprobante, strTipo, blnCFDI, lngCveAddenda) Then 'Exit Function
32           blnMostrarMsjNotificaError = False
             intlineaGoto = 33
33           GoTo NotificaError
         End If
     End If
    
     'Se regresa a la normalidad el estatus del cursor del mouse...
34   Screen.MousePointer = vbDefault

35   If CFDiblnHaytimbre Or Not blnCFDI Then ' si ya hay timbre fiscal o es un CFD
         '-----------------------------------
         ' Comienza generacion de XML y/o PDF
         '-----------------------------------
36       strSentencia = "SELECT TRIM(VCHSERIECOMPROBANTE) || TRIM(VCHFOLIOCOMPROBANTE) Folio FROM GNCOMPROBANTEFISCALDIGITAL WHERE intComprobante = " & lngComprobante & " AND CHRTIPOCOMPROBANTE = '" & strTipo & "'"
37       Set rsNota = frsRegresaRs(strSentencia)
38       strSentencia = "SELECT VCHRUTAXML, VCHRUTAPDF FROM CNEMPRESACONTABLE WHERE TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
39       Set rsRutas = frsRegresaRs(strSentencia)
                    
         'Se modificó el orden de generar los archivos XML y PDF, ahora se genera primero el XML esto es para que, en caso de que exista error de impresión el XML ya haya sido generado
40       strError = "No se ha configurado la ruta de descarga de los archivos XML"
    
41       If Trim(rsRutas!vchRutaXML) = "" Then
            intlineaGoto = 42
42          GoTo NotificaError
         ElseIf Not IsNull(Trim(rsRutas!vchRutaXML)) Then
44          pCreaDirectorio rsRutas!vchRutaXML
45          strRutaXML = rsRutas!vchRutaXML & "\" & rsNota!Folio & ".xml"
46          If blnCFDI Then
47             If Not fblnDescargaXMLCFDi(lngComprobante, strTipo, strRutaXML) Then 'Exit Function '--------------- CFDi
48                    blnMostrarMsjNotificaError = False
                      intlineaGoto = 49
49                    GoTo NotificaError
               End If
            Else
50             If Not fblnDescargaXML(lngComprobante, strTipo, strRutaXML) Then 'Exit Function     '--------------- CFD
51                    blnMostrarMsjNotificaError = False
                      intlineaGoto = 52
52                    GoTo NotificaError
              End If
            End If
         Else
            intlineaGoto = 53
53          GoTo NotificaError
         End If
            
55       strError = "No se ha configurado la ruta de descarga de los archivos PDF"
56       If Trim(rsRutas!vchRutaPDF) = "" Then
            intlineaGoto = 57
57          GoTo NotificaError
58       ElseIf Not IsNull(Trim(rsRutas!vchRutaPDF)) Then
59                  pCreaDirectorio rsRutas!vchRutaPDF
60                  strRutaPDF = rsRutas!vchRutaPDF & "\" & rsNota!Folio & ".pdf"
61                  lngCveTipoPaciente = -2
62                  strTipoPaciente = ""
63                  intTipoAgrupa = -1
64                  Set rsTipoPaciente = frsEjecuta_SP(lngComprobante & "|" & strTipo, "SP_GNSELTIPOPACIENTECFD")
65                  If rsTipoPaciente.RecordCount > 0 Then
66                     lngCveTipoPaciente = rsTipoPaciente!intCveTipoPaciente
67                     strTipoPaciente = rsTipoPaciente!VCHTIPOPACIENTE
68                     intTipoAgrupa = rsTipoPaciente!intTipoDetalleFactura
                    End If
69                  If strTipo = "CR" Or strTipo = "CA" Then
70                     lngCveFormato = flngFormatoDepto(vgintNumeroDepartamento, 8, "*")
                       'Se agregó esta condición para determinar si es un donativo de tipo CFD
71                  ElseIf Trim(strTipo) = "DO" And blnCFDI = False Then
72                         lngCveFormato = -1  '----Se especifica el valor fijo para imprimir DONATIVOS de tipo CFD (-1)
                         ' Se agregó esta condición para determinar si es un donativo de tipo CFDi
73                  ElseIf Trim(strTipo) = "DO" And blnCFDI = True Then
74                         lngCveFormato = -10  '----Se especifica el valor fijo para imprimir DONATIVOS de tipo CFDi (-10)
                    ElseIf Trim(strTipo) = "RE" Then
                           lngCveFormato = -20  '----Se especifica el valor fijo para imprimir COMPROBANTES DE PAGOS
                    Else
                        '|  Si es una factura de clientes o una factura de membresía de socios
75                       If strTipo = "FA" And (strTipoPaciente = "C" Or strTipoPaciente = "S") Then
76                          lngCveFormato = flngFormatoDepto(vgintNumeroDepartamento, 9, IIf(strTipoPaciente = "S", strTipoPaciente, "*"))
                         Else
                            lngCveFormato = 1
                            'Se verifica si el CFD es para una empresa, para obtener la clave de esta y seleccionar el formato correspondiente
                            If strTipo = "AN" Or strTipo = "AA" Then
                                vlintEmpresaCFD = 0
                            Else
77                              Set rsEmpresaCFD = frsEjecuta_SP(CStr(lngComprobante), "SP_PVSELCVEEMPRESACFD")
78                              If rsEmpresaCFD.RecordCount > 0 And strTipo = "FA" Then
79                                 vlintEmpresaCFD = rsEmpresaCFD!claveEmpresa
                                Else
80                                 vlintEmpresaCFD = 0
                                End If
                            End If
81                          frsEjecuta_SP vgintNumeroDepartamento & "|" & vlintEmpresaCFD & "|" & lngCveTipoPaciente & "|" & strTipoPaciente, "fn_PVSelFormatoFactura2", True, lngCveFormato
                         End If
                    End If
                    ' Se manda imprimir el comprobante
82                  strError = "Error en la generación del archivo PDF del comprobante"
83                  blnMostrarMsjNotificaError = False
84                  If Not fblnImprimeComprobanteDigital(lngComprobante, strTipo, "PDF", lngCveFormato, intTipoAgrupa, strRutaPDF, False) Then 'Exit Function
85                         blnMostrarMsjNotificaError = False
                           intlineaGoto = 86
86                         GoTo NotificaError
                    End If
         Else
             intlineaGoto = 87
87           GoTo NotificaError
         End If
         'Termina generacion de XML y/o PDF
88       fblnGeneraComprobanteDigital = True
89       strError = ""
90       Screen.MousePointer = vbDefault
     End If
     Exit Function
NotificaError:
      If Not CFDiblnBanError Then ' si todavia no se registra un error
             CFDiblnBanError = True
             CFDistrProcesoError = "fblnGeneraComprobantedigital"
          If Err.Number <> 0 Then 'error del código
             CFDiintLineaError = Erl()
             CFDistrDescripError = Err.Description
             CFDilngNumError = Err.Number
             CFDiMostrarMensajeError = True
             Err.Clear
          Else 'llegó con un goto
             CFDiintLineaError = intlineaGoto
             CFDistrDescripError = strError
             CFDilngNumError = -1
             CFDiMostrarMensajeError = blnMostrarMsjNotificaError
          End If
      End If
      If blnCFDI Then 'cfdi
         If CFDiintResultadoTimbrado = 2 Then 'trono el timbrado
            Call pErrorGeneraCFD(1024, CFDistrDescripError, CFDiMostrarMensajeError)
            CFDistrDescripError = "codeCFDi(" & CFDiintResultadoTimbrado & ":" & CFDiblnHaytimbre & ") " & CFDistrDescripError
            vgIntBanderaTImbradoPendiente = 2
         ElseIf CFDiintResultadoTimbrado = 0 Then 'en teoria no llego al timbrado pero primero evaluamos si hay timbre
            If Not CFDiblnHaytimbre Then 'ahora si hay un error antes del timbre
               Call pErrorGeneraCFD(1024, CFDistrDescripError, CFDiMostrarMensajeError)
               CFDistrDescripError = "codeCFDi(" & CFDiintResultadoTimbrado & ":" & CFDiblnHaytimbre & ") " & CFDistrDescripError
               vgIntBanderaTImbradoPendiente = 3
            Else
               Call pErrorGeneraCFD(1276, CFDistrDescripError, CFDiMostrarMensajeError)
               CFDistrDescripError = "codeCFDi(" & CFDiintResultadoTimbrado & ":" & CFDiblnHaytimbre & ") " & CFDistrDescripError
               vgIntBanderaTImbradoPendiente = 0 'el proceso esta correcto falla la impresion del xml o el pdf
            End If
         ElseIf CFDiintResultadoTimbrado = 1 Then 'llego hasta el timbre, y quedo pendiente el timbrado
                vgIntBanderaTImbradoPendiente = 1
                CFDistrDescripError = "codeCFDi(" & CFDiintResultadoTimbrado & ":" & CFDiblnHaytimbre & ") " & CFDistrDescripError
         End If
         'si hay timbre, aunque exista un error, se queda la información como timbrada
         fblnGeneraComprobanteDigital = CFDiintResultadoTimbrado = 0 And CFDiblnHaytimbre
      Else 'cfd
         If CFDistrProcesoError = "fblnGeneraComprobantedigital" Then
            If CFDiintLineaError < 36 Then 'antes de la impresión el xml por ejemplo, para atras y cancelamos la factura
               CFDistrDescripError = "codeCFD(" & "fblnGeneraComprobantedigital" & ":" & CFDiintLineaError & ") " & CFDistrDescripError
               vgIntBanderaTImbradoPendiente = 3
               fblnGeneraComprobanteDigital = False
            Else 'empieza la impresión aqui ya se debe dejar pasar correctamente, por impresiones no detenemos el proceso
               CFDistrDescripError = "codeCFD(" & "fblnGeneraComprobantedigital" & ":" & CFDiintLineaError & ") " & CFDistrDescripError
               vgIntBanderaTImbradoPendiente = 0
               fblnGeneraComprobanteDigital = True
            End If
         ElseIf CFDistrProcesoError = "fblnGeneraCFD" Then 'en cualquier parte de este proceso que ocurra en error entonces detenemos
                CFDistrDescripError = "codeCFD(" & "fblnGeneraCFD" & ":" & CFDiintLineaError & ") " & CFDistrDescripError
                vgIntBanderaTImbradoPendiente = 3
                fblnGeneraComprobanteDigital = False
         Else 'cualquier otro proceso donde se envie error que no debe de pasar
               CFDistrDescripError = "codeCFD(" & CFDistrProcesoError & ":" & CFDiintLineaError & ") " & CFDistrDescripError
               vgIntBanderaTImbradoPendiente = 3
               fblnGeneraComprobanteDigital = False
         End If
      End If
      
      'registramos el error
      frsEjecuta_SP CFDilngNumError & "|" & Left(CFDistrDescripError, 200) & "|" & cgstrModulo & "|" & Left(CFDistrProcesoError, 50) & " Linea:" & CFDiintLineaError & "|" & "", "SP_GNINSREGISTROERRORES", True
      'Se eliminan archivos XML y PDF finales (debido a que no se tenian configuradas ambas rutas de descarga)
      If fsoComprobante.FileExists(strRutaXML) Then fsoComprobante.DeleteFile strRutaXML
      If fsoComprobante.FileExists(strRutaPDF) Then fsoComprobante.DeleteFile strRutaPDF
      '----------------------------------------------------------------------------------------------------------------------------
End Function




' -----------------------------------------------------------------------------------------
' |  Crea una ruta con direcotio y subdirectorios
' -----------------------------------------------------------------------------------------
Public Function pCreaDirectorio(ByVal sDirPath As String) As Boolean

On Error GoTo Error_Handler
    If Right(sDirPath, 1) <> "\" Then sDirPath = sDirPath & "\"
    '|  Si la ruta no existe la crea, si existe no hace nada.
    If Len(Dir(sDirPath, vbDirectory)) = 0 Then
        Call MakeSureDirectoryPathExists(sDirPath)
        pCreaDirectorio = CBool(Len(Dir(sDirPath, vbDirectory)))
    End If
    Exit Function
Error_Handler:
End Function
'----------------------------------------------------------------------------------------
'|  Valida que con la información obtenida se pueda generar el comprobante fiscal digital
'----------------------------------------------------------------------------------------
Public Sub pMuestraErrorDatosXML(lngResultado As Long)
    Dim strError As String
    
    Select Case lngResultado
        Case -1
            strError = ""
        Case 1
            strError = "Fecha emisión"
        Case 2
            strError = "Número aprobación"
        Case 3
            strError = "Año aprobación"
        Case 4
            strError = "Subtotal"
        Case 5
            strError = "Total"
        Case 6
            strError = "Folio"
        Case 7
            strError = "RFC del emisor"
        Case 8
            strError = "Nombre del emisor"
        Case 9
            strError = "Calle del domicilio fiscal del emisor"
        Case 10
            strError = "Municipio del domicilio fiscal del emisor"
        Case 11
            strError = "Estado del domicilio fiscal del emisor"
        Case 12
            strError = "País del domicilio fiscal del emisor"
        Case 13
            strError = "Código postal del domicilio fiscal del emisor"
        Case 14
            strError = "RCF del receptor"
        Case 15
            strError = "Pais del receptor"
        Case 16
            strError = "Código postal del receptor"
        Case 17
            strError = "Código postal de la sucursal"
        Case 18
            strError = "Régimen fiscal"
        Case 19
            strError = "Método de pago"
        Case 20
            strError = "Lugar de expedición"
        Case 21
            strError = "Cuenta o referencia de pago"
    End Select
    If lngResultado > 0 Then strError = "Información incorrecta: " & strError
    '|  El archivo XML base contiene información inválida.
    MsgBox SIHOMsg(1) & "." & vbNewLine & vbNewLine & "El archivo XML base contiene información inválida: " & vbNewLine & vbCrLf & "- " & strError & ".", vbCritical, "Mensaje"
End Sub
Public Function fblnGeneraCFD(lngComprobante As Long, strTipo As String, blnCFDI As Boolean, lngCveAddenda As Long) As Boolean
    
    Dim strSentencia As String
    Dim RsComprobante As New ADODB.Recordset
    Dim stmComprobante As New ADODB.Stream
    Dim lngError As Long
    Dim strContrasena As String
    Dim strNombreBase As String
    Dim strArchivoXMLNoCert As String
    Dim strArchivoXMLFirmado As String
    Dim strArchivoXMLRequestTimbrado As String
    Dim strArchivoLlave As String
    Dim strArchivoCertificado As String
    Dim strComprobanteFiscalFirmado As String
    Dim strCadenaOriginal As String
    Dim strSello As String
    Dim strCertificadoString As String
    Dim fsoComprobante As New FileSystemObject
    Dim tsComprobante As TextStream
    Dim strLinea As String
    Dim strArchivoXMLBase As String
    Dim strDestino As String
    Dim intAno As Integer
    Dim strParametros As String
    Dim XMLSolicitudTimbrado As MSXML2.DOMDocument
    Dim strArchivoXMLFirmadoTimbrado As String
    Dim UUID As String
    Dim strCFDiTimbrado As String
    Dim strNoCertificadoSAT As String
    Dim strSelloSAT As String
    Dim strFechaTimbrado As String
    Dim strCadenaTFD As String
    Dim RefID As String     'Identificador de CFDi, para el archivo Request Timbrado (RFC Emisor (3 primeros y 3 últimos) + Tipo + Serie||Folio)
    Dim vlaryParametrosSalida() As String
    Dim strComplementoAddenda As String
    Dim XMLAddendado As MSXML2.DOMDocument
    Dim strCFDaddendado As String
    Dim rsPAC As New ADODB.Recordset
    Dim intPAC As Integer
    Dim lngTiempoRestanteHrs As Long
    Dim lngTiempoRestanteMins As Long
    Dim strTiempoRestanteTotal As String
    Dim strError As String 'Esta variable almacena el proceso en el cual se presenta un error, para poder ser detectado más rápidamente
    Dim blnMostrarMsjNotificaError As Boolean 'Esta varialble indica si se mostrará un mensaje de error, en caso de que se presente alguno
    
    'Sistema
    Dim strFechaHoraServer As String
    Dim strFechaServer As String
    Dim strHoraServer As String
    Dim strFechaHoraServerLetra As String
    
    'Certificado
    Dim strCerRFC As String
    Dim strCerFechaHoraValidaDesde As String
    Dim strCerFechaHoraValidaDesdeLetra As String
    Dim strCerFechaValidaDesde As String
    Dim strCerHoraValidaDesde As String
    Dim strCerFechaHoraValidaHasta As String
    Dim strCerFechaHoraValidaHastaLetra As String
    Dim strCerFechaValidaHasta As String
    Dim strCerHoraValidaHasta As String
    Dim strCerEmpresaEmisora As String
    Dim strCerNumCertificado As String
    Dim intlineaGoto As Integer
    
On Error GoTo NotificaError:
    
     'Se obtienen fecha y hora (formateadas) del servidor para las validaciones de la vigencia del certificado
1    strFechaHoraServer = Format(fdtmServerFechaHora, "DD/MM/YYYY HH:MM:SS")
2    strFechaServer = Mid(strFechaHoraServer, 1, 10)
3    strHoraServer = Mid(strFechaHoraServer, 12)
4    strFechaHoraServerLetra = Mid(strFechaHoraServer, 1, 3) & fstrMesLetra(Mid(strFechaHoraServer, 4, 2), False) & Mid(strFechaHoraServer, 6)
    
     'Se elimina el contenido de la carpeta temporal
5    strDestino = Environ$("temp") & "\dA-Ms19"
6    pCreaDirectorio strDestino
7    On Error Resume Next
    
     'Checa que el directorio se haya creado, para proceder a eliminar el archivo (evita el error 53)
8    If Dir$(strDestino & "\") <> "" Then
9        Kill strDestino & "\*.*"
10        If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
11            Err.Clear
          Else
13              Err.Raise Err.Number
          End If
     End If

     '|  Inicializa nombre de archivos de trabajo y variables de control
15    strNombreBase = strDestino & "\" & strTipo & "_" & lngComprobante
16    strArchivoXMLBase = strNombreBase & ".xml"
      strArchivoXMLNoCert = strNombreBase & "NoCert.xml"
17    strArchivoXMLFirmado = strNombreBase & "Firmado.xml"
18    strArchivoXMLRequestTimbrado = strNombreBase & "RequestTimbrado.xml"
19    strArchivoXMLFirmadoTimbrado = strNombreBase & "Firmado_Timbrado.xml"
20    strArchivoLlave = strNombreBase & ".key"
21    strArchivoCertificado = strNombreBase & ".cer"
22    strError = ""
23    blnMostrarMsjNotificaError = True
      '|  Descarga archivo XML firmado en directorio local del cliente
24    If Not fblnDescargaXML(lngComprobante, strTipo, strArchivoXMLBase) Then 'Exit Function
25       strError = "Ocurrió un error al descargar el archivo XML."
26       blnMostrarMsjNotificaError = False
         intlineaGoto = 27
27       GoTo NotificaError
      End If
      
      '|  Consulta archivo .CER, .KEY y Contraseña almacenado en la base de datos
28    strSentencia = "SELECT BLBCERTIFICADO " & _
                   "     , BLBLLAVE " & _
                   "     , VCHCONTRASENA " & _
                   "     , VCHRFC " & _
                   "  FROM CNEMPRESACONTABLE " & _
                   " WHERE CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
29    Set RsComprobante = frsRegresaRs(strSentencia)
    
      '|  Descarga archivo Certificado en directorio local del cliente
30    If Not IsNull(RsComprobante!BLBCERTIFICADO) Then
31       With stmComprobante
32            .Type = adTypeBinary
33            .Open
34            .Write RsComprobante!BLBCERTIFICADO
35            .SaveToFile strArchivoCertificado, adSaveCreateOverWrite
36            .Close
         End With
        
         'Se digiere el contenido del certificado...
37        strError = "Error en la digestión del archivo .CER"
38        strCerRFC = Trim(satQueryCert(strArchivoCertificado, "rfc"))
39        strCerRFC = Trim(Replace(Replace(Replace(strCerRFC, "-", ""), "_", ""), " ", ""))
40        strCerNumCertificado = Trim(satQueryCert(strArchivoCertificado, "serialNumber"))
41        strCerEmpresaEmisora = Trim(satQueryCert(strArchivoCertificado, "organizationName"))
42        strCerFechaHoraValidaDesde = Trim(satQueryCert(strArchivoCertificado, "notBefore"))
43        strCerFechaHoraValidaHasta = Trim(satQueryCert(strArchivoCertificado, "notAfter"))
        
          'Formateo y desglose de las fechas y horas del certificado
44        strError = "Error de formateo de las fecha de vigencia del certificado"
45        strCerFechaHoraValidaDesde = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaDesde, 12, 8)
46        strCerFechaValidaDesde = Mid(strCerFechaHoraValidaDesde, 1, 10)
47        strCerHoraValidaDesde = Mid(strCerFechaHoraValidaDesde, 12)
48        strCerFechaHoraValidaDesdeLetra = Mid(strCerFechaHoraValidaDesde, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaDesde, 4, 2), False) & Mid(strCerFechaHoraValidaDesde, 6)
49        strCerFechaHoraValidaHasta = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaHasta, 12, 8)
50        strCerFechaValidaHasta = Mid(strCerFechaHoraValidaHasta, 1, 10)
51        strCerHoraValidaHasta = Mid(strCerFechaHoraValidaHasta, 12)
52        strCerFechaHoraValidaHastaLetra = Mid(strCerFechaHoraValidaHasta, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaHasta, 4, 2), False) & Mid(strCerFechaHoraValidaHasta, 6)
          
          'Validaciones simples del archivo .CER
          'Si se utiliza un certificado de pruebas, se omiten las validaciones
53        If strCerRFC <> "ACO560518KW7" Then
54           If strCerRFC = "" Then 'Si el RFC del certificado está vació, significa que no se ha instalado el complemento de sellado (librerías de FirmaSAT en system32)
55              MsgBox SIHOMsg(1) & "." & vbCrLf & vbCrLf & "No se detectó el complemento de sellado de comprobantes. ", vbCritical, "Mensaje"
56              strError = "No se detectó el complemento de sellado de comprobantes."
57              blnMostrarMsjNotificaError = False
                intlineaGoto = 58
58              GoTo NotificaError
59           ElseIf strCerRFC <> Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) Then 'Compara el RFC del certificado vs el RFC de la empresa contable
60                  MsgBox "El certificado configurado en el sistema no corresponde a la empresa contable emisora: " & vbNewLine & vbNewLine & _
                                                        "- RFC de la empresa:" & vbTab & Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) & vbNewLine & _
                                                        "- RFC del certificado:" & vbTab & strCerRFC, vbCritical + vbOKOnly, "Mensaje"
61                  strError = "El certificado configurado en el sistema no corresponde a la empresa contable emisora"
62                  blnMostrarMsjNotificaError = False
                    intlineaGoto = 63
63                  GoTo NotificaError
64           ElseIf CDate(strCerFechaValidaDesde) > CDate(strFechaServer) Then 'La fecha de inicio validez del certificado aún no entra en vigor
65                  MsgBox "El certificado configurado en el sistema aún no entra en su período de validez: " & vbNewLine & vbNewLine & _
                                                        "- Válido a partir de:" & vbTab & strCerFechaHoraValidaDesdeLetra & vbNewLine & _
                                                        "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
66                  strError = "El certificado configurado en el sistema aún no entra en período de validez"
67                  blnMostrarMsjNotificaError = False
                    intlineaGoto = 68
68                  GoTo NotificaError
69           ElseIf CDate(strCerFechaValidaHasta) < CDate(strFechaServer) Then 'La fecha de expiración del certificado ha excedido su validez
70                  MsgBox "El certificado configurado en el sistema excede su período de validez: " & vbNewLine & vbNewLine & _
                                                        "- Válido hasta el:" & vbTab & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                                        "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
71                  strError = "El certificado configurado en el sistema excede su período de validez"
72                  blnMostrarMsjNotificaError = False
                    intlineaGoto = 73
73                  GoTo NotificaError
74           ElseIf CDate(strCerFechaValidaDesde) = CDate(strFechaServer) Then 'La fecha de inicio de validez del certificado es igual a la fecha actual
75                    If Format(CDate(strCerHoraValidaDesde), "HH:MM:SS") > Format(CDate(strHoraServer), "HH:MM:SS") Then 'Se compara la hora de inicio de validez con la hora actual
76                       MsgBox "El certificado configurado en el sistema aún no entra en su período de validez: " & vbNewLine & vbNewLine & _
                                                            "- Válido a partir de:" & vbTab & strCerFechaHoraValidaDesdeLetra & vbNewLine & _
                                                            "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
77                       strError = "El certificado configurado en el sistema aún no entra en período de validez"
78                       blnMostrarMsjNotificaError = False
79                       intlineaGoto = 80
80                       GoTo NotificaError
                    End If
81           ElseIf CDate(strCerFechaValidaHasta) = CDate(strFechaServer) Then 'La fecha de expiración del certificado es igual a la fecha actual
82                    If Format(CDate(strCerHoraValidaHasta), "HH:MM:SS") > Format(CDate(strHoraServer), "HH:MM:SS") Then 'Certificado válido por pocas horas
83                       lngTiempoRestanteHrs = DateDiff("h", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
84                       lngTiempoRestanteMins = DateDiff("n", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
85                       strTiempoRestanteTotal = CStr(lngTiempoRestanteHrs) & " horas " & CStr(Abs(lngTiempoRestanteMins - (60 * lngTiempoRestanteHrs))) & " minutos!"
86                       MsgBox "¡El certificado expirará en " & strTiempoRestanteTotal & ", por favor solicite uno nuevo al SAT.", vbExclamation, "Mensaje"
                      Else 'Certificado expirado
87                       MsgBox "El certificado configurado en el sistema excede su período de validez: " & vbNewLine & vbNewLine & _
                                                            "- Válido hasta el:" & vbTab & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                                            "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
88                       strError = "El certificado configurado en el sistema excede su período de validez"
89                       blnMostrarMsjNotificaError = False
                         intlineaGoto = 90
90                       GoTo NotificaError
                    End If
                End If
            Else
91              If fblnAutoVerificacion Then
                   'Este mensaje es para que los clientes se percaten de que estén utilizando un certificado de pruebas
                   '(Solamente se mostrará, si se tiene habilitado el bit de autoverificación y si el esquema en el que se está probando, no es un esquema SiC (RFC = CSI040928HX4))
92                   If Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) <> "CSI040928HX4" Then
93                      MsgBox "Se está utilizando un certificado de pruebas: " & vbNewLine & vbNewLine & _
                                        "- RFC del certificado:  " & strCerRFC & vbNewLine & _
                                        "- Válido del  " & strCerFechaHoraValidaDesdeLetra & " al " & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                        "- Número de certificado:  " & strCerNumCertificado & vbNewLine & _
                                        "- Empresa certificadora:  " & strCerEmpresaEmisora, vbInformation + vbOKOnly, "Mensaje"
                    End If
                End If
            End If
      Else
94        strError = "No se ha configurado un archivo de certificado .CER para emitir comprobantes fiscales digitales"
          intlineaGoto = 95
95        GoTo NotificaError
      End If
    
      '|  Descarga archivo .KEY en directorio local del cliente
96    If Not IsNull(RsComprobante!BLBLLAVE) Then
97       With stmComprobante
98            .Type = adTypeBinary
100           .Open
101           .Write RsComprobante!BLBLLAVE
102            .SaveToFile strArchivoLlave, adSaveCreateOverWrite
103            .Close
         End With
      Else
104        strError = "No existe configurada un archivo llave .KEY para emitir facturas comprobantes fiscales digitales"
           intlineaGoto = 105
105        GoTo NotificaError
      End If
    
      '| Almacena contraseña
106   If Not IsNull(RsComprobante!vchContrasena) Then
107      strContrasena = fstrEncrypt2(fstrConvierteChr(RsComprobante!vchContrasena), RsComprobante!vchRFC)
      Else
108      strError = "No existe configurada una contraseña para emitir facturas comprobantes fiscales digitales"
         intlineaGoto = 109
109      GoTo NotificaError
      End If
        
    'Se valida que los archivos .CER, .KEY y la contraseña sean correctos...
110    lngError = SAT_CheckKeyAndCert(strArchivoLlave, strContrasena, strArchivoCertificado, 0)
111    If lngError <> 0 Then
112        strError = fstrErrorFirmaSAT(lngError)
           intlineaGoto = 113
113        GoTo NotificaError
       End If
        
       If blnCFDI Then
            lngError = SAT_InsertCert(strArchivoXMLNoCert, strArchivoXMLBase, strArchivoCertificado, 1)
            If lngError <> 0 Then
               strError = fstrErrorFirmaSAT(lngError)
               GoTo NotificaError
            End If
       End If
      
        
    '-----------------------------------------------------------------------
    '|  Genera XML firmado y decodifica Certificado, Cadena original y Sello
    '-----------------------------------------------------------------------
    
       '|Genera XML firmado
114    intAno = Year(fdtmServerFecha)
       If blnCFDI Then
115        lngError = SAT_SignXml(strArchivoXMLFirmado, strArchivoXMLNoCert, strArchivoLlave, strContrasena, strArchivoCertificado, 0)
116        If lngError <> 0 Then
117           strError = fstrErrorFirmaSAT(lngError)
              intlineaGoto = 118
118           GoTo NotificaError
           End If
       End If
    
       'Valida el sello
       If blnCFDI Then
119        lngError = SAT_VerifySignature(strArchivoXMLFirmado, strArchivoCertificado, 0)
120        If lngError <> 0 Then
121            strError = fstrErrorFirmaSAT(lngError)
               intlineaGoto = 122
122            GoTo NotificaError
           End If
       End If
    
       '|Valida que el XML generado este correcto
       If blnCFDI Then
123        lngError = SAT_ValidateXml(strArchivoXMLFirmado, 0)
124        If lngError <> 0 Then
125           strError = fstrErrorFirmaSAT(lngError)
              intlineaGoto = 126
126           GoTo NotificaError
           End If
       End If
    
       '|  Obtiene cadena original
127    strCadenaOriginal = fstrCadenaOriginal(strArchivoXMLFirmado, blnCFDI)
128    If Len(strCadenaOriginal) = 0 Then
129       strError = "Ocurrió un error al generar la cadena original."
130       blnMostrarMsjNotificaError = False
          intlineaGoto = 131
131       GoTo NotificaError
       End If
    
       '|  Extrae el string del certificado
       
132        strCertificadoString = satGetCertAsString(strArchivoXMLFirmado)
            If blnCFDI Then
133            If Len(strCertificadoString) = 0 Then
                  '|  No se pudo extraer el string del certificado del comprobante generado. ¡Avisar al área de sistemas!
134               MsgBox SIHOMsg(1085), vbCritical, "Mensaje"
135               strError = SIHOMsg(1085)
136               blnMostrarMsjNotificaError = False
                  intlineaGoto = 137
137               GoTo NotificaError
               End If
            End If

    '|  Obtiene sello digital
        
138     strSello = satMakeSignatureFromXml(strArchivoXMLBase, strArchivoLlave, strContrasena)
        If blnCFDI Then
139            If Len(strSello) = 0 Then
                   '|  No se pudo obtener el sello digital del comprobante generado. ¡Avisar al área de sistemas!
140                MsgBox SIHOMsg(1028), vbCritical, "Mensaje"
141                strError = SIHOMsg(1028)
142                blnMostrarMsjNotificaError = False
                   intlineaGoto = 143
143                GoTo NotificaError
               End If
        End If
       '-----------------------------------------------------------------------------
       '|  Inserta XML firmado, Cadena original y Sello en GNCOMPROBANTEFISCALDIGITAL
       '-----------------------------------------------------------------------------
144    strComprobanteFiscalFirmado = fstrConvierteArchivoUTF8(strArchivoXMLFirmado)
        
       '|  Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL con lo datos obtenidos
145    strSentencia = "SELECT VCHSERIECOMPROBANTE, VCHFOLIOCOMPROBANTE, VCHRFCEMISOR, CLBCOMPROBANTEFISCAL, VCHNUMEROCERTIFICADO, CLBCADENAORIGINAL, CLBSELLODIGITAL, VCHSELLO, VCHCERTIFICADO" & _
                       "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                       " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                       "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
                       
146    Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
147    With RsComprobante
            'Se modificó esta linea debido a la actualización del FirmaSAT 4.1.0 (generaba un "?" al inicio de la cadena en CFD, por eso se agregó el MID)
148            !CLBCOMPROBANTEFISCAL = Mid(strComprobanteFiscalFirmado, 2, Len(strComprobanteFiscalFirmado) - 1)
149            !VCHNUMEROCERTIFICADO = strCerNumCertificado
150            !CLBCADENAORIGINAL = strCadenaOriginal
151            !CLBSELLODIGITAL = strSello
152            !VCHSELLO = strSello
153            !VCHCERTIFICADO = strCertificadoString
154            .Update
       End With
       ' Se hicieron cambios debido a nuevos requerimientos de buzón fiscal
       ' Nueva estructura: Código de buzón fiscal de SiC = "CSI1209" + RFC Emisor (3 primeros y 3 últimos) + Tipo + IDComprobante + Serie||Folio Longitud máxima = 32 caracteres
155    RefID = "CSI1209" & Trim(Left(Trim(RsComprobante!VCHRFCEMISOR), 3) & Right(Trim(RsComprobante!VCHRFCEMISOR), 3)) & Trim(strTipo) & lngComprobante & Trim(IIf(IsNull(RsComprobante!VCHSERIECOMPROBANTE), "", Trim(RsComprobante!VCHSERIECOMPROBANTE) & IIf(IsNull(RsComprobante!VCHFOLIOCOMPROBANTE), "", Trim(RsComprobante!VCHFOLIOCOMPROBANTE))))
156    If blnCFDI Then
          '----------------------------------------
          '|  Inicia el proceso de timbrado de CFDi
          '----------------------------------------
          'Se carga el XML para solicitar el request de timbrado
157       Set XMLSolicitudTimbrado = New MSXML2.DOMDocument
158       XMLSolicitudTimbrado.Load (strArchivoXMLFirmado)
          'Se ejecuta el proceso de timbrado...
159       strError = "Error en el proceso de timbrado"
160       TimbrarCFDI XMLSolicitudTimbrado, RefID, strArchivoXMLRequestTimbrado
          'Se validan los error en el proceso de timbrado
161       If CFDiblnBanError Then
             CFDiblnBanError = False
             intlineaGoto = 162 '*
162          GoTo NotificaError
          End If
          'Se graba el archivo timbrado FINAL en la carpeta temporal
163       XMLSolicitudTimbrado.Save strArchivoXMLFirmadoTimbrado
          'Se asigna el valor del UUID a la variable para el mensaje
164       UUID = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@UUID").Text
          
          'Validación del mensaje de error en base al PAC configurado:
165       If Trim(UUID) = "" Then ' se supone que esto se valida en la función del timbrado, pero por si acaso lo dejamos
             intlineaGoto = 166
166          GoTo NotificaError
          End If
          
          '---------------------------------------------------
          '|Se graba el contenido del XML en strCFDiTimbrado
          '---------------------------------------------------
167       strError = "Error al codificar a UTF8 el comprobante fiscal digital firmado"
168       strCFDiTimbrado = fstrConvierteArchivoUTF8(strArchivoXMLFirmadoTimbrado)
          '|Se obtienen los datos obtenidos con el timbre (incluyendo el UUID)
169       strError = "Error al extraer el contenido del complemento de timbrado"
          If vgstrVersionCFDI = "3.2" Then
170         strNoCertificadoSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@noCertificadoSAT").Text
171         strSelloSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@selloSAT").Text
          Else
            strNoCertificadoSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@NoCertificadoSAT").Text
            strSelloSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@SelloSAT").Text
          End If
172       strFechaTimbrado = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@FechaTimbrado").Text
          'Se formatea la fecha de timbrado
173       strError = "Error al formatear la fecha de timbrado"
174       strFechaTimbrado = Mid(strFechaTimbrado, 9, 2) & "/" & fstrMesLetra(Mid(strFechaTimbrado, 6, 2), False) & "/" & Mid(strFechaTimbrado, 1, 4) & "  " & Mid(strFechaTimbrado, 12, 8)
        
          'Se obtiene la cadena del complemento TFD
175        strCadenaTFD = fstrCadenaOriginalTFD(strArchivoXMLFirmadoTimbrado)
176        If Len(strCadenaTFD) = 0 Then
177           blnMostrarMsjNotificaError = False
178           strError = "Error al obtener la cadena del complemento TFD"
              intlineaGoto = 178
179           GoTo NotificaError
           End If

        '|  Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL con lo datos obtenidos
180        strSentencia = "SELECT CLBCFDITIMBRADO, VCHCERTIFICADOSAT, VCHSELLOSAT, VCHFECHATIMBRADO, VCHUUID, VCHCADENATFD" & _
                       "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                       " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                       "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
                       
181        Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
182        With RsComprobante
               'inserta el siguiente encabezado si es que no lo tiene el xml <?xml version="1.0" encoding="UTF-8"?>
183            If InStr(1, strCFDiTimbrado, "<?xml version=" & Chr(34) & "1.0" & Chr(34) & " encoding=" & Chr(34) & "UTF-8" & Chr(34) & "?>", 1) = 0 Then
184               strCFDiTimbrado = "<?xml version=" & Chr(34) & "1.0" & Chr(34) & " encoding=" & Chr(34) & "UTF-8" & Chr(34) & "?>" & Chr(13) & strCFDiTimbrado
               End If
185            !CLBCFDITIMBRADO = strCFDiTimbrado 'En los CFDi si se conserva la cadena completa, por eso se eliminó el MID de arriba
186            !VCHCERTIFICADOSAT = strNoCertificadoSAT
187            !VCHSELLOSAT = strSelloSAT
188            !VCHFECHATIMBRADO = strFechaTimbrado
189            !VCHUUID = UUID
190            !VCHCADENATFD = strCadenaTFD
200            .Update
201        End With
       Else
        '|  Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL con lo datos obtenidos
        strSentencia = "SELECT CLBCFDITIMBRADO, VCHCERTIFICADOSAT, VCHSELLOSAT, VCHFECHATIMBRADO, VCHUUID, VCHCADENATFD" & _
                       "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                       " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                       "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
                       
        Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
        With RsComprobante
               'inserta el siguiente encabezado si es que no lo tiene el xml <?xml version="1.0" encoding="UTF-8"?>
            If InStr(1, strCFDiTimbrado, "<?xml version=" & Chr(34) & "1.0" & Chr(34) & " encoding=" & Chr(34) & "UTF-8" & Chr(34) & "?>", 1) = 0 Then
               strCFDiTimbrado = "<?xml version=" & Chr(34) & "1.0" & Chr(34) & " encoding=" & Chr(34) & "UTF-8" & Chr(34) & "?>" & Chr(13) & strCFDiTimbrado
               End If
            !VCHUUID = Null
            .Update
        End With
       End If
       
       '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$              Inicio de Complemento Addenda             '$$$$$$$$$$$$$$$$$$$$$$$$$$
       'Si el comprobante maneja una addenda...
202    If lngCveAddenda <> 0 Then
203       strError = "Error en la generación del complemento addenda"
          'Se ejecuta el SP que regresa el complemento ADDENDA para el CFD
204        pCargaArreglo vlaryParametrosSalida, "|" & adBSTR 'adVarChar
205        strParametros = CStr(lngCveAddenda) & "|" & CStr(lngComprobante) & "|" & Trim(strTipo)
206        frsEjecuta_SP strParametros, "SP_GNADDENDAXML", , , vlaryParametrosSalida
207        pObtieneValores vlaryParametrosSalida, strComplementoAddenda
208        If blnCFDI = True Then '-----------------------------------------------------------------------------------CFDi
209           strCFDaddendado = fstrConvierteArchivoUTF8(strArchivoXMLFirmadoTimbrado)
              'Nota: vbCrLf en la linea de abajo sirve como un salto de linea
210           strCFDaddendado = Replace(strCFDaddendado, "</cfdi:Complemento></cfdi:Comprobante>", "</cfdi:Complemento>" & strComplementoAddenda & "</cfdi:Comprobante>")
              '|Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL para agregar la addenda
211           strSentencia = "SELECT CLBCFDITIMBRADO" & _
                             "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                             " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                             "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
212           Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
213           With RsComprobante
214                !CLBCFDITIMBRADO = strCFDaddendado 'En los CFDi si se conserva la cadena completa, por eso se eliminó el MID de abajo
215                .Update
216           End With
              '|  Descarga archivo XML ya con la addenda agregada (se sobreescribe el archivo sin la addenda)
217           fblnDescargaXMLCFDi lngComprobante, strTipo, strArchivoXMLFirmadoTimbrado
           Else '---------------------------------------------------------------------------------------------------------CFD
218           strCFDaddendado = fstrConvierteArchivoUTF8(strArchivoXMLFirmado)
219           strCFDaddendado = Replace(strCFDaddendado, "</Impuestos></Comprobante>", "</Impuestos>" & strComplementoAddenda & "</Comprobante>")
              '|  Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL para agregar la addenda
220           strSentencia = "SELECT CLBCOMPROBANTEFISCAL" & _
                             "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                             " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                             "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
221           Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
222           With RsComprobante
223                !CLBCOMPROBANTEFISCAL = Mid(strCFDaddendado, 2, Len(strCFDaddendado) - 1)
224               .Update
              End With
              '|  Descarga archivo XML ya con la addenda agregada (se sobreescribe el archivo sin la addenda)
225           fblnDescargaXML lngComprobante, strTipo, strArchivoXMLFirmado
           End If
       End If

       '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$              Final de Complemento Addenda             '$$$$$$$$$$$$$$$$$$$$$$$$$$$
   
       '|  Elimina archivos de trabajo
226    If fsoComprobante.FileExists(strArchivoXMLBase) Then fsoComprobante.DeleteFile strArchivoXMLBase
       If fsoComprobante.FileExists(strArchivoXMLNoCert) Then fsoComprobante.DeleteFile strArchivoXMLNoCert
227    If fsoComprobante.FileExists(strArchivoXMLFirmado) Then fsoComprobante.DeleteFile strArchivoXMLFirmado
228    If fsoComprobante.FileExists(strArchivoLlave) Then fsoComprobante.DeleteFile strArchivoLlave
229    If fsoComprobante.FileExists(strArchivoCertificado) Then fsoComprobante.DeleteFile strArchivoCertificado
230    If fsoComprobante.FileExists(strArchivoXMLFirmadoTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLFirmadoTimbrado
231    If fsoComprobante.FileExists(strArchivoXMLRequestTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLRequestTimbrado
232    fblnGeneraCFD = True
233    strError = ""
       Exit Function

NotificaError:
       If Not CFDiblnBanError Then 'si no existe otro error anterior
              CFDiblnBanError = True
              If Err.Number <> 0 Then 'llega como error del código
                 CFDistrProcesoError = "fblnGeneraCFD"
                 CFDiintLineaError = Erl()
                 CFDistrDescripError = Err.Description
                 CFDilngNumError = Err.Number
                 CFDiMostrarMensajeError = True
                 Err.Clear
              Else 'llega de un goto
                 If intlineaGoto = 162 Or intlineaGoto = 166 Then
                    If intlineaGoto = 166 Then 'no se encontró el uuid.
                       CFDistrProcesoError = "fblnGeneraCFD"
                       CFDiintLineaError = 166
                       CFDistrDescripError = "No se pudó obtener el folio fiscal."
                       CFDilngNumError = -1
                       CFDiMostrarMensajeError = False
                       CFDiblnHaytimbre = False 'si no hay UUID, no hay timbre.
                       CFDiintResultadoTimbrado = 1 ' lo dejamos pendiente timbre.
                    End If
                    If blnNOMensajeErrorPAC = False And CFDiintResultadoTimbrado = 1 Then
                       'Se obtiene el PAC con el que se realizó el proceso de timbrado (Buzón Fiscal: INTIDPAC = 1) (PAX: INTIDPAC = 2)
                       Set rsPAC = frsEjecuta_SP(CStr(vgintClaveEmpresaContable), "SP_GNSELCONFIGPAC")
                       If rsPAC.RecordCount > 0 Then
                          intPAC = Val(rsPAC!PAC)
                          Select Case intPAC
                                 Case 1 '(Buzón Fiscal: INTIDPAC = 1)
                                     MsgBox "No se pudo timbrar el CFDi, verifique lo siguiente antes de intentar de nuevo: " & vbNewLine & vbNewLine & _
                                                           "1. Que exista una conexión a Internet." & vbNewLine & _
                                                           "2. Las configuraciones de conexión del PAC sean correctas." & vbNewLine & _
                                                           "3. Si el PAC requiere un certificado X.509: " & vbNewLine & _
                                                           "    a) Que el certificado esté instalado en el equipo." & vbNewLine & _
                                                           "    b) Que el certificado esté vigente." & vbNewLine & _
                                                           "    c) Que el certificado esté relacionado con el RFC emisor/donatario.", vbExclamation + vbOKOnly, "Mensaje"
                                 Case 2 '(PAX: INTIDPAC = 2)
                                     MsgBox "No se pudo timbrar el CFDi, verifique lo siguiente antes de intentar de nuevo: " & vbNewLine & vbNewLine & _
                                                           "1. Que exista una conexión a Internet." & vbNewLine & _
                                                           "2. Las configuraciones de conexión del PAC sean correctas.", vbExclamation + vbOKOnly, "Mensaje"
                                 End Select
                       Else
                          '|¡No se ha configurado un PAC activo para realizar el servicio de timbrado!
                          MsgBox SIHOMsg(1155), vbCritical, "Mensaje"
                       End If
                    End If
                 Else 'de cualquier otra linea goto
                    CFDistrProcesoError = "fblnGeneraCFD"
                    CFDiintLineaError = intlineaGoto
                    CFDistrDescripError = strError
                    CFDilngNumError = -1
                    CFDiMostrarMensajeError = False
                    Call pErrorGeneraCFD(1156, strError, blnMostrarMsjNotificaError)
                 End If
              End If
       End If
       
       'por alguna razon tróno después de que se realizó el timbrado, entonces la dejamos como pendiente de timbre fiscal (abusado)
       If CFDiintResultadoTimbrado = 0 And CFDiblnHaytimbre Then CFDiintResultadoTimbrado = 1
       'Elimina archivos de trabajo
       If fsoComprobante.FileExists(strArchivoXMLBase) Then fsoComprobante.DeleteFile strArchivoXMLBase
       If fsoComprobante.FileExists(strArchivoXMLNoCert) Then fsoComprobante.DeleteFile strArchivoXMLNoCert
       If fsoComprobante.FileExists(strArchivoXMLFirmado) Then fsoComprobante.DeleteFile strArchivoXMLFirmado
       If fsoComprobante.FileExists(strArchivoLlave) Then fsoComprobante.DeleteFile strArchivoLlave
       If fsoComprobante.FileExists(strArchivoCertificado) Then fsoComprobante.DeleteFile strArchivoCertificado
       If fsoComprobante.FileExists(strArchivoXMLFirmadoTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLFirmadoTimbrado
       If fsoComprobante.FileExists(strArchivoXMLRequestTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLRequestTimbrado
      
       'Se regresa el error de la función
       fblnGeneraCFD = False
End Function

Public Function fblnGeneraComprobanteDigitalnom(lngComprobante As Long, strTipo As String, blnCFDI As Boolean, Optional blnImprime As Boolean) As Boolean
                                                                             
    Dim strParametros As String
    Dim strArchivoXMLBase As String
    Dim alstrParametroSalida() As String
    Dim lngError As Long
    Dim lngCveFormato As Long
    Dim rsTipoPaciente As New ADODB.Recordset
    Dim lngCveTipoPaciente As Long
    Dim strTipoPaciente As String
    Dim intTipoAgrupa As Integer
    Dim strSentencia As String
    Dim rsNota As New Recordset
    Dim rsRutas As New Recordset
    Dim fsoComprobante As New FileSystemObject
    Dim strRutaXML As String
    Dim strRutaPDF As String
    Dim vlBuscaCarpeta As Object
    Dim XMLSolicitudTimbrado As MSXML2.DOMDocument
    Dim UUID As String
    Dim rsRuta As New ADODB.Recordset
    Dim rsEmpresaCFD As New ADODB.Recordset
    Dim vlintEmpresaCFD As Long
    Dim dblTotal As Double
    Dim strMoneda As String
    Dim strCantidadLetras As String
    Dim RsComprobante As New ADODB.Recordset
    Dim strError As String 'Esta variable almacena el proceso en el cual se presenta un error, para poder ser detectado más rápidamente
    Dim blnMostrarMsjNotificaError As Boolean 'Esta varialble indica si se mostrará un mensaje de error, en caso de que se presente alguno
    
On Error GoTo NotificaError:

    'Se pone el cursor del mouse en modo de espera...
    Screen.MousePointer = vbHourglass
    
    'Se inicializan las variables de control
    fblnGeneraComprobanteDigitalnom = False
    strError = ""
    blnMostrarMsjNotificaError = True
   
    'Se regresa a la normalidad el estatus del cursor del mouse...
    Screen.MousePointer = vbDefault
    
    ' Comienza generacion de XML y/o PDF
    strSentencia = "SELECT TRIM(VCHSERIECOMPROBANTE) || TRIM(VCHFOLIOCOMPROBANTE) Folio FROM GNCFDIGITALNOMINA WHERE INTIDCOMPROBANTE = " & lngComprobante '& " 'AND CHRTIPOCOMPROBANTE = '" & strTipo & "'"
    Set rsNota = frsRegresaRs(strSentencia)
    strSentencia = "SELECT VCHRUTAXML, VCHRUTAPDF FROM CNEMPRESACONTABLE WHERE TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
    Set rsRutas = frsRegresaRs(strSentencia)
            
    ' Se modificó el orden de generar los archivos XML y PDF, ahora se genera primero el XML
    ' esto es para que, en caso de que exista error de impresión el XML ya haya sido generado
    strError = "No se ha configurado la ruta de descarga de los archivos XML"
    
    If vgIntBanderaTImbradoPendiente = 0 Then ' solo cuando el timbre se realizó correctamente
        If Trim(rsRutas!vchRutaXML) = "" Then
            GoTo NotificaError
        ElseIf Not IsNull(Trim(rsRutas!vchRutaXML)) Then
            pCreaDirectorio rsRutas!vchRutaXML
            strRutaXML = rsRutas!vchRutaXML & "\" & rsNota!Folio & ".xml"
            
            If blnCFDI Then
                If Not fblnDescargaXMLCFDiNom(lngComprobante, strTipo, strRutaXML) Then 'Exit Function '--------------- CFDi
                    blnMostrarMsjNotificaError = False
                    GoTo NotificaError
                End If
            Else
    '            If Not fblnDescargaXML(lngComprobante, strTipo, strRutaXML) Then 'Exit Function     '--------------- CFD
    '                blnMostrarMsjNotificaError = False
    '                GoTo NotificaError
    '            End If
            End If
            
        Else
            GoTo NotificaError
        End If
    End If
    
    strError = "No se ha configurado la ruta de descarga de los archivos PDF"
    If Trim(rsRutas!vchRutaPDF) = "" Then
        GoTo NotificaError
    ElseIf Not IsNull(Trim(rsRutas!vchRutaPDF)) Then
        pCreaDirectorio rsRutas!vchRutaPDF
        strRutaPDF = rsRutas!vchRutaPDF & "\" & rsNota!Folio & ".pdf"
        
        lngCveTipoPaciente = -2
        strTipoPaciente = ""
        intTipoAgrupa = -1
        Set rsTipoPaciente = frsEjecuta_SP(lngComprobante & "|" & strTipo, "SP_GNSELTIPOPACIENTECFD")
                
        ' Se manda imprimir el comprobante
        strError = "Error en la generación del archivo PDF del comprobante"
        blnMostrarMsjNotificaError = False
        If blnImprime Then
            If Not fblnImprimeComprobanteDigitalNom(lngComprobante, "PDF", strRutaPDF, False) Then   'Exit Function
                blnMostrarMsjNotificaError = False
                GoTo NotificaError
            End If
            If Not fblnImprimeComprobanteDigitalNom(lngComprobante, "NOT", strRutaPDF, False) Then   'Exit Function
                blnMostrarMsjNotificaError = False
                GoTo NotificaError
            End If
        Else
            If Not fblnImprimeComprobanteDigitalNom(lngComprobante, "PDF", strRutaPDF, False) Then   'Exit Function
                blnMostrarMsjNotificaError = False
                GoTo NotificaError
            End If
        End If
        
    Else
        GoTo NotificaError
    End If
        
    ' Termina generacion de XML y/o PDF
    fblnGeneraComprobanteDigitalnom = True
    strError = ""
    Screen.MousePointer = vbDefault
            
    Exit Function

NotificaError:
    'Se reestablece el cursor del mouse
    Screen.MousePointer = vbDefault
    
    'Muestra el mensaje de error
    Call pErrorGeneraCFD(1024, strError, blnMostrarMsjNotificaError)
    
    'Se eliminan archivos XML y PDF finales (debido a que no se tenian configuradas ambas rutas de descarga)
    If fsoComprobante.FileExists(strRutaXML) Then fsoComprobante.DeleteFile strRutaXML
    If fsoComprobante.FileExists(strRutaPDF) Then fsoComprobante.DeleteFile strRutaPDF
    
    'Se regresa el error de la función
    fblnGeneraComprobanteDigitalnom = False
End Function


 Public Function fblnGeneraCFDnom(lngComprobante As Long, strTipo As String, blnCFDI As Boolean, lngCveAddenda As Long, blnMensajePruebas As Boolean) As Boolean
    Dim strSentencia As String
    Dim RsComprobante As New ADODB.Recordset
    Dim stmComprobante As New ADODB.Stream
    Dim lngError As Long
    Dim strContrasena As String
    Dim strNombreBase As String
    Dim strArchivoXMLFirmado As String
    Dim strArchivoXMLRequestTimbrado As String
    Dim strArchivoLlave As String
    Dim strArchivoCertificado As String
    Dim strComprobanteFiscalFirmado As String
    Dim strCadenaOriginal As String
    Dim strSello As String
    Dim strCertificadoString As String
    Dim fsoComprobante As New FileSystemObject
    Dim tsComprobante As TextStream
    Dim strLinea As String
    Dim strArchivoXMLBase As String
    Dim strDestino As String
    Dim intAno As Integer
    Dim strParametros As String
    Dim XMLSolicitudTimbrado As MSXML2.DOMDocument
    Dim strArchivoXMLFirmadoTimbrado As String
    Dim UUID As String
    Dim strCFDiTimbrado As String
    Dim strNoCertificadoSAT As String
    Dim strSelloSAT As String
    Dim strFechaTimbrado As String
    Dim strCadenaTFD As String
    Dim RefID As String     'Identificador de CFDi, para el archivo Request Timbrado (RFC Emisor (3 primeros y 3 últimos) + Tipo + Serie||Folio)
    Dim vlaryParametrosSalida() As String
    Dim strComplementoAddenda As String
    Dim XMLAddendado As MSXML2.DOMDocument
    Dim strCFDaddendado As String
    Dim rsPAC As New ADODB.Recordset
    Dim intPAC As Integer
    Dim lngTiempoRestanteHrs As Long
    Dim lngTiempoRestanteMins As Long
    Dim strTiempoRestanteTotal As String
    Dim strError As String 'Esta variable almacena el proceso en el cual se presenta un error, para poder ser detectado más rápidamente
    Dim blnMostrarMsjNotificaError As Boolean 'Esta varialble indica si se mostrará un mensaje de error, en caso de que se presente alguno
    
    'Sistema
    Dim strFechaHoraServer As String
    Dim strFechaServer As String
    Dim strHoraServer As String
    Dim strFechaHoraServerLetra As String
    
    'Certificado
    Dim strCerRFC As String
    Dim strCerFechaHoraValidaDesde As String
    Dim strCerFechaHoraValidaDesdeLetra As String
    Dim strCerFechaValidaDesde As String
    Dim strCerHoraValidaDesde As String
    Dim strCerFechaHoraValidaHasta As String
    Dim strCerFechaHoraValidaHastaLetra As String
    Dim strCerFechaValidaHasta As String
    Dim strCerHoraValidaHasta As String
    Dim strCerEmpresaEmisora As String
    Dim strCerNumCertificado As String
    
On Error GoTo NotificaError:
    
    vgIntBanderaTImbradoPendiente = 0 '*abusado
    
    'Se obtienen fecha y hora (formateadas) del servidor para las validaciones de la vigencia del certificado
    strFechaHoraServer = Format(fdtmServerFechaHora, "DD/MM/YYYY HH:MM:SS")
    strFechaServer = Mid(strFechaHoraServer, 1, 10)
    strHoraServer = Mid(strFechaHoraServer, 12)
    strFechaHoraServerLetra = Mid(strFechaHoraServer, 1, 3) & fstrMesLetra(Mid(strFechaHoraServer, 4, 2), False) & Mid(strFechaHoraServer, 6)
    
    'Se elimina el contenido de la carpeta temporal
    strDestino = Environ$("temp") & "\dA-Ms19"
    pCreaDirectorio strDestino
    On Error Resume Next
    
    'Checa que el directorio se haya creado, para proceder a eliminar el archivo (evita el error 53)
    If Dir$(strDestino & "\") <> "" Then
        Kill strDestino & "\*.*"
        If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
            Err.Clear
        Else
            Err.Raise Err.Number
        End If
    End If

    '|  Inicializa nombre de archivos de trabajo y variables de control
    strNombreBase = strDestino & "\" & strTipo & "_" & lngComprobante
    strArchivoXMLBase = strNombreBase & ".xml"
    strArchivoXMLFirmado = strNombreBase & "Firmado.xml"
    strArchivoXMLRequestTimbrado = strNombreBase & "RequestTimbrado.xml"
    strArchivoXMLFirmadoTimbrado = strNombreBase & "Firmado_Timbrado.xml"
    strArchivoLlave = strNombreBase & ".key"
    strArchivoCertificado = strNombreBase & ".cer"
    strError = ""
    blnMostrarMsjNotificaError = True
    
    '|  Descarga archivo XML firmado en directorio local del cliente
    If Not fblnDescargaXMLNom(lngComprobante, strTipo, strArchivoXMLBase) Then 'Exit Function
        blnMostrarMsjNotificaError = False
        vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
        
    '|  Consulta archivo .CER, .KEY y Contraseña almacenado en la base de datos
    strSentencia = "SELECT BLBCERTIFICADO " & _
                   "     , BLBLLAVE " & _
                   "     , VCHCONTRASENA " & _
                   "     , VCHRFC " & _
                   "  FROM CNEMPRESACONTABLE " & _
                   " WHERE CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
    Set RsComprobante = frsRegresaRs(strSentencia)
    
    '|  Descarga archivo Certificado en directorio local del cliente
    If Not IsNull(RsComprobante!BLBCERTIFICADO) Then
    
        With stmComprobante
            .Type = adTypeBinary
            .Open
            .Write RsComprobante!BLBCERTIFICADO
            .SaveToFile strArchivoCertificado, adSaveCreateOverWrite
            .Close
        End With
        
        'Se digiere el contenido del certificado...
        strError = "Error en la digestión del archivo .CER"
        strCerRFC = Trim(satQueryCert(strArchivoCertificado, "rfc"))
        strCerRFC = Trim(Replace(Replace(Replace(strCerRFC, "-", ""), "_", ""), " ", ""))
        strCerNumCertificado = Trim(satQueryCert(strArchivoCertificado, "serialNumber"))
        strCerEmpresaEmisora = Trim(satQueryCert(strArchivoCertificado, "organizationName"))
        strCerFechaHoraValidaDesde = Trim(satQueryCert(strArchivoCertificado, "notBefore"))
        strCerFechaHoraValidaHasta = Trim(satQueryCert(strArchivoCertificado, "notAfter"))
        
        'Formateo y desglose de las fechas y horas del certificado
        strError = "Error de formateo de las fecha de vigencia del certificado"
        strCerFechaHoraValidaDesde = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaDesde, 12, 8)
        strCerFechaValidaDesde = Mid(strCerFechaHoraValidaDesde, 1, 10)
        strCerHoraValidaDesde = Mid(strCerFechaHoraValidaDesde, 12)
        strCerFechaHoraValidaDesdeLetra = Mid(strCerFechaHoraValidaDesde, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaDesde, 4, 2), False) & Mid(strCerFechaHoraValidaDesde, 6)
        
        strCerFechaHoraValidaHasta = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaHasta, 12, 8)
        strCerFechaValidaHasta = Mid(strCerFechaHoraValidaHasta, 1, 10)
        strCerHoraValidaHasta = Mid(strCerFechaHoraValidaHasta, 12)
        strCerFechaHoraValidaHastaLetra = Mid(strCerFechaHoraValidaHasta, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaHasta, 4, 2), False) & Mid(strCerFechaHoraValidaHasta, 6)
        
        'Validaciones simples del archivo .CER
            'Si se utiliza un certificado de pruebas, se omiten las validaciones
             If strCerRFC <> "ACO560518KW7" Then
                If strCerRFC = "" Then 'Si el RFC del certificado está vació, significa que no se ha instalado el complemento de sellado (librerías de FirmaSAT en system32)
                    MsgBox SIHOMsg(1) & "." & vbCrLf & vbCrLf & "No se detectó el complemento de sellado de comprobantes. ", vbCritical, "Mensaje"
                    blnMostrarMsjNotificaError = False
                    vgIntBanderaTImbradoPendiente = 3
                    GoTo NotificaError
                ElseIf strCerRFC <> Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) Then 'Compara el RFC del certificado vs el RFC de la empresa contable
                    MsgBox "El certificado configurado en el sistema no corresponde a la empresa contable emisora: " & vbNewLine & vbNewLine & _
                                                        "- RFC de la empresa:" & vbTab & Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) & vbNewLine & _
                                                        "- RFC del certificado:" & vbTab & strCerRFC, vbCritical + vbOKOnly, "Mensaje"
                    blnMostrarMsjNotificaError = False
                         vgIntBanderaTImbradoPendiente = 3
                    GoTo NotificaError
                ElseIf CDate(strCerFechaValidaDesde) > CDate(strFechaServer) Then 'La fecha de inicio validez del certificado aún no entra en vigor
                    MsgBox "El certificado configurado en el sistema aún no entra en su período de validez: " & vbNewLine & vbNewLine & _
                                                        "- Válido a partir de:" & vbTab & strCerFechaHoraValidaDesdeLetra & vbNewLine & _
                                                        "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
                    blnMostrarMsjNotificaError = False
                              vgIntBanderaTImbradoPendiente = 3
                    GoTo NotificaError
                ElseIf CDate(strCerFechaValidaHasta) < CDate(strFechaServer) Then 'La fecha de expiración del certificado ha excedido su validez
                    MsgBox "El certificado configurado en el sistema excede su período de validez: " & vbNewLine & vbNewLine & _
                                                        "- Válido hasta el:" & vbTab & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                                        "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
                    blnMostrarMsjNotificaError = False
                               vgIntBanderaTImbradoPendiente = 3
                    GoTo NotificaError
                ElseIf CDate(strCerFechaValidaDesde) = CDate(strFechaServer) Then 'La fecha de inicio de validez del certificado es igual a la fecha actual
                    If Format(CDate(strCerHoraValidaDesde), "HH:MM:SS") > Format(CDate(strHoraServer), "HH:MM:SS") Then 'Se compara la hora de inicio de validez con la hora actual
                        MsgBox "El certificado configurado en el sistema aún no entra en su período de validez: " & vbNewLine & vbNewLine & _
                                                            "- Válido a partir de:" & vbTab & strCerFechaHoraValidaDesdeLetra & vbNewLine & _
                                                            "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
                        blnMostrarMsjNotificaError = False
                                  vgIntBanderaTImbradoPendiente = 3
                        GoTo NotificaError
                    End If
                ElseIf CDate(strCerFechaValidaHasta) = CDate(strFechaServer) Then 'La fecha de expiración del certificado es igual a la fecha actual
                    If Format(CDate(strCerHoraValidaHasta), "HH:MM:SS") > Format(CDate(strHoraServer), "HH:MM:SS") Then 'Certificado válido por pocas horas
                        lngTiempoRestanteHrs = DateDiff("h", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
                        lngTiempoRestanteMins = DateDiff("n", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
                        strTiempoRestanteTotal = CStr(lngTiempoRestanteHrs) & " horas " & CStr(Abs(lngTiempoRestanteMins - (60 * lngTiempoRestanteHrs))) & " minutos!"
                        MsgBox "¡El certificado expirará en " & strTiempoRestanteTotal & ", por favor solicite uno nuevo al SAT.", vbExclamation, "Mensaje"
                    Else 'Certificado expirado
                        MsgBox "El certificado configurado en el sistema excede su período de validez: " & vbNewLine & vbNewLine & _
                                                            "- Válido hasta el:" & vbTab & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                                            "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
                        blnMostrarMsjNotificaError = False
                                   vgIntBanderaTImbradoPendiente = 3
                        GoTo NotificaError
                    End If
                End If
            Else
                If fblnAutoVerificacion And blnMensajePruebas Then
                    'Este mensaje es para que los clientes se percaten de que estén utilizando un certificado de pruebas
                    '(Solamente se mostrará, si se tiene habilitado el bit de autoverificación y si el esquema en el que se está probando, no es un esquema SiC (RFC = CSI040928HX4))
                    If Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) <> "CSI040928HX4" Then
                       MsgBox "Se está utilizando un certificado de pruebas: " & vbNewLine & vbNewLine & _
                                        "- RFC del certificado:  " & strCerRFC & vbNewLine & _
                                        "- Válido del  " & strCerFechaHoraValidaDesdeLetra & " al " & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                        "- Número de certificado:  " & strCerNumCertificado & vbNewLine & _
                                        "- Empresa certificadora:  " & strCerEmpresaEmisora, vbInformation + vbOKOnly, "Mensaje"
                    End If
                End If
            End If
    Else
        strError = "No se ha configurado un archivo de certificado .CER para emitir comprobantes fiscales digitales"
                   vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
    
    '|  Descarga archivo .KEY en directorio local del cliente
    If Not IsNull(RsComprobante!BLBLLAVE) Then
        With stmComprobante
            .Type = adTypeBinary
            .Open
            .Write RsComprobante!BLBLLAVE
            .SaveToFile strArchivoLlave, adSaveCreateOverWrite
            .Close
        End With
    Else
        strError = "No existe configurada un archivo llave .KEY para emitir facturas comprobantes fiscales digitales"
                 vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
    
    '|  Almacena contraseña
    If Not IsNull(RsComprobante!vchContrasena) Then
        strContrasena = fstrEncrypt2(fstrConvierteChr(RsComprobante!vchContrasena), RsComprobante!vchRFC)
    Else
        strError = "No existe configurada una contraseña para emitir facturas comprobantes fiscales digitales"
                 vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
        
    'Se valida que los archivos .CER, .KEY y la contraseña sean correctos...
    lngError = SAT_CheckKeyAndCert(strArchivoLlave, strContrasena, strArchivoCertificado, 0)
    If lngError <> 0 Then
        strError = fstrErrorFirmaSAT(lngError)
                   vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
        
    '----------------------------------------------------------------------------------------
    '|  Genera XML firmado y decodifica Certificado, Cadena original y Sello
    '----------------------------------------------------------------------------------------
    
    '|  Genera XML firmado
    intAno = Year(fdtmServerFecha)
    lngError = SAT_SignXml(strArchivoXMLFirmado, strArchivoXMLBase, strArchivoLlave, strContrasena, strArchivoCertificado, IIf(intAno = 2010, SAT_HASH_MD5, SAT_HASH_SHA1))
    If lngError <> 0 Then
        strError = fstrErrorFirmaSAT(lngError)
                   vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
    
    'Valida el sello
    lngError = SAT_VerifySignature(strArchivoXMLFirmado, strArchivoCertificado, 0)
    If lngError <> 0 Then
        strError = fstrErrorFirmaSAT(lngError)
                   vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
    
    '|  Valida que el XML generado este correcto
    lngError = SAT_ValidateXml(strArchivoXMLFirmado, 0)
    If lngError <> 0 Then
        strError = fstrErrorFirmaSAT(lngError)
                   vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
    
    '|  Obtiene cadena original
    strCadenaOriginal = fstrCadenaOriginal(strArchivoXMLFirmado, blnCFDI)
    If Len(strCadenaOriginal) = 0 Then
        blnMostrarMsjNotificaError = False
                  vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
    
    '|  Extrae el string del certificado
    strCertificadoString = satGetCertAsString(strArchivoXMLFirmado)
    If Len(strCertificadoString) = 0 Then
        '|  No se pudo extraer el string del certificado del comprobante generado. ¡Avisar al área de sistemas!
        MsgBox SIHOMsg(1085), vbCritical, "Mensaje"
        blnMostrarMsjNotificaError = False
                   vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If

    '|  Obtiene sello digital
    strSello = satMakeSignatureFromXml(strArchivoXMLBase, strArchivoLlave, strContrasena)
    If Len(strSello) = 0 Then
        '|  No se pudo obtener el sello digital del comprobante generado. ¡Avisar al área de sistemas!
        MsgBox SIHOMsg(1028), vbCritical, "Mensaje"
        blnMostrarMsjNotificaError = False
                  vgIntBanderaTImbradoPendiente = 3
        GoTo NotificaError
    End If
    
    '----------------------------------------------------------------------------------
    '|  Inserta XML firmado, Cadena original y Sello en GNCOMPROBANTEFISCALDIGITAL
    '----------------------------------------------------------------------------------
    strComprobanteFiscalFirmado = fstrConvierteArchivoUTF8(strArchivoXMLFirmado)
        
    '|  Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL con lo datos obtenidos
    strSentencia = "SELECT VCHSERIECOMPROBANTE, VCHFOLIOCOMPROBANTE, VCHRFCEMISOR, CLBCOMPROBANTEFISCAL, VCHNUMEROCERTIFICADO, CLBCADENAORIGINAL, CLBSELLODIGITAL, VCHSELLO, VCHCERTIFICADO" & _
                   "  FROM GNCFDIGITALNOMINA " & _
                   " WHERE GNCFDIGITALNOMINA.INTIDCOMPROBANTE = " & lngComprobante '& _
                   '"   AND GNCFDIGITALNOMINA.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
                   
    Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
    With RsComprobante
        'Se modificó esta linea debido a la actualización del FirmaSAT 4.1.0 (generaba un "?" al inicio de la cadena en CFD, por eso se agregó el MID)
'        !CLBCOMPROBANTEFISCAL = strComprobanteFiscalFirmado
        !CLBCOMPROBANTEFISCAL = Mid(strComprobanteFiscalFirmado, 2, Len(strComprobanteFiscalFirmado) - 1)
        !VCHNUMEROCERTIFICADO = strCerNumCertificado
        !CLBCADENAORIGINAL = strCadenaOriginal
        !CLBSELLODIGITAL = strSello
        !VCHSELLO = strSello
        !VCHCERTIFICADO = strCertificadoString
        .Update
    End With
                        
    ' Se especifica el valor del RefID (Identificador de CFDi, para evitar quemar folios fiscales)
    ' Estructura: (RFC Emisor (3 primeros y 3 últimos) + Tipo + IDComprobante + Serie||Folio) Longitud máxima = 32 caracteres
'    RefID = Trim(Left(Trim(rsComprobante!VCHRFCEMISOR), 3) & Right(Trim(rsComprobante!VCHRFCEMISOR), 3)) & Trim(strTipo) & Trim(IIf(IsNull(rsComprobante!VCHSERIECOMPROBANTE), "", Trim(rsComprobante!VCHSERIECOMPROBANTE) & IIf(IsNull(rsComprobante!VCHFOLIOCOMPROBANTE), "", Trim(rsComprobante!VCHFOLIOCOMPROBANTE))))
    
    'Se hicieron cambios debido a nuevos requerimientos de buzón fiscal
    ' Nueva estructura: Código de buzón fiscal de SiC = "CSI1209" + RFC Emisor (3 primeros y 3 últimos) + Tipo + IDComprobante + Serie||Folio Longitud máxima = 32 caracteres
    RefID = "CSI1209" & Trim(Left(Trim(RsComprobante!VCHRFCEMISOR), 3) & Right(Trim(RsComprobante!VCHRFCEMISOR), 3)) & Trim(strTipo) & lngComprobante & Trim(IIf(IsNull(RsComprobante!VCHSERIECOMPROBANTE), "", Trim(RsComprobante!VCHSERIECOMPROBANTE) & IIf(IsNull(RsComprobante!VCHFOLIOCOMPROBANTE), "", Trim(RsComprobante!VCHFOLIOCOMPROBANTE))))
            
    If blnCFDI Then
        '--------------------------------------------------------------------------------------------------------------------------------------------------------------------
        '|  Inicia el proceso de timbrado de CFDi
        '--------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        'Se carga el XML para solicitar el request de timbrado
        Set XMLSolicitudTimbrado = New MSXML2.DOMDocument
        XMLSolicitudTimbrado.Load (strArchivoXMLFirmado)
    
        'Se ejecuta el proceso de timbrado...
        strError = "Error en el proceso de timbrado"
        TimbrarCFDI XMLSolicitudTimbrado, RefID, strArchivoXMLRequestTimbrado
        
        'Se validan los error en el proceso de timbrado
        If Err.Number <> 0 Then
            GoTo NotificaError
        End If
            
        'Se graba el archivo timbrado FINAL en la carpeta temporal
        XMLSolicitudTimbrado.Save strArchivoXMLFirmadoTimbrado
    
        'Se asigna el valor del UUID a la variable para el mensaje
        UUID = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@UUID").Text
        
        'Validación del mensaje de error en base al PAC configurado:
        If Trim(UUID) = "" Then
            'Se obtiene el PAC con el que se realizó el proceso de timbrado (Buzón Fiscal: INTIDPAC = 1) (PAX: INTIDPAC = 2)
            Set rsPAC = frsEjecuta_SP(CStr(vgintClaveEmpresaContable), "SP_GNSELCONFIGPAC")
               
            If rsPAC.RecordCount > 0 Then
                intPAC = Val(rsPAC!PAC)
                
                Select Case intPAC
                    Case 1 '(Buzón Fiscal: INTIDPAC = 1)
                    If vgIntBanderaTImbradoPendiente = 2 Or vgIntBanderaTImbradoPendiente = 3 Then
                        MsgBox "No se pudo timbrar el CFDi, verifique lo siguiente antes de intentar de nuevo: " & vbNewLine & vbNewLine & _
                                                    "1. Que exista una conexión a Internet." & vbNewLine & _
                                                    "2. La información del CFDi enviado para timbrar sea correcta." & vbNewLine & _
                                                    "3. Las configuraciones de conexión del PAC sean correctas." & vbNewLine & _
                                                    "4. Si el PAC requiere un certificado X.509: " & vbNewLine & _
                                                    "    a) Que el certificado esté instalado en el equipo." & vbNewLine & _
                                                    "    b) Que el certificado esté vigente." & vbNewLine & _
                                                    "    c) Que el certificado esté relacionado con el RFC emisor/donatario.", vbExclamation + vbOKOnly, "Mensaje"
                    End If
                        blnMostrarMsjNotificaError = False
                        GoTo NotificaError
                    Case 2 '(PAX: INTIDPAC = 2)
                    If vgIntBanderaTImbradoPendiente = 2 Or vgIntBanderaTImbradoPendiente = 3 Then
                        MsgBox "No se pudo timbrar el CFDi, verifique lo siguiente antes de intentar de nuevo: " & vbNewLine & vbNewLine & _
                                                    "1. Que exista una conexión a Internet." & vbNewLine & _
                                                    "2. La información del CFDi enviado para timbrar sea correcta." & vbNewLine & _
                                                    "3. Las configuraciones de conexión del PAC sean correctas.", vbExclamation + vbOKOnly, "Mensaje"
                    End If
                        blnMostrarMsjNotificaError = False
                        GoTo NotificaError
                End Select
            Else
                '|¡No se ha configurado un PAC activo para realizar el servicio de timbrado!
                MsgBox SIHOMsg(1155), vbCritical, "Mensaje"
                blnMostrarMsjNotificaError = False
                GoTo NotificaError
            End If
        Else
'            MsgBox "CFDi timbrado exitosamente con el UUID (" & UUID & ")", vbInformation + vbOKOnly, "Mensaje"
        End If

        
        '----------------------------------------------------------------------------------
        '|  Se graba el contenido del XML en strCFDiTimbrado
        '----------------------------------------------------------------------------------
        strError = "Error al codificar a UTF8 el comprobante fiscal digital firmado"
        strCFDiTimbrado = fstrConvierteArchivoUTF8(strArchivoXMLFirmadoTimbrado)
            
        '|  Se obtienen los datos obtenidos con el timbre (incluyendo el UUID)
        strError = "Error al extraer el contenido del complemento de timbrado"
        strNoCertificadoSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@noCertificadoSAT").Text
        strSelloSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@selloSAT").Text
        strFechaTimbrado = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@FechaTimbrado").Text
        
        'Se formatea la fecha de timbrado
        strError = "Error al formatear la fecha de timbrado"
        strFechaTimbrado = Mid(strFechaTimbrado, 9, 2) & "/" & fstrMesLetra(Mid(strFechaTimbrado, 6, 2), False) & "/" & Mid(strFechaTimbrado, 1, 4) & "  " & Mid(strFechaTimbrado, 12, 8)
        
        ' Se obtiene la cadena del complemento TFD
        strCadenaTFD = fstrCadenaOriginalTFD(strArchivoXMLFirmadoTimbrado)
        If Len(strCadenaTFD) = 0 Then
            blnMostrarMsjNotificaError = False
            If vgIntBanderaTImbradoPendiente = 0 Then vgIntBanderaTImbradoPendiente = 1
            GoTo NotificaError
        End If

        '|  Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL con lo datos obtenidos
        strSentencia = "SELECT CLBCFDITIMBRADO, VCHCERTIFICADOSAT, VCHSELLOSAT, VCHFECHATIMBRADO, VCHUUID, VCHCADENATFD" & _
                       "  FROM GNCFDIGITALNOMINA " & _
                       " WHERE GNCFDIGITALNOMINA.INTIDCOMPROBANTE = " & lngComprobante '& _
'                       "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
                       
        Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
        With RsComprobante
    '        !CLBCFDITIMBRADO = Mid(strCFDiTimbrado, 2, Len(strCFDiTimbrado) - 1)
            !CLBCFDITIMBRADO = strCFDiTimbrado 'En los CFDi si se conserva la cadena completa, por eso se eliminó el MID de arriba
            !VCHCERTIFICADOSAT = strNoCertificadoSAT
            !VCHSELLOSAT = strSelloSAT
            !VCHFECHATIMBRADO = strFechaTimbrado
            !VCHUUID = UUID
            !VCHCADENATFD = strCadenaTFD
            .Update
        End With
        
    End If
    '--------------------------------------------------------------------------------------------------------------------------------------------------------------------
    '|
    '--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
    '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$              Inicio de Complemento Addenda             '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    'Si el comprobante maneja una addenda...
    If lngCveAddenda <> 0 Then
    strError = "Error en la generación del complemento addenda"
        'Se ejecuta el SP que regresa el complemento ADDENDA para el CFD
        pCargaArreglo vlaryParametrosSalida, "|" & adBSTR 'adVarChar
        strParametros = CStr(lngCveAddenda) & "|" & CStr(lngComprobante) & "|" & Trim(strTipo)
        frsEjecuta_SP strParametros, "SP_GNADDENDAXML", , , vlaryParametrosSalida
        pObtieneValores vlaryParametrosSalida, strComplementoAddenda

        If blnCFDI = True Then '-----------------------------------------------------------------------------------CFDi
            strCFDaddendado = fstrConvierteArchivoUTF8(strArchivoXMLFirmadoTimbrado)
            
            'Nota: vbCrLf en la linea de abajo sirve como un salto de linea
            strCFDaddendado = Replace(strCFDaddendado, "</cfdi:Complemento>" & vbCrLf & "</cfdi:Comprobante>", "</cfdi:Complemento>" & strComplementoAddenda & "</cfdi:Comprobante>")

            '|  Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL para agregar la addenda
                strSentencia = "SELECT CLBCFDITIMBRADO" & _
                               "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                               " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                               "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"

                Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
                With RsComprobante
                    !CLBCFDITIMBRADO = strCFDaddendado 'En los CFDi si se conserva la cadena completa, por eso se eliminó el MID de abajo
                    '!CLBCFDITIMBRADO = Mid(strCFDaddendado, 2, Len(strCFDaddendado) - 1)
                    .Update
                End With

                '|  Descarga archivo XML ya con la addenda agregada (se sobreescribe el archivo sin la addenda)
                fblnDescargaXML lngComprobante, strTipo, strArchivoXMLFirmadoTimbrado
        Else '---------------------------------------------------------------------------------------------------------CFD
            strCFDaddendado = fstrConvierteArchivoUTF8(strArchivoXMLFirmado)

            strCFDaddendado = Replace(strCFDaddendado, "</Impuestos></Comprobante>", "</Impuestos>" & strComplementoAddenda & "</Comprobante>")

            '|  Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL para agregar la addenda
                strSentencia = "SELECT CLBCOMPROBANTEFISCAL" & _
                               "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                               " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                               "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"

                Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
                With RsComprobante
                    'Se modificó esta linea debido a la actualización a partir del FirmaSAT 4.1.0 (generaba un "?" al inicio de la cadena en CFD, por eso se agregó el MID)
            '        !CLBCOMPROBANTEFISCAL = strCFDaddendado
                    !CLBCOMPROBANTEFISCAL = Mid(strCFDaddendado, 2, Len(strCFDaddendado) - 1)
                    .Update
                End With

                '|  Descarga archivo XML ya con la addenda agregada (se sobreescribe el archivo sin la addenda)
                fblnDescargaXML lngComprobante, strTipo, strArchivoXMLFirmado
        End If
    End If

    '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$              Final de Complemento Addenda             '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

 
    '|  Elimina archivos de trabajo
    If fsoComprobante.FileExists(strArchivoXMLBase) Then fsoComprobante.DeleteFile strArchivoXMLBase
    If fsoComprobante.FileExists(strArchivoXMLFirmado) Then fsoComprobante.DeleteFile strArchivoXMLFirmado
    If fsoComprobante.FileExists(strArchivoLlave) Then fsoComprobante.DeleteFile strArchivoLlave
    If fsoComprobante.FileExists(strArchivoCertificado) Then fsoComprobante.DeleteFile strArchivoCertificado
    If fsoComprobante.FileExists(strArchivoXMLFirmadoTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLFirmadoTimbrado
    If fsoComprobante.FileExists(strArchivoXMLRequestTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLRequestTimbrado

    fblnGeneraCFDnom = True
    strError = ""
    Exit Function
    
NotificaError:

    'Elimina archivos de trabajo
    If fsoComprobante.FileExists(strArchivoXMLBase) Then fsoComprobante.DeleteFile strArchivoXMLBase
    If fsoComprobante.FileExists(strArchivoXMLFirmado) Then fsoComprobante.DeleteFile strArchivoXMLFirmado
    If fsoComprobante.FileExists(strArchivoLlave) Then fsoComprobante.DeleteFile strArchivoLlave
    If fsoComprobante.FileExists(strArchivoCertificado) Then fsoComprobante.DeleteFile strArchivoCertificado
    If fsoComprobante.FileExists(strArchivoXMLFirmadoTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLFirmadoTimbrado
    If fsoComprobante.FileExists(strArchivoXMLRequestTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLRequestTimbrado
    If vgIntBanderaTImbradoPendiente = 2 Or vgIntBanderaTImbradoPendiente = 3 Then
    'Muestra el mensaje de error
    Call pErrorGeneraCFD(1156, strError, blnMostrarMsjNotificaError)
    End If
    'Se regresa el error de la función
    fblnGeneraCFDnom = False
    
End Function


Public Function fstrTiempoRestanteCertificado() As String

'Comprobante
Dim strDestino As String
Dim strSentencia As String
Dim RsComprobante As New ADODB.Recordset
Dim stmComprobante As New ADODB.Stream

'Sistema
Dim strFechaHoraServer As String
Dim strFechaServer As String
Dim strHoraServer As String
Dim strFechaHoraServerLetra As String

'Certificado
Dim strArchivoCertificado As String
Dim strCerRFC As String
Dim strCerFechaHoraValidaDesde As String
Dim strCerFechaHoraValidaDesdeLetra As String
Dim strCerFechaValidaDesde As String
Dim strCerHoraValidaDesde As String
Dim strCerFechaHoraValidaHasta As String
Dim strCerFechaHoraValidaHastaLetra As String
Dim strCerFechaValidaHasta As String
Dim strCerHoraValidaHasta As String
Dim strCerEmpresaEmisora As String
Dim strCerNumCertificado As String

'Tiempo
Dim lngTiempoRestanteDias As String
Dim strTiempoRestanteTotal As String
Dim lngTiempoRestanteHrs As Long
Dim lngTiempoRestanteMins As Long

On Error GoTo NotificaError
        
    fstrTiempoRestanteCertificado = ""
        
    'Se obtienen fecha y hora (formateadas) del servidor para las validaciones de la vigencia del certificado
    strFechaHoraServer = Format(fdtmServerFechaHora, "DD/MM/YYYY HH:MM:SS")
    strFechaServer = Mid(strFechaHoraServer, 1, 10)
    strHoraServer = Mid(strFechaHoraServer, 12)
    strFechaHoraServerLetra = Mid(strFechaHoraServer, 1, 3) & fstrMesLetra(Mid(strFechaHoraServer, 4, 2), False) & Mid(strFechaHoraServer, 6)
    
    
    'Se elimina el contenido de la carpeta temporal
    strDestino = Environ$("temp") & "\fA-Mp09"
    pCreaDirectorio strDestino
    On Error Resume Next
    
    'Checa que el directorio se haya creado, para proceder a eliminar el archivo (evita el error 53)
    If Dir$(strDestino & "\") <> "" Then
        Kill strDestino & "\*.*"
        If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
            Err.Clear
        Else
            Err.Raise Err.Number
        End If
    End If

    '|  Consulta archivo .CER, .KEY y Contraseña almacenado en la base de datos
    strSentencia = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) as RFC, BLBCERTIFICADO " & _
                   "  FROM CNEMPRESACONTABLE " & _
                   " WHERE CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
    Set RsComprobante = frsRegresaRs(strSentencia)
    
    '|  Descarga archivo Certificado en directorio local del cliente
    If Not IsNull(RsComprobante!BLBCERTIFICADO) Then
    
        'Se especifica el archivo de certificado
        strArchivoCertificado = strDestino & "\" & RsComprobante!RFC & ".cer"
    
        With stmComprobante
            .Type = adTypeBinary
            .Open
            .Write RsComprobante!BLBCERTIFICADO
            .SaveToFile strArchivoCertificado, adSaveCreateOverWrite
            .Close
        End With
        
        'Se digiere el contenido del certificado...
        strCerRFC = Trim(satQueryCert(strArchivoCertificado, "rfc"))
        strCerRFC = Trim(Replace(Replace(Replace(strCerRFC, "-", ""), "_", ""), " ", ""))
        strCerNumCertificado = Trim(satQueryCert(strArchivoCertificado, "serialNumber"))
        strCerEmpresaEmisora = Trim(satQueryCert(strArchivoCertificado, "organizationName"))
        strCerFechaHoraValidaDesde = Trim(satQueryCert(strArchivoCertificado, "notBefore"))
        strCerFechaHoraValidaHasta = Trim(satQueryCert(strArchivoCertificado, "notAfter"))
        
        'Formateo y desglose de las fechas y horas del certificado
        strCerFechaHoraValidaDesde = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaDesde, 12, 8)
        strCerFechaValidaDesde = Mid(strCerFechaHoraValidaDesde, 1, 10)
        strCerHoraValidaDesde = Mid(strCerFechaHoraValidaDesde, 12)
        strCerFechaHoraValidaDesdeLetra = Mid(strCerFechaHoraValidaDesde, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaDesde, 4, 2), False) & Mid(strCerFechaHoraValidaDesde, 6)
        
        strCerFechaHoraValidaHasta = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaHasta, 12, 8)
        strCerFechaValidaHasta = Mid(strCerFechaHoraValidaHasta, 1, 10)
        strCerHoraValidaHasta = Mid(strCerFechaHoraValidaHasta, 12)
        strCerFechaHoraValidaHastaLetra = Mid(strCerFechaHoraValidaHasta, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaHasta, 4, 2), False) & Mid(strCerFechaHoraValidaHasta, 6)
        
        'Condiciones
        If Trim(strCerRFC) <> "" Then 'Si el RFC del certificado está vacío, significa que no se instaló el complemento de certificado así que se se salta las validaciones
            'Si se utiliza un certificado de pruebas, se omiten las validaciones
            If strCerRFC <> "ACO560518KW7" Then
                If CDate(strCerFechaValidaDesde) > CDate(strFechaServer) Then
                    'Regresa el valor de la función
                    fstrTiempoRestanteCertificado = "El certificado de sellado de CFD/CFDi aún no entra en vigor."
                ElseIf CDate(strCerFechaValidaHasta) > CDate(strFechaServer) Then
                    lngTiempoRestanteDias = DateDiff("d", Format(CDate(strFechaServer), "DD/MM/YYYY"), Format(CDate(strCerFechaValidaHasta), "DD/MM/YYYY"))
                    strTiempoRestanteTotal = CStr(lngTiempoRestanteDias) & " días."
                    
                    If lngTiempoRestanteDias <= 30 Then
                        'Regresa el valor de la función
                        fstrTiempoRestanteCertificado = "El certificado de sellado de CFD/CFDi expirará en " & strTiempoRestanteTotal
                    End If
                    
                ElseIf CDate(strCerFechaValidaHasta) = CDate(strFechaServer) Then
                
                    If Format(CDate(strCerHoraValidaHasta), "HH:MM:SS") > Format(CDate(strHoraServer), "HH:MM:SS") Then 'Certificado válido por pocas horas
                        lngTiempoRestanteHrs = DateDiff("h", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
                        lngTiempoRestanteMins = DateDiff("n", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
                        strTiempoRestanteTotal = CStr(lngTiempoRestanteHrs) & " horas " & CStr(Abs(lngTiempoRestanteMins - (60 * lngTiempoRestanteHrs))) & " minutos."
            
                        'Regresa el valor de la función
                        fstrTiempoRestanteCertificado = "El certificado de sellado de CFD/CFDi expirará en " & strTiempoRestanteTotal
                        
                    Else
                        'Regresa el valor de la función
                        fstrTiempoRestanteCertificado = "El certificado de sellado de CFD/CFDi ha expirado."
                    End If
                    
                End If
            End If
        End If
    Else
        fstrTiempoRestanteCertificado = "No se ha configurado un certificado de sellado de CFD/CFDi."
        Exit Function
    End If

Exit Function

NotificaError:
    fstrTiempoRestanteCertificado = "El certificado de sellado de CFD/CFDi no es válido."
    
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrTiempoRestanteCertificado"))
End Function


Public Function fstrCadenaOriginalTFD(strArchivoXML As String) As String
    Dim domDocXML As New DOMDocument
    Dim domDocXSLT As New DOMDocument
    Dim XSLTcadenaOriginal As String
    Dim fso As Scripting.FileSystemObject
    Dim rsRuta As New ADODB.Recordset
    Dim strRuta As String
    
    Set fso = New Scripting.FileSystemObject
    
On Error GoTo NotificaError:
    domDocXML.async = False
    domDocXSLT.async = False
    
    'Se configura el archivo se utilizará para la generación de la cadena original
    If vgstrVersionCFDI = "3.2" Then
        XSLTcadenaOriginal = "cadenaoriginalTFD1.xslt"
    Else
        XSLTcadenaOriginal = "cadenaoriginal_TFD_1_1.xslt"
    End If
    
    '|  Archivo XML firmado
    domDocXML.Load strArchivoXML
    
'###########################################################
    If fblnAutoVerificacion Then
        
        'Valida la ruta de los reportes
        Set rsRuta = frsSelParametros("SI", -1, "VCHRUTAREPORTES")
        If Not rsRuta.EOF Then
            If Trim(rsRuta!Valor) = "" Then
                MsgBox "Ocurrió un error al generar la cadena original del timbre." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso", vbCritical, "Mensaje"
                fstrCadenaOriginalTFD = ""
                Exit Function
            ElseIf Not IsNull(Trim(rsRuta!Valor)) Then
                strRuta = IIf(IsNull(rsRuta("Valor")), "", rsRuta("Valor"))
            Else
                MsgBox "Ocurrió un error al generar la cadena original del timbre." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso", vbCritical, "Mensaje"
                fstrCadenaOriginalTFD = ""
                Exit Function
            End If
        End If
    
        'Valida el acceso a la ruta de los reportes
        If Dir$(strRuta & "\") <> "" Then
        'La ruta SI es una ruta válida
            If fso.FileExists(strRuta & "\" & XSLTcadenaOriginal) = False Then
                MsgBox "No se realizó la impresión." & vbCrLf & vbCrLf & "Se esperaba el archivo: " & vbNewLine & strRuta & "\" & XSLTcadenaOriginal, vbCritical, "Mensaje"
                fstrCadenaOriginalTFD = ""
                Exit Function
            Else
                '|  Archivo XSLT proporcionado por el SAT
                domDocXSLT.Load fstrRutaReportes(XSLTcadenaOriginal)
                fstrCadenaOriginalTFD = domDocXML.transformNode(domDocXSLT)
            End If
        Else
        'La ruta NO es válida
            MsgBox "Ocurrió un error al generar la cadena original del timbre." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso", vbCritical, "Mensaje"
            fstrCadenaOriginalTFD = ""
            Exit Function
        End If
        
    Else
    
        If fso.FileExists(App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & XSLTcadenaOriginal) = False Then
            MsgBox SIHOMsg(1026) & vbCrLf & vbCrLf & "Se esperaba el archivo: " & vbNewLine & App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & XSLTcadenaOriginal, vbCritical, "Mensaje"
            fstrCadenaOriginalTFD = ""
            Exit Function
        Else
            '|  Archivo XSLT proporcionado por el SAT
            domDocXSLT.Load App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & XSLTcadenaOriginal
            fstrCadenaOriginalTFD = domDocXML.transformNode(domDocXSLT)
        End If
        
    End If
'###########################################################
    
    
Exit Function
    
NotificaError:
    fstrCadenaOriginalTFD = ""
End Function

Public Function fblnImprimeComprobanteDigitalNom(lngComprobante As Long, _
                                                    strDestino As String, _
                                            Optional strRutaPDF As String = "", _
                                         Optional blnAbrePDF As Boolean = True) As Boolean
    Dim dblTotal As Double
    Dim dblTotalVales As Double
    Dim strMoneda As String
    Dim strParametros As String
    Dim strSentencia As String
    Dim RsComprobante As New ADODB.Recordset
    Dim alstrParametros(2) As String
    Dim vgrptReporte As CRAXDRT.Report
    Dim strNombreReporte As String
    Dim rsRuta As New ADODB.Recordset
    Dim blnCFDI As Boolean
    Dim strRuta As String
    Dim strRutaCBB As String
    Dim strRutaCBB1 As String
    Dim vlBandera As Integer
    Dim fso As Scripting.FileSystemObject
    Dim rptArriba As CRAXDRT.Report
    Dim rptAbajo As CRAXDRT.Report
    Dim blnExisteUUID As Boolean
    Dim blnUsarPDFCreator As Boolean
    
On Error GoTo NotificaError:
    
    fblnImprimeComprobanteDigitalNom = False
    vlBandera = 0
    strRuta = ""
    strRutaCBB = ""
    strRutaCBB1 = ""
    Set fso = New Scripting.FileSystemObject
    
    '|  Si es -1 significa que es un donativo
    
    '|  Selecciona los datos del comprobante fiscal digital
    strParametros = lngComprobante
    Set RsComprobante = frsEjecuta_SP(strParametros, "SP_GNSELCFDNOM")
    If Not RsComprobante.EOF Then
        '-----------------------------------------------------------------------
        '|  Instancia el reporte dependiendo del tipo de documento
        '-----------------------------------------------------------------------
        If strDestino = "PDF" Then
            pInstanciaReporte vgrptReporte, IIf(IsNull(RsComprobante!VCHUUID), "rptCFDiNomnoUUID.rpt", "rptCFDiNom.rpt")
            vgrptReporte.DiscardSavedData
        Else
            pInstanciaReporte vgrptReporte, IIf(IsNull(RsComprobante!VCHUUID), "rptCFDinomImpnoUUID.rpt", "rptCFDiNomImp.rpt")
            Set rptArriba = vgrptReporte.OpenSubreport(IIf(IsNull(RsComprobante!VCHUUID), "rptCFDiNomnoUUID.rpt", "rptCFDiNom.rpt"))
            Set rptAbajo = vgrptReporte.OpenSubreport(IIf(IsNull(RsComprobante!VCHUUID), "rptCFDiNom1noUUID.rpt", "rptCFDiNom1.rpt"))
            rptArriba.DiscardSavedData
            rptAbajo.DiscardSavedData
            rptArriba.Database.SetDataSource RsComprobante
            rptAbajo.Database.SetDataSource RsComprobante
        End If
                
        dblTotal = IIf(IsNull(RsComprobante!numTotalComprobante), 0, RsComprobante!numTotalComprobante)
        dblTotalVales = IIf(IsNull(RsComprobante!ValesDespensa), 0, RsComprobante!ValesDespensa)
        If strDestino = "PDF" Then
            alstrParametros(0) = "pCantidadLetras;" & fstrNumeroenLetras(dblTotal - dblTotalVales, "PESOS", "")
        Else
            alstrParametros(0) = "cantidad;" & fstrNumeroenLetras(dblTotal - dblTotalVales, "PESOS", "")
        End If
        alstrParametros(2) = "intIdcomprobante;" & RsComprobante!INTIDCOMPROBANTE
        pCargaParameterFields alstrParametros, vgrptReporte
        
        '-----------------------------------------------------------------------------------------------------
        '|  Busca un elemento para incrustar el código bidireccional en caso de que el comprobante sea CFDi
        '-----------------------------------------------------------------------------------------------------
        '|  Identifica si el comprobante es CFDi
        blnCFDI = IsNull(RsComprobante!IntAnoAprobacion) And IsNull(RsComprobante!INTNUMEROAPROBACION)
        
        If blnCFDI And Not IsNull(RsComprobante!VCHUUID) Then
            If (fintSeccionCBB(vgrptReporte) <> -1) Or (strDestino <> "PDF") Then
            '----------------------------------------------------------------------------
            '|  Genera el CBB si es CFDi
            '----------------------------------------------------------------------------
            
                '|  Obtiene la ruta de los reportes
                If fblnAutoVerificacion Then
                
                    'Valida la ruta de los reportes
            '       strRuta = fstrRutaReportes(strTipo & lngComprobante & ".jpg")
                    Set rsRuta = frsSelParametros("SI", -1, "VCHRUTAREPORTES")
                    If Not rsRuta.EOF Then
                        If Trim(rsRuta!Valor) = "" Then
                            MsgBox "Ocurrió un error al generar el código bidimensional." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                            fblnImprimeComprobanteDigitalNom = False
                            Exit Function
                        ElseIf Not IsNull(Trim(rsRuta!Valor)) Then
                            strRuta = IIf(IsNull(rsRuta("Valor")), "", rsRuta("Valor"))
                            strRutaCBB = IIf(IsNull(rsRuta("Valor")), "", rsRuta("Valor")) & "\" & "NO" & lngComprobante & ".jpg"
                            If strDestino <> "PDF" Then strRutaCBB1 = IIf(IsNull(rsRuta("Valor")), "", rsRuta("Valor")) & "\" & "NO1" & lngComprobante & ".jpg"
                        Else
                            MsgBox "Ocurrió un error al generar el código bidimensional." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                            fblnImprimeComprobanteDigitalNom = False
                            Exit Function
                        End If
                    End If

                    'Valida el acceso a la ruta de los reportes
                    If Dir$(strRuta & "\") <> "" Then
                    'La ruta SI es una ruta válida
'                        pGeneraCBB lngComprobante, "NO", strRutaCBB
                        pGeneraCBBNOM lngComprobante, "NO", strRutaCBB
                        If strDestino <> "PDF" Then pGeneraCBBNOM lngComprobante, "NO", strRutaCBB1
                    Else
                    'La ruta NO es válida
                        MsgBox "Ocurrió un error al generar el código bidimensional." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                        fblnImprimeComprobanteDigitalNom = False
                        Exit Function
                    End If

                Else
                
                    'Valida el acceso a la ruta de los reportes
                    If Dir$(App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\") <> "" Then
                    'La ruta SI es una ruta válida
                        strRuta = App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\"
                        strRutaCBB = App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & "NO" & lngComprobante & ".jpg"
                        pGeneraCBBNOM lngComprobante, "NO", strRutaCBB
                        If strDestino <> "PDF" Then
                           strRutaCBB1 = App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & "NO1" & lngComprobante & ".jpg"
                           pGeneraCBBNOM lngComprobante, "NO", strRutaCBB1
                        End If
                    Else
                    'La ruta NO es válida
                        MsgBox "Ocurrió un error al generar el código bidimensional." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                        fblnImprimeComprobanteDigitalNom = False
                        Exit Function
                    End If
                    
                End If
                
            Else
                MsgBox "No se pudo " & IIf(strDestino = "PDF", "generar el comprobante ", "realizar la impresión ") & "por falta de código bidireccional. " & vbNewLine & vbNewLine & "Revise que el formato que está configurado es para un comprobante del tipo CFDi.", vbCritical, "Mensaje"
                fblnImprimeComprobanteDigitalNom = False
                Exit Function
            End If
        End If
        '|  Se va a generar un archivo PDF
        If strDestino = "PDF" Then
            If strRutaPDF <> "" Then
               vgrptReporte.Database.SetDataSource RsComprobante
               If strRutaCBB <> "" And blnCFDI Then
                  frmReporte.strRutaCBB = strRutaCBB
                  frmReporte.pImprimeCBB vgrptReporte ' Manda llamar a la función que agrega el CBB al reporte
               End If
               '-----------------------------------------------------------------------
               '|  Exporta la factura a formato PDF
               '----------------------------------------------------------------------
                
               'Variable de bandera, que indica si se pasó la validación de la exportación a formato PDF
               vlBandera = 1
               
               blnUsarPDFCreator = fblnUsarPDFCreator()
               If Not blnUsarPDFCreator Then
                    With vgrptReporte
                        .ExportOptions.DiskFileName = strRutaPDF
                        .ExportOptions.DestinationType = crEDTDiskFile
                        .ExportOptions.FormatType = crEFTPortableDocFormat
                        .ExportOptions.PDFExportAllPages = True
                        'Variable de bandera, que indica si la ruta de descarga es válida
                        vlBandera = 2
                        .Export False
                    End With
                Else
                    pGeneraPDF vgrptReporte, strRutaPDF
                End If
                If blnAbrePDF Then shellexecute 0&, "open", strRutaPDF, "", "", vbNormalFocus
            End If
        Else
            fblnAsignaImpresoraReporte vgintNumeroDepartamento, "NO", vgrptReporte
            'vgrptReporte.SelectPrinter Printer.DriverName, Printer.DeviceName, Printer.port
            'vgrptReporte.PaperOrientation = crDefaultPaperOrientation
            
            If Not IsNull(RsComprobante!VCHUUID) Then
                    frmReporte.strRutaCBB = strRutaCBB
                    frmReporte.strRutaCBB1 = strRutaCBB1 '|  Carga la ruta donde se encuentra el archivo CBB
                    frmReporte.pImprimeCBB rptArriba '|  Manda llamar a la función que agrega el CBB al reporte
                    frmReporte.pImprimeCBB1 rptAbajo
            End If
            vgrptReporte.PrintOutEx False, 1
            'pImprimeReporte vgrptReporte, rsComprobante, strDestino, "Nomina", , 2, strRutaCBB
        End If
        
        '|  Elimina el CBB si es CFDi
        If blnCFDI And Not IsNull(RsComprobante!VCHUUID) Then
            If Trim(strRutaCBB) <> "" Then pEliminaCBB lngComprobante, "NO", strRutaCBB
            If strDestino <> "PDF" And Trim(strRutaCBB1) <> "" Then pEliminaCBB lngComprobante, "NO", strRutaCBB1
        End If
    
    Else
        '|  ¡No existe información!
        MsgBox "No existe la información para generar el comprobante fiscal digital.", vbInformation, "Mensaje"
        Exit Function
    End If
    
    fblnImprimeComprobanteDigitalNom = True
    vlBandera = 0
    Exit Function
    
NotificaError:
    If fso.FileExists(strRutaCBB) Then fso.DeleteFile strRutaCBB
    
    fblnImprimeComprobanteDigitalNom = False
    vlBandera = 0
End Function


  Private Function fstrObtieneNombreReporte(lngFormato As Long, intTipoGrupo As Integer, strTipo As String, Optional strVersionCFDI As String = "3.2") As String
    Dim strParametros As String
    Dim rsReporte As ADODB.Recordset
    
    strParametros = strTipo & "|" & lngFormato & "|" & intTipoGrupo
    Set rsReporte = frsEjecuta_SP(strParametros, "SP_GNSELREPORTECOFIGURADO")
    If Not rsReporte.EOF Then
        If strVersionCFDI = "3.2" Then
            fstrObtieneNombreReporte = IIf(IsNull(rsReporte!NombreReporte), "", rsReporte!NombreReporte)
        Else
            fstrObtieneNombreReporte = IIf(IsNull(rsReporte!NombreReporteFormatoUnico), "", rsReporte!NombreReporteFormatoUnico)
        End If
    Else
        fstrObtieneNombreReporte = ""
    End If
End Function

Public Function fblnImprimeComprobanteDigital(lngComprobante As Long, _
                                                     strTipo As String, _
                                                  strDestino As String, _
                                                  lngFormato As Long, _
                                            intTipoImpresion As Integer, _
                                            Optional strRutaPDF As String = "", _
                                         Optional blnAbrePDF As Boolean = True, _
                                         Optional chrTipoCliente As String = "", _
                                         Optional intReferenciaCliente As Long = -1, _
                                         Optional intNumeroCopias As Integer = -1) As Boolean
    Dim dblTotal As Double
    Dim strMoneda As String
    Dim strParametros As String
    Dim strParametrosRE As String
    Dim strParametrosSubRE As String
    Dim strSentencia As String
    Dim RsComprobante As New ADODB.Recordset
    Dim rsTasasIEPS As New ADODB.Recordset
    Dim StrTasasIEPS As String
    Dim StrCanIEPS As String
    Dim alstrParametros() As String
    Dim lngConceptosAseguradora As Long
    Dim rsSubReporte As New ADODB.Recordset
    Dim vgrptReporte As CRAXDRT.Report
    Dim vgrptSubReporte As CRAXDRT.Report
    Dim strNombreReporte As String
    Dim strNombreSubReporte As String
    Dim rsRuta As New ADODB.Recordset
    Dim blnCFDI As Boolean
    Dim strRuta As String
    Dim strRutaCBB As String
    Dim vlBandera As Integer
    Dim fso As Scripting.FileSystemObject
    Dim ObjRS As New ADODB.Recordset
    Dim blnExisteUUID As Boolean ' si no hay UUID quiere decir que el CFDi esta pendiente de timbre, se debe imprimir con leyenda (NO ES UN COMPROBANTE FISCAL VáLIDO)
    Dim intCopiasImpresion As Integer
    Dim rsFacturasNotas As New ADODB.Recordset
    Dim strFacturas As String
    Dim strCuentas As String
    Dim strTipos As String
    Dim strPacientes As String
    Dim strUUIDs As String
    Dim blnUsarPDFCreator As Boolean
    Dim strVersionCFDI As String
    Dim strSql As String
    Dim vlintUUIDs As Integer
    Dim vlblnUUIDsFinal As Boolean
    
On Error GoTo NotificaError:
    ReDim alstrParametros(8)
    vlintUUIDs = 1
    vlblnUUIDsFinal = False
    fblnImprimeComprobanteDigital = False
    vlBandera = 0
    strRuta = ""
    strRutaCBB = ""
    blnExisteUUID = True 'Mientras que esta varible este activa, la impresión debe hacerce de la manera normal
    
    Set fso = New Scripting.FileSystemObject
    
    'Revisamos si el Documento tiene UUID
    strSentencia = "SELECT VCHUUID, VCHVERSIONCFDI FROM GNCOMPROBANTEFISCALDIGITAL " & _
                   " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                   " AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'" & _
                   " AND ((INTANOAPROBACION IS NULL AND INTNUMEROAPROBACION IS NULL) OR CAST(NVL(VCHVERSIONCFDI,0) AS INTEGER) < 3.3)"
                                                  
    Set ObjRS = frsRegresaRs(strSentencia, adLockOptimistic)
    
    If ObjRS.RecordCount > 0 Then
       blnExisteUUID = IIf(IsNull(ObjRS!VCHUUID), False, True)
       strVersionCFDI = IIf(IsNull(ObjRS!vchVersionCFDI), "3.2", ObjRS!vchVersionCFDI)
    End If
    ObjRS.Close
       
    If Not blnExisteUUID Then
       If Trim(strTipo) = "FA" Or Trim(strTipo) = "AN" Or Trim(strTipo) = "AA" Then
          'debemos ver si el formato es para factura directa o facturacion "normal"
          strSentencia = "select INTNUMEROTIPOFORMATO from formato where INTNUMEROFORMATO =" & lngFormato
          Set ObjRS = frsRegresaRs(strSentencia, adLockOptimistic)
            
          If ObjRS.RecordCount = 0 Then 'en teoria nunca debe de entrar aqui
             strNombreReporte = "rptFacturaElectronicaCFDi_AFCnoUUID.rpt"
          Else
              If ObjRS!intNumeroTipoFormato = 9 Then 'factura directa
                 If strVersionCFDI = "3.2" Then
                    strNombreReporte = "rptCFD_Factura_DirectaCFDinoUUID.rpt"
                 Else
                    strNombreReporte = "rptFacturaElectronicaCFDi_FUnoUUID.rpt"
                 End If
              Else 'factura normal
                If strVersionCFDI = "3.2" Then
                  Select Case intTipoImpresion
                         Case 1
                         strNombreReporte = "rptFacturaElectronicaCFDi_ACFnoUUID.rpt"
                         Case 2
                         strNombreReporte = "rptFacturaElectronicaCFDi_ACAnoUUID.rpt"
                         Case 3
                         strNombreReporte = "rptFacturaElectronicaCFDi_DCAnoUUID.rpt"
                  End Select
                Else
                    strNombreReporte = "rptFacturaElectronicaCFDi_FUnoUUID.rpt"
                End If
              End If
          End If
       ElseIf Trim(strTipo) = "CR" Or Trim(strTipo) = "CA" Then 'nota de credito/cargo
          strNombreReporte = "rptCFDNotaCreditoCargoCFDinoUUID.rpt"
       ElseIf Trim(strTipo) = "DO" Then 'Donativos que se supone que nadie utliza
          strNombreReporte = "rptDonativosCFDinoUUID.rpt"
       ElseIf Trim(strTipo) = "RE" Then 'Comprobantes de pagos
          strNombreReporte = "rptCFDIPagos.rpt"
          strNombreSubReporte = "rptCFDIPagosFormasPagos.rpt"
       End If
    Else
        If Trim(strTipo) = "RE" And lngFormato = -20 Then '--- Comprobante de pagos
            strNombreReporte = "rptCFDIPagos.rpt"
            strNombreSubReporte = "rptCFDIPagosFormasPagos.rpt"
        Else
            '|  Si es -1 significa que es un donativo
            If Trim(strTipo) = "DO" And lngFormato = -1 Then '--- Donativo CFD
                strNombreReporte = "rptDonativos.rpt"
            ElseIf Trim(strTipo) = "DO" And lngFormato = -10 Then '---Donativo CFDi
                strNombreReporte = "rptDonativosCFDi.rpt"
            Else
                '|  Verifica que exista un reporte configurado para imprimir el comprobante
                strNombreReporte = fstrObtieneNombreReporte(lngFormato, intTipoImpresion, strTipo, strVersionCFDI)
                If Trim(strNombreReporte) = "" Then
                    '|  No existen registrados formatos de impresión.
                    MsgBox SIHOMsg(1) & "." & vbCrLf & vbCrLf & "No se realizó la impresión." & vbCrLf & vbCrLf & "- No existen registrados formatos de impresión.", vbCritical, "Mensaje"
                    fblnImprimeComprobanteDigital = False
                    Exit Function
                End If
            End If
        End If
    End If
    
    '|  Selecciona los datos del comprobante fiscal digital
    If Trim(strTipo) = "RE" And lngFormato = -20 Then '--- Comprobante de pagos
        strParametrosRE = lngComprobante & "|" & strTipo & "|" & chrTipoCliente & "|" & intReferenciaCliente
        strParametrosSubRE = lngComprobante
    Else
        strParametrosRE = lngComprobante & "|" & strTipo & "|" & chrTipoCliente & "|-1"
    End If
        
    strParametros = lngComprobante & "|" & strTipo
    Set RsComprobante = frsEjecuta_SP(strParametrosRE, "SP_GNSELCOMPROBANTEFISDIGITAL")
    If Not RsComprobante.EOF Then
        '-----------------------------------------------------------------------
        '|  Instancia el reporte dependiendo del tipo de documento
        '-----------------------------------------------------------------------
        pInstanciaReporte vgrptReporte, strNombreReporte
        vgrptReporte.DiscardSavedData
        
        If Trim(strTipo) = "RE" Then
            Set vgrptSubReporte = vgrptReporte.OpenSubreport("rptCFDIPagosFormasPagos.rpt")
            vgrptSubReporte.DiscardSavedData

            Set rsSubReporte = frsEjecuta_SP(str(lngComprobante), "SP_GNSELCOMPROBFISDIGFORMAPAGO")
            If rsSubReporte.RecordCount <> 0 Then
                vgrptSubReporte.Database.SetDataSource rsSubReporte
'                vgrptReporte.PrintOutEx False, 1
            End If
        End If
        
        '----------------------------------------------------------------------
        'TASAS DE IEPS
        '----------------------------------------------------------------------
        Set rsTasasIEPS = frsEjecuta_SP(strParametros, "SP_PVTasasIEPS")
        StrTasasIEPS = ""
        StrCanIEPS = ""
        If Not rsTasasIEPS.EOF Then
           rsTasasIEPS.MoveFirst
           Do While Not rsTasasIEPS.EOF
                StrTasasIEPS = StrTasasIEPS & rsTasasIEPS!LEYENDA
                StrCanIEPS = StrCanIEPS & Format(rsTasasIEPS!IEPS, "$###,###,###,##0.00")
                rsTasasIEPS.MoveNext
                If Not rsTasasIEPS.EOF Then
                   StrTasasIEPS = StrTasasIEPS & vbNewLine
                   StrCanIEPS = StrCanIEPS & vbNewLine
                End If
           Loop
        End If
                    
        '--------------------------------------------------------------------
        'SE MUESTRAN O NO CONCEPTOS DE ASEGURADORA (SOLO FACTURAS)
        '--------------------------------------------------------------------
        lngConceptosAseguradora = 1
        If Trim(strTipo) = "FA" Then
           frsEjecuta_SP CStr(lngComprobante) & "|0|A", "Fn_PvSelBitDesglose", True, lngConceptosAseguradora
        End If
                            
        '---------------------------------------------------------------------------
        'SI ES UNA NOTA DE CRÉDITO\CARGO SE BUSCAN LAS FACTURAS A LAS QUE SE APLICAN
        '---------------------------------------------------------------------------
        strFacturas = ""
        strCuentas = ""
        strTipos = ""
        strPacientes = ""
        strUUIDs = ""
        If Trim(strTipo) = "CR" Or Trim(strTipo) = "CA" Then
           vlintUUIDs = 1
           vlblnUUIDsFinal = False
           Set rsFacturasNotas = frsEjecuta_SP(CStr(lngComprobante), "sp_SelRelNotaFactura")
           If rsFacturasNotas.RecordCount > 0 Then
              rsFacturasNotas.MoveFirst
              Do While Not rsFacturasNotas.EOF
                 If strFacturas = "" Then
                        strFacturas = IIf(IsNull(rsFacturasNotas!chrfoliofactura), "", rsFacturasNotas!chrfoliofactura)
                        strCuentas = IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                        strTipos = IIf(IsNull(rsFacturasNotas!TipoPaciente), "", rsFacturasNotas!TipoPaciente)
                        strPacientes = IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                        strUUIDs = IIf(IsNull(rsFacturasNotas!UUID), "", rsFacturasNotas!UUID)
                        vlintUUIDs = vlintUUIDs + 1
                 Else
                    If vlintUUIDs <= 47 Then
                        strFacturas = strFacturas & vbNewLine & IIf(IsNull(rsFacturasNotas!chrfoliofactura), "", rsFacturasNotas!chrfoliofactura)
                        strCuentas = strCuentas & vbNewLine & IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                        strTipos = strTipos & vbNewLine & IIf(IsNull(rsFacturasNotas!TipoPaciente), "", rsFacturasNotas!TipoPaciente)
                        strPacientes = strPacientes & vbNewLine & IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                        strUUIDs = strUUIDs & vbNewLine & IIf(IsNull(rsFacturasNotas!UUID), "", rsFacturasNotas!UUID)
                        vlintUUIDs = vlintUUIDs + 1
                    ElseIf vlintUUIDs = 48 And vlblnUUIDsFinal = False Then
                        strFacturas = strFacturas & vbNewLine & "..."
                        strCuentas = strCuentas & vbNewLine
                        strTipos = strTipos & vbNewLine
                        strPacientes = strPacientes & vbNewLine
                        strUUIDs = strUUIDs & vbNewLine
                        vlblnUUIDsFinal = True
                    End If
                 End If
                 rsFacturasNotas.MoveNext
              Loop
           End If
        End If
                             
        dblTotal = IIf(IsNull(RsComprobante!numTotalComprobante), 0, RsComprobante!numTotalComprobante)
        strMoneda = UCase(RsComprobante!VCHMONEDAADDENDA)
        alstrParametros(0) = "pCantidadLetras;" & fstrNumeroenLetras(dblTotal, strMoneda, IIf(IsNull(RsComprobante!VCHAGREGADOMONEDAADDENDA), "", RsComprobante!VCHAGREGADOMONEDAADDENDA))
        alstrParametros(1) = "pCadenaOriginal;" & RsComprobante!CLBCADENAORIGINAL
        alstrParametros(2) = "TasasIEPS;" & StrTasasIEPS
        alstrParametros(3) = "CanIEPS;" & StrCanIEPS
        alstrParametros(4) = "DesgloseConceptosAseguradora;" & IIf(lngConceptosAseguradora = 3, 1, 0)
        
        If (Trim(strTipo) = "CR" Or Trim(strTipo) = "CA") Then
           alstrParametros(5) = "Facturas;" & strFacturas
           alstrParametros(6) = "Cuentas;" & strCuentas
           alstrParametros(7) = "Tipos;" & strTipos
           alstrParametros(8) = "Nombres;" & strPacientes
           If strVersionCFDI <> "3.2" Then
            ReDim Preserve alstrParametros(9)
            alstrParametros(9) = "UUIDs;" & strUUIDs
           End If
        End If
        
        If Trim(strTipo) = "FA" And strVersionCFDI <> "3.2" Then
           ReDim Preserve alstrParametros(9)
           strFacturas = ""
           strCuentas = ""
           strTipos = ""
           strPacientes = ""
           strUUIDs = ""
           
           vlintUUIDs = 1
           vlblnUUIDsFinal = False
                      
           Set rsFacturasNotas = frsEjecuta_SP(CStr(lngComprobante), "sp_SelRelFacturaFactura")
           If rsFacturasNotas.RecordCount > 0 Then
              rsFacturasNotas.MoveFirst
              Do While Not rsFacturasNotas.EOF
                 If strFacturas = "" Then
                    strFacturas = IIf(IsNull(rsFacturasNotas!chrfoliofactura), "", rsFacturasNotas!chrfoliofactura)
                    strCuentas = IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                    strTipos = IIf(IsNull(rsFacturasNotas!TipoPaciente), "", rsFacturasNotas!TipoPaciente)
                    strPacientes = IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                    strUUIDs = IIf(IsNull(rsFacturasNotas!UUID), "", rsFacturasNotas!UUID)
                    vlintUUIDs = vlintUUIDs + 1
                 Else
                    If vlintUUIDs <= 47 Then
                        strFacturas = strFacturas & vbNewLine & IIf(IsNull(rsFacturasNotas!chrfoliofactura), "", rsFacturasNotas!chrfoliofactura)
                        strCuentas = strCuentas & vbNewLine & IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                        strTipos = strTipos & vbNewLine & IIf(IsNull(rsFacturasNotas!TipoPaciente), "", rsFacturasNotas!TipoPaciente)
                        strPacientes = strPacientes & vbNewLine & IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                        strUUIDs = strUUIDs & vbNewLine & IIf(IsNull(rsFacturasNotas!UUID), "", rsFacturasNotas!UUID)
                        vlintUUIDs = vlintUUIDs + 1
                    ElseIf vlintUUIDs = 48 And vlblnUUIDsFinal = False Then
                        strFacturas = strFacturas & vbNewLine & "..."
                        strCuentas = strCuentas & vbNewLine
                        strTipos = strTipos & vbNewLine
                        strPacientes = strPacientes
                        strUUIDs = strUUIDs & vbNewLine
                        vlblnUUIDsFinal = True
                    End If
                 End If
                 rsFacturasNotas.MoveNext
              Loop
           End If
           rsFacturasNotas.Close
           
           If strFacturas = "" Then
           
                vlintUUIDs = 1
                vlblnUUIDsFinal = False
                Set rsFacturasNotas = frsEjecuta_SP(CStr(lngComprobante), "sp_selRelFacturaAnticipo")
                If rsFacturasNotas.RecordCount > 0 Then
                   rsFacturasNotas.MoveFirst
                   Do While Not rsFacturasNotas.EOF
                      If strFacturas = "" Then
                         strFacturas = IIf(IsNull(rsFacturasNotas!chrfoliofactura), "", rsFacturasNotas!chrfoliofactura)
                         strCuentas = IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                         strTipos = IIf(IsNull(rsFacturasNotas!TipoPaciente), "", rsFacturasNotas!TipoPaciente)
                         strPacientes = IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                         strUUIDs = IIf(IsNull(rsFacturasNotas!UUID), "", rsFacturasNotas!UUID)
                         vlintUUIDs = vlintUUIDs + 1
                      Else
                        If vlintUUIDs <= 47 Then
                          strFacturas = strFacturas & vbNewLine & IIf(IsNull(rsFacturasNotas!chrfoliofactura), "", rsFacturasNotas!chrfoliofactura)
                          strCuentas = strCuentas & vbNewLine & IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                          strTipos = strTipos & vbNewLine & IIf(IsNull(rsFacturasNotas!TipoPaciente), "", rsFacturasNotas!TipoPaciente)
                          strPacientes = strPacientes & vbNewLine & IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                          strUUIDs = strUUIDs & vbNewLine & IIf(IsNull(rsFacturasNotas!UUID), "", rsFacturasNotas!UUID)
                          vlintUUIDs = vlintUUIDs + 1
                        ElseIf vlintUUIDs = 48 And vlblnUUIDsFinal = False Then
                          strFacturas = strFacturas & vbNewLine & "..."
                          strCuentas = strCuentas & vbNewLine
                          strTipos = strTipos & vbNewLine
                          strPacientes = strPacientes & vbNewLine
                          strUUIDs = strUUIDs & vbNewLine
                          vlblnUUIDsFinal = True
                        End If
                      End If
                      rsFacturasNotas.MoveNext
                   Loop
                End If
                rsFacturasNotas.Close
           End If
           
           alstrParametros(5) = "Facturas;" & strFacturas
           alstrParametros(6) = "Cuentas;" & strCuentas
           alstrParametros(7) = "Tipos;" & strTipos
           alstrParametros(8) = "Nombres;" & strPacientes
           alstrParametros(9) = "UUIDs;" & strUUIDs
        End If
        
        If Trim(strTipo) = "AN" And strVersionCFDI <> "3.2" Then
           ReDim Preserve alstrParametros(9)
           strFacturas = ""
           strCuentas = ""
           strTipos = ""
           strPacientes = ""
           strUUIDs = ""
                      
                 
           If strFacturas = "" Then
           
                vlintUUIDs = 1
                vlblnUUIDsFinal = False
                
                Set rsFacturasNotas = frsEjecuta_SP(CStr(lngComprobante), "SP_PVSELRELANTICIPO")
                If rsFacturasNotas.RecordCount > 0 Then
                   rsFacturasNotas.MoveFirst
                   Do While Not rsFacturasNotas.EOF
                      If strFacturas = "" Then
                         strFacturas = IIf(IsNull(rsFacturasNotas!CHRFOLIORECIBO), "", rsFacturasNotas!CHRFOLIORECIBO)
                         strCuentas = IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                         strTipos = IIf(IsNull(rsFacturasNotas!CHRTIPOPACIENTE), "", rsFacturasNotas!CHRTIPOPACIENTE)
                         strPacientes = IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                         strUUIDs = IIf(IsNull(rsFacturasNotas!VCHUUID), "", rsFacturasNotas!VCHUUID)
                         vlintUUIDs = vlintUUIDs + 1
                      Else
                        If vlintUUIDs <= 47 Then
                          strFacturas = strFacturas & vbNewLine & IIf(IsNull(rsFacturasNotas!CHRFOLIORECIBO), "", rsFacturasNotas!CHRFOLIORECIBO)
                          strCuentas = strCuentas & vbNewLine & IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                          strTipos = strTipos & vbNewLine & IIf(IsNull(rsFacturasNotas!CHRTIPOPACIENTE), "", rsFacturasNotas!CHRTIPOPACIENTE)
                          strPacientes = strPacientes & vbNewLine & IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                          strUUIDs = strUUIDs & vbNewLine & IIf(IsNull(rsFacturasNotas!VCHUUID), "", rsFacturasNotas!VCHUUID)
                          vlintUUIDs = vlintUUIDs + 1
                        ElseIf vlintUUIDs = 48 And vlblnUUIDsFinal = False Then
                          strFacturas = strFacturas & vbNewLine & "..."
                          strCuentas = strCuentas & vbNewLine
                          strTipos = strTipos & vbNewLine
                          strPacientes = strPacientes & vbNewLine
                          strUUIDs = strUUIDs & vbNewLine
                          vlblnUUIDsFinal = True
                        End If
                      End If
                      rsFacturasNotas.MoveNext
                   Loop
                End If
                rsFacturasNotas.Close
           End If
           
           alstrParametros(5) = "Facturas;" & strFacturas
           alstrParametros(6) = "Cuentas;" & strCuentas
           alstrParametros(7) = "Tipos;" & strTipos
           alstrParametros(8) = "Nombres;" & strPacientes
           alstrParametros(9) = "UUIDs;" & strUUIDs
        End If
        
        If Trim(strTipo) = "AA" Then
            ReDim Preserve alstrParametros(9)
            alstrParametros(5) = "Facturas;"
            alstrParametros(6) = "Cuentas;"
            alstrParametros(7) = "Tipos;"
            alstrParametros(8) = "Nombres;"
            alstrParametros(9) = "UUIDs;"
            
            vlintUUIDs = 1
            vlblnUUIDsFinal = False
            
            strSql = "select PVFactura.chrFolioFactura, PVFactura.intMovPaciente, PVFactura.chrTipoPaciente TipoPaciente, trim(PVFactura.chrNombre) Nombre, CF.vchUUID UUID" & _
            " from PVAplicacionAnticipo" & _
            " inner join PVFactura on trim(PVFactura.chrFolioFactura) = PVAplicacionAnticipo.chrFolioFactura" & _
            " inner join GNComprobanteFiscalDigital CF on CF.intComprobante = PVFactura.intConsecutivo and CF.chrTipoComprobante = 'FA'" & _
            " where PVAplicacionAnticipo.INTCOMPROBANTE = " & lngComprobante
            Set rsFacturasNotas = frsRegresaRs(strSql, adLockReadOnly, adOpenForwardOnly)
            Do While Not rsFacturasNotas.EOF
                If strFacturas = "" Then
                   strFacturas = IIf(IsNull(rsFacturasNotas!chrfoliofactura), "", rsFacturasNotas!chrfoliofactura)
                   strCuentas = IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                   strTipos = IIf(IsNull(rsFacturasNotas!TipoPaciente), "", rsFacturasNotas!TipoPaciente)
                   strPacientes = IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                   strUUIDs = IIf(IsNull(rsFacturasNotas!UUID), "", rsFacturasNotas!UUID)
                   vlintUUIDs = vlintUUIDs + 1
                Else
                  If vlintUUIDs <= 47 Then
                    strFacturas = strFacturas & vbNewLine & IIf(IsNull(rsFacturasNotas!chrfoliofactura), "", rsFacturasNotas!chrfoliofactura)
                    strCuentas = strCuentas & vbNewLine & IIf(IsNull(rsFacturasNotas!INTMOVPACIENTE), "", rsFacturasNotas!INTMOVPACIENTE)
                    strTipos = strTipos & vbNewLine & IIf(IsNull(rsFacturasNotas!TipoPaciente), "", rsFacturasNotas!TipoPaciente)
                    strPacientes = strPacientes & vbNewLine & IIf(IsNull(rsFacturasNotas!Nombre), "", rsFacturasNotas!Nombre)
                    strUUIDs = strUUIDs & vbNewLine & IIf(IsNull(rsFacturasNotas!UUID), "", rsFacturasNotas!UUID)
                    vlintUUIDs = vlintUUIDs + 1
                  ElseIf vlintUUIDs = 48 And vlblnUUIDsFinal = False Then
                    strFacturas = strFacturas & vbNewLine & "..."
                    strCuentas = strCuentas & vbNewLine
                    strTipos = strTipos & vbNewLine
                    strPacientes = strPacientes
                    strUUIDs = strUUIDs & vbNewLine
                    vlblnUUIDsFinal = True
                  End If
                End If
                rsFacturasNotas.MoveNext
            Loop
            rsFacturasNotas.Close
            alstrParametros(5) = "Facturas;" & strFacturas
            alstrParametros(6) = "Cuentas;" & strCuentas
            alstrParametros(7) = "Tipos;" & strTipos
            alstrParametros(8) = "Nombres;" & strPacientes
            alstrParametros(9) = "UUIDs;" & strUUIDs
        End If

        
        pCargaParameterFields alstrParametros, vgrptReporte
        
        '-----------------------------------------------------------------------------------------------------
        '|  Busca un elemento para incrustar el código bidireccional en caso de que el comprobante sea CFDi
        '-----------------------------------------------------------------------------------------------------
        '|  Identifica si el comprobante es CFDi
        blnCFDI = IsNull(RsComprobante!IntAnoAprobacion) And IsNull(RsComprobante!INTNUMEROAPROBACION)
        
        If blnCFDI And blnExisteUUID Then
            If fintSeccionCBB(vgrptReporte) <> -1 Then
            '----------------------------------------------------------------------------
            '|  Genera el CBB si es CFDi
            '----------------------------------------------------------------------------
            
                '|  Obtiene la ruta de los reportes
                If fblnAutoVerificacion Then
                
                    'Valida la ruta de los reportes
            '       strRuta = fstrRutaReportes(strTipo & lngComprobante & ".jpg")
                    Set rsRuta = frsSelParametros("SI", -1, "VCHRUTAREPORTES")
                    If Not rsRuta.EOF Then
                        If Trim(rsRuta!Valor) = "" Then
                            MsgBox "Ocurrió un error al generar el código bidimensional." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                            fblnImprimeComprobanteDigital = False
                            Exit Function
                        ElseIf Not IsNull(Trim(rsRuta!Valor)) Then
                            strRuta = IIf(IsNull(rsRuta("Valor")), "", rsRuta("Valor"))
                            strRutaCBB = IIf(IsNull(rsRuta("Valor")), "", rsRuta("Valor")) & "\" & strTipo & lngComprobante & ".jpg"
                        Else
                            MsgBox "Ocurrió un error al generar el código bidimensional." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                            fblnImprimeComprobanteDigital = False
                            Exit Function
                        End If
                    End If

                    'Valida el acceso a la ruta de los reportes
                    If Dir$(strRuta & "\") <> "" Then
                    'La ruta SI es una ruta válida
                        pGeneraCBB lngComprobante, strTipo, strRutaCBB
                    Else
                    'La ruta NO es válida
                        MsgBox "Ocurrió un error al generar el código bidimensional." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                        fblnImprimeComprobanteDigital = False
                        Exit Function
                    End If

                Else
                
                    'Valida el acceso a la ruta de los reportes
                    If Dir$(App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\") <> "" Then
                    'La ruta SI es una ruta válida
                        strRuta = App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\"
                        strRutaCBB = App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & strTipo & lngComprobante & ".jpg"
                        pGeneraCBB lngComprobante, strTipo, strRutaCBB
                    Else
                    'La ruta NO es válida
                        MsgBox "Ocurrió un error al generar el código bidimensional." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                        fblnImprimeComprobanteDigital = False
                        Exit Function
                    End If
                    
                End If
                
            Else
                MsgBox "No se pudo " & IIf(strDestino = "PDF", "generar el comprobante ", "realizar la impresión ") & "por falta de código bidireccional. " & vbNewLine & vbNewLine & "Revise que el formato que está configurado es para un comprobante del tipo CFDi.", vbCritical, "Mensaje"
                fblnImprimeComprobanteDigital = False
                Exit Function
            End If
        End If
        
        '|  Se va a generar un archivo PDF
        If strDestino = "PDF" Then
            If strRutaPDF <> "" Then
                
                If strRutaCBB <> "" And blnCFDI And blnExisteUUID Then
                    frmReporte.strRutaCBB = strRutaCBB
                    frmReporte.pImprimeCBB vgrptReporte ' Manda llamar a la función que agrega el CBB al reporte
                End If
                vgrptReporte.Database.SetDataSource RsComprobante
                '---------------------------------  --------------------------------------
                '|  Exporta la factura a formato PDF
                '-----------------------------------------------------------------------
                
                'Variable de bandera, que indica si se pasó la validación de la exportación a formato PDF
                vlBandera = 1
                
                blnUsarPDFCreator = fblnUsarPDFCreator()
                If Not blnUsarPDFCreator Then
                    With vgrptReporte
                        .ExportOptions.DiskFileName = strRutaPDF
                        .ExportOptions.DestinationType = crEDTDiskFile
                        .ExportOptions.FormatType = crEFTPortableDocFormat
                        .ExportOptions.PDFExportAllPages = True
                        'Variable de bandera, que indica si la ruta de descarga es válida
                        vlBandera = 2
                        .Export False
                    End With
                Else
                    pGeneraPDF vgrptReporte, strRutaPDF
                End If
                If blnAbrePDF Then shellexecute 0&, "open", strRutaPDF, "", "", vbNormalFocus
            End If
        Else
            fblnAsignaImpresoraReporte vgintNumeroDepartamento, strTipo, vgrptReporte
            'vgrptReporte.SelectPrinter Printer.DriverName, Printer.DeviceName, Printer.port
            'vgrptReporte.PaperOrientation = crDefaultPaperOrientation
            
            'copias a imprimir
            'CASO: 19407 imprimir número copias facturas no fiscales, según parámetros
            If Not blnExisteUUID Then ' si no hay UUID
               intCopiasImpresion = intNumeroCopias
            Else
               If strTipo = "FA" Then
                    If intNumeroCopias = -1 Then
                        intCopiasImpresion = fintNumCopiasImpresion(lngComprobante)
                    Else
                        intCopiasImpresion = intNumeroCopias
                    End If
               Else
                    intCopiasImpresion = 2 'prederminadas son dos
               End If
            End If
            pImprimeReporte vgrptReporte, RsComprobante, strDestino, "Comprobante fiscal digital", , intCopiasImpresion, strRutaCBB
        End If
        
        '|  Elimina el CBB si es CFDi
        If blnCFDI And blnExisteUUID Then
            pEliminaCBB lngComprobante, strTipo, strRutaCBB
        End If
    
    Else
        '|  ¡No existe información!
        MsgBox "No existe la información para generar el comprobante fiscal digital.", vbInformation, "Mensaje"
        Exit Function
    End If
    
    fblnImprimeComprobanteDigital = True
    vlBandera = 0
    Exit Function
    
NotificaError:
    If Err.Number = -2147206452 And Trim(Err.Description) = "The file is in use by another application." Then
        Err.Description = "El archivo está en uso por otra aplicación" & " " & strRutaPDF
    End If
        
    If fso.FileExists(strRutaCBB) Then fso.DeleteFile strRutaCBB
    
    fblnImprimeComprobanteDigital = False
    vlBandera = 0
End Function

'*********************************************************************************************************************************************
Public Function fblnImprimeComprobanteFactura(dblTotal As Double, lngComprobante As Long, strDestino As String, lngFormato As Long, intTipoImpresion As Integer, Optional strRutaPDF As String = "", Optional blnAbrePDF As Boolean = True) As Boolean
    Dim strMoneda As String
    Dim strParametros As String
    Dim RsComprobante As New ADODB.Recordset
    Dim rsTasasIEPS As New ADODB.Recordset
    Dim StrTasasIEPS As String
    Dim StrCanIEPS As String
    Dim alstrParametros(8) As String
    Dim vgrptReporte As CRAXDRT.Report
    Dim strNombreReporte As String
    Dim rsRuta As New ADODB.Recordset
    Dim strRuta As String
    Dim strRutaCBB As String
    Dim vlBandera As Integer
    Dim fso As Scripting.FileSystemObject
    Dim intCopiasImpresion As Integer
    Dim blnUsarPDFCreator As Boolean
      
On Error GoTo NotificaError:
    
    fblnImprimeComprobanteFactura = False
    vlBandera = 0
    strRuta = ""
    strRutaCBB = ""
    
    Set fso = New Scripting.FileSystemObject
   
    strNombreReporte = "rptFacturasinComprobante.rpt"
    
    '|  Selecciona los datos del comprobante fiscal digital
    strParametros = lngComprobante
    Set RsComprobante = frsEjecuta_SP(strParametros, "SP_GNSELFACTURASINCOMPROBANTE")
    If RsComprobante.RecordCount > 0 Then
        '-----------------------------------------------------------------------
        '|  Instancia el reporte dependiendo del tipo de documento
        '-----------------------------------------------------------------------
        pInstanciaReporte vgrptReporte, strNombreReporte
        vgrptReporte.DiscardSavedData
        strMoneda = RsComprobante!Moneda
        
        'strMoneda = UCase(RsComprobante!VCHMONEDAADDENDA)
        alstrParametros(0) = "pCantidadLetras;" & fstrNumeroenLetras(dblTotal, strMoneda, "")
        alstrParametros(1) = "NombreHospital;" & Trim(vgstrNombreHospitalCH)
        alstrParametros(2) = "Tasaiva;" & (vgdblCantidadIvaGeneral / 100)
        alstrParametros(3) = "CanIEPS;" & StrCanIEPS
                
        pCargaParameterFields alstrParametros, vgrptReporte
        
        'Valida el acceso a la ruta de los reportes
        If Dir$(App.Path & IIf(cgstrModulo = "PV", "\" & vgstrNombreCarpeta, "") & "\Reportes\") <> "" Then
        'La ruta SI es una ruta válida
            strRuta = App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\"
        Else
        'La ruta NO es válida
            MsgBox "La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
            fblnImprimeComprobanteFactura = False
            Exit Function
        End If
    End If
        
        '|  Se va a generar un archivo PDF
        If strDestino = "PDF" Then
            If strRutaPDF <> "" Then
                
                vgrptReporte.Database.SetDataSource RsComprobante
                '-----------------------------------------------------------------------
                '|  Exporta la factura a formato PDF
                '-----------------------------------------------------------------------
                
                'Variable de bandera, que indica si se pasó la validación de la exportación a formato PDF
                vlBandera = 1
                
                blnUsarPDFCreator = fblnUsarPDFCreator()
                If Not blnUsarPDFCreator Then
                    With vgrptReporte
                        .ExportOptions.DiskFileName = strRutaPDF
                        .ExportOptions.DestinationType = crEDTDiskFile
                        .ExportOptions.FormatType = crEFTPortableDocFormat
                        .ExportOptions.PDFExportAllPages = True
                        'Variable de bandera, que indica si la ruta de descarga es válida
                        vlBandera = 2
                        .Export False
                    End With
                Else
                    pGeneraPDF vgrptReporte, strRutaPDF
                End If
                If blnAbrePDF Then shellexecute 0&, "open", strRutaPDF, "", "", vbNormalFocus
            End If
        Else
            fblnAsignaImpresoraReporte vgintNumeroDepartamento, "FA", vgrptReporte
            'vgrptReporte.SelectPrinter Printer.DriverName, Printer.DeviceName, Printer.port
            'vgrptReporte.PaperOrientation = crDefaultPaperOrientation
            intCopiasImpresion = 1
           
            pImprimeReporte vgrptReporte, RsComprobante, strDestino, "Facturación", , intCopiasImpresion, strRutaCBB
        End If
    
    fblnImprimeComprobanteFactura = True
    vlBandera = 0
    Exit Function
    
NotificaError:
    If fso.FileExists(strRutaCBB) Then fso.DeleteFile strRutaCBB
    
    fblnImprimeComprobanteFactura = False
    vlBandera = 0
'*********************************************************************************************************************************************
End Function

'------------------------------------------------------------------------------------------------------------------
'|  Identifica la sección en la que se encuentra el elemento llamado CBB para incrustar el código bidireccional
'------------------------------------------------------------------------------------------------------------------
Public Function fintSeccionCBB(crReport As CRAXDRT.Report) As Integer
    Dim crSection As CRAXDRT.Section
    Dim crReportObject As Object
    Dim blnCBB As Boolean
    
    fintSeccionCBB = -1
    '|  Recorre todas las secciones
    For Each crSection In crReport.Sections
        '|  Recorre todos los objetos de la sección
        For Each crReportObject In crSection.ReportObjects
            If crReportObject.Name = "CBB" Then
                fintSeccionCBB = crSection.Number + 1
                Exit For
            End If
        Next
        If fintSeccionCBB <> -1 Then Exit For
    Next
End Function

'------------------------------------------------------------------------------------------------------------------
'|  Identifica la sección en la que se encuentra el elemento llamado CBB para incrustar el código bidireccional
'------------------------------------------------------------------------------------------------------------------
Public Function fintSeccionCBB1(crReport As CRAXDRT.Report) As Integer
    Dim crSection As CRAXDRT.Section
    Dim crReportObject As Object
    Dim blnCBB As Boolean
    
    fintSeccionCBB1 = -1
    '|  Recorre todas las secciones
    For Each crSection In crReport.Sections
        '|  Recorre todos los objetos de la sección
        For Each crReportObject In crSection.ReportObjects
            If crReportObject.Name = "CBB1" Then
                fintSeccionCBB1 = crSection.Number + 1
                Exit For
            End If
        Next
        If fintSeccionCBB1 <> -1 Then Exit For
    Next
End Function

Public Function fstrCadenaOriginal(strArchivoXML As String, blnCFDI As Boolean) As String
    Dim domDocXML As New DOMDocument
    Dim domDocXSLT As New DOMDocument
    Dim XSLTcadenaOriginal As String
    Dim fso As Scripting.FileSystemObject
    Dim rsRuta As New ADODB.Recordset
    Dim strRuta As String
    
    Set fso = New Scripting.FileSystemObject
    
On Error GoTo NotificaError:
    domDocXML.async = False
    domDocXSLT.async = False
    
    'Se determina que archivo se utilizará para la generación de la cadena original
    If blnCFDI = True Then
        If vgstrVersionCFDI = "3.2" Then
            XSLTcadenaOriginal = "cadenaoriginal32.xslt"
        ElseIf vgstrVersionCFDI = "3.3" Then
            XSLTcadenaOriginal = "cadenaoriginal_3_3.xslt"
        Else
            XSLTcadenaOriginal = "cadenaoriginal_4_0.xslt"
        End If
    Else
        XSLTcadenaOriginal = "cadenaoriginal22.xslt"
    End If
    
    '|  Archivo XML firmado
    domDocXML.Load strArchivoXML
    
'###########################################################
    If fblnAutoVerificacion Then
        
        'Valida la ruta de los reportes
        Set rsRuta = frsSelParametros("SI", -1, "VCHRUTAREPORTES")
        If Not rsRuta.EOF Then
            If Trim(rsRuta!Valor) = "" Then
                MsgBox "Ocurrió un error al generar la cadena original." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                fstrCadenaOriginal = ""
                Exit Function
            ElseIf Not IsNull(Trim(rsRuta!Valor)) Then
                strRuta = IIf(IsNull(rsRuta("Valor")), "", rsRuta("Valor"))
            Else
                MsgBox "Ocurrió un error al generar la cadena original." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
                fstrCadenaOriginal = ""
                Exit Function
            End If
        End If
    
        'Valida el acceso a la ruta de los reportes
        If Dir$(strRuta & "\") <> "" Then
        'La ruta SI es una ruta válida
            If fso.FileExists(strRuta & "\" & XSLTcadenaOriginal) = False Then
                MsgBox "No se realizó la impresión." & vbCrLf & vbCrLf & "Se esperaba el archivo: " & vbNewLine & strRuta & "\" & XSLTcadenaOriginal, vbCritical, "Mensaje"
                fstrCadenaOriginal = ""
                Exit Function
            Else
                '|  Archivo XSLT proporcionado por el SAT
                domDocXSLT.Load fstrRutaReportes(XSLTcadenaOriginal)
                fstrCadenaOriginal = domDocXML.transformNode(domDocXSLT)
            End If
        Else
        'La ruta NO es válida
            MsgBox "Ocurrió un error al generar la cadena original." & vbNewLine & vbNewLine & "- La ruta de reportes no es válida o no se tiene acceso.", vbCritical, "Mensaje"
            fstrCadenaOriginal = ""
            Exit Function
        End If
        
    Else
        If fso.FileExists(App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & XSLTcadenaOriginal) = False Then
            MsgBox SIHOMsg(1026) & vbCrLf & vbCrLf & "Se esperaba el archivo: " & vbNewLine & App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & XSLTcadenaOriginal, vbCritical, "Mensaje"
            fstrCadenaOriginal = ""
            Exit Function
        Else
            '|  Archivo XSLT proporcionado por el SAT
            domDocXSLT.Load App.Path & IIf(cgstrModulo = "SE", "\" & vgstrNombreCarpeta, "") & "\Reportes\" & XSLTcadenaOriginal
            fstrCadenaOriginal = domDocXML.transformNode(domDocXSLT)
        End If
    End If
'###########################################################
    
    
Exit Function
    
NotificaError:
    fstrCadenaOriginal = ""
End Function

Public Function fblnDescargaXML(lngComprobante As Long, strTipo As String, strNombre As String, Optional strTabla As String = "") As Boolean
    Dim strSentencia As String
    Dim RsComprobante As New ADODB.Recordset
    Dim stmComprobante As New ADODB.Stream
    Dim stmComprobanteSinBOM As New ADODB.Stream
    
On Error GoTo NotificaError:
    
    '----------------------------------------------------------------------------------------
    '|  Descarga archivo XML en directorio local
    '----------------------------------------------------------------------------------------
    '|  Consulta campo CLOB que contiene XML del comprobante sin firmar
    If strTabla = "" Then
       strSentencia = "SELECT CLBCOMPROBANTEFISCAL " & _
                      "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                      " WHERE INTCOMPROBANTE = " & lngComprobante & _
                      "   AND CHRTIPOCOMPROBANTE = '" & strTipo & "'"
    Else
       strSentencia = "SELECT CLBCOMPROBANTEFISCAL" & _
                      "  FROM PVCANCELARCOMPROBANTES " & _
                      " WHERE INTCOMPROBANTE = " & lngComprobante & _
                      "   AND VCHTIPOCOMPROBANTE = '" & strTipo & "'"
    End If
    Set RsComprobante = frsRegresaRs(strSentencia)
    
    '|  Descarga XML en directorio local del cliente
    With stmComprobante
        .Charset = "utf-8"
        .Open
        '|  Establece el grupo de caracteres UTF-8

        .WriteText RsComprobante!CLBCOMPROBANTEFISCAL
        .position = 0
'        .SaveToFile strNombre, adSaveCreateOverWrite
        .Type = 2
        .position = 3
    End With
    
    With stmComprobanteSinBOM
      .Type = 1
      .Open
      stmComprobante.CopyTo stmComprobanteSinBOM
      .SaveToFile strNombre, adSaveCreateOverWrite
    End With
    
    stmComprobante.Close
    stmComprobanteSinBOM.Close
    
    RsComprobante.Close
    fblnDescargaXML = True
    
    Exit Function
NotificaError:
    If Err.Number = 3004 And Trim(Err.Description) = "Write to file failed." Then
        Err.Description = "No fue posible escribir el archivo " & strNombre & ". " & SIHOMsg(1190)
    End If
    If Err.Number = -2147206452 And Trim(Err.Description) = "The file is in use by another application." Then
        Err.Description = "El archivo está en uso por otra aplicación. Ruta y nombre del archivo: " & " " & strNombre
    End If
    MsgBox Err.Description, vbOKOnly + vbInformation, "Información"
    Resume Next
    fblnDescargaXML = True
'    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnDescargaXML"))
'    fblnDescargaXML = False
End Function

Public Function fblnDescargaXMLNom(lngComprobante As Long, strTipo As String, strNombre As String) As Boolean
    Dim strSentencia As String
    Dim RsComprobante As New ADODB.Recordset
    Dim stmComprobante As New ADODB.Stream
    
On Error GoTo NotificaError:
    
    '----------------------------------------------------------------------------------------
    '|  Descarga archivo XML en directorio local
    '----------------------------------------------------------------------------------------
    '|  Consulta campo CLOB que contiene XML del comprobante sin firmar
    strSentencia = "SELECT CLBCOMPROBANTEFISCAL " & _
                   "  FROM GNCFDIGITALNOMINA " & _
                   " WHERE INTIDCOMPROBANTE = " & lngComprobante '& _
                '   "   AND CHRTIPOCOMPROBANTE = '" & strTipo & "'"
    Set RsComprobante = frsRegresaRs(strSentencia)
    '|  Descarga XML en directorio local del cliente
    With stmComprobante
        .Open
        '|  Establece el grupo de caracteres UTF-8
        .Charset = "utf-8"
        .WriteText RsComprobante!CLBCOMPROBANTEFISCAL, adWriteChar
        .SaveToFile strNombre, adSaveCreateOverWrite
        .Close
    End With
    RsComprobante.Close
    fblnDescargaXMLNom = True
    
    Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnDescargaXMLNom"))
    fblnDescargaXMLNom = False
End Function

Public Function fblnDescargaXMLCFDi(lngComprobante As Long, strTipo As String, strNombre As String) As Boolean
    Dim strSentencia As String
    Dim RsComprobante As New ADODB.Recordset
    
    Dim stmComprobante As New ADODB.Stream
    Dim stmComprobanteSinBOM As New ADODB.Stream
    
On Error GoTo NotificaError:
    
    fblnDescargaXMLCFDi = True
    
    '----------------------------------------------------------------------------------------
    '|  Descarga archivo XML en directorio local
    '----------------------------------------------------------------------------------------
    '|  Consulta campo CLOB que contiene XML del comprobante sin firmar
    strSentencia = "SELECT CLBCFDITIMBRADO " & _
                   "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                   " WHERE INTCOMPROBANTE = " & lngComprobante & _
                   "   AND CHRTIPOCOMPROBANTE = '" & strTipo & "'"
    Set RsComprobante = frsRegresaRs(strSentencia)
    '|  Descarga XML en directorio local del cliente
    With stmComprobante
        .Charset = "utf-8"
        .Open
        .WriteText RsComprobante!CLBCFDITIMBRADO
        .position = 0
        .Type = 2
        .position = 3
    End With
    
    With stmComprobanteSinBOM
      .Type = 1
      .Open
      stmComprobante.CopyTo stmComprobanteSinBOM
      .SaveToFile strNombre, adSaveCreateOverWrite
    End With
    
    stmComprobante.Close
    stmComprobanteSinBOM.Close
    
    RsComprobante.Close
    
    Exit Function

NotificaError:
    If Err.Number = 3004 And Trim(Err.Description) = "Write to file failed." Then
'        Err.Description = "No fue posible escribir el archivo " & strNombre
        Err.Description = "No fue posible escribir el archivo " & strNombre & ". " & SIHOMsg(1190)
    End If
    If Err.Number = -2147206452 And Trim(Err.Description) = "The file is in use by another application." Then
'        Err.Description = "El archivo está en uso por otra aplicación" & " " & strNombre
        Err.Description = "El archivo está en uso por otra aplicación. Ruta y nombre del archivo: " & " " & strNombre
    End If
    MsgBox Err.Description, vbOKOnly + vbInformation, "Información"
    Resume Next
    fblnDescargaXMLCFDi = True
'    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnDescargaXMLCFDi"))
'    fblnDescargaXMLCFDi = False
End Function

Public Function fblnDescargaXMLCFDiNom(lngComprobante As Long, strTipo As String, strNombre As String) As Boolean
    Dim strSentencia As String
    Dim RsComprobante As New ADODB.Recordset
    Dim stmComprobante As New ADODB.Stream
    
On Error GoTo NotificaError:
    
    '----------------------------------------------------------------------------------------
    '|  Descarga archivo XML en directorio local
    '----------------------------------------------------------------------------------------
    '|  Consulta campo CLOB que contiene XML del comprobante sin firmar
    strSentencia = "SELECT CLBCFDITIMBRADO " & _
                   "  FROM GNCFDIGITALNOMINA " & _
                   " WHERE INTIDCOMPROBANTE = " & lngComprobante '& _
                   '"   AND CHRTIPOCOMPROBANTE = '" & strTipo & "'"
    Set RsComprobante = frsRegresaRs(strSentencia)
    '|  Descarga XML en directorio local del cliente
    With stmComprobante
        .Open
        '|  Establece el grupo de caracteres UTF-8
        .Charset = "utf-8"
        .WriteText RsComprobante!CLBCFDITIMBRADO, adWriteChar
        .SaveToFile strNombre, adSaveCreateOverWrite
        .Close
    End With
    RsComprobante.Close
    fblnDescargaXMLCFDiNom = True
    
    Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnDescargaXMLCFDiNom"))
    fblnDescargaXMLCFDiNom = False
End Function

'--------------------------------------------------------------------------------'
'|  Descarga archivo XML del acuse de cancelación del CFDi en directorio local  |'
'--------------------------------------------------------------------------------'
Public Function fblnDescargaXMLCancelacion(lngComprobante As Long, strArchivo As String) As Boolean
On Error GoTo NotificaError:
    
    Dim strSentencia As String
    Dim rsAcuse As New ADODB.Recordset
    Dim stmAcuse As New ADODB.Stream
    
    '|  Consulta campo que contiene XML del acuse de cancelación
    strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTIDCOMPROBANTE = " & lngComprobante
    Set rsAcuse = frsRegresaRs(strSentencia)
    '|  Descarga XML en directorio local del cliente
    With stmAcuse
        .Open
        .Charset = "utf-8"  'Establece el grupo de caracteres UTF-8
        .WriteText rsAcuse!CLBXMLACUSE, adWriteChar
        .SaveToFile strArchivo, adSaveCreateOverWrite
        .Close
    End With
    rsAcuse.Close
    
    fblnDescargaXMLCancelacion = True
    
Exit Function
NotificaError:
    If Err.Number = 3004 And Trim(Err.Description) = "Write to file failed." Then
        Err.Description = "No fue posible escribir el archivo " & strArchivo
    End If
    If Err.Number = -2147206452 And Trim(Err.Description) = "The file is in use by another application." Then
        Err.Description = "El archivo está en uso por otra aplicación" & " " & strArchivo
    End If
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnDescargaXMLCancelacion"))
    fblnDescargaXMLCancelacion = False
End Function

'| Convierte un arreglo de bytes UTF-8 a  una cadena Unicode
Public Function fstrUTF8ToUni(byteUTF8() As Byte) As String
    Dim lngBytes As Long
    Dim lngNC As Long
    Dim lngRet As Long

    lngBytes = UBound(byteUTF8) - LBound(byteUTF8) + 1
    lngNC = lngBytes
    fstrUTF8ToUni = String$(lngNC, Chr(0))
    lngRet = MultiByteToWideChar(CP_UTF8, 0, VarPtr(byteUTF8(LBound(byteUTF8))), lngBytes, StrPtr(fstrUTF8ToUni), lngNC)
    fstrUTF8ToUni = Left$(fstrUTF8ToUni, lngRet)
End Function

Public Function fstrConvierteArchivoUTF8(strArchivoUTF8 As String) As String
  
    Dim byteDato() As Byte
    Dim lngTamano As Long
    Dim intArchivo As Integer
    Dim strDato As String
   
    Dim vLine As Variant
    Dim isUTF As Boolean
    Dim i As Integer
    Dim daten As String
    Dim by1 As Byte
    Dim by2 As Byte
    Dim isBOM As Boolean
    
    '|  Obtiene el tamaño del archivo
    lngTamano = FileLen(strArchivoUTF8)
    If lngTamano > 0 Then
        ReDim byteDato(0 To lngTamano - 1)
        '|  Lee el archivo en formato UTF-8
        intArchivo = FreeFile()
        Open strArchivoUTF8 For Binary As #intArchivo
        Get #intArchivo, , byteDato
        Close #intArchivo
        '|  Convierte los datos a Unicode
        strDato = fstrUTF8ToUni(byteDato)
    Else
        strDato = ""
    End If
    fstrConvierteArchivoUTF8 = strDato
End Function

Public Function fstrConvierteStringUTF8(InputStr As String) As String
  
'Dim bytSrc() As Byte
'Dim bytDest() As Byte
'Dim i As Long
'Dim strDato As String
'
'   bytSrc = InputStr
'   ReDim bytDest(UBound(bytSrc) \ 2)
'   For i = 0 To UBound(bytDest)
'      bytDest(i) = bytSrc(i * 2)
'   Next
'
'    '|  Convierte los datos a Unicode
'    strDato = fstrUTF8ToUni(bytDest)
'
'   fstrConvierteStringUTF8 = strDato

    Dim objStream As ADODB.Stream
    Dim data() As Byte
    Dim strDato As String
    
    ' init stream
    Set objStream = New ADODB.Stream
    objStream.Charset = "utf-8"
    objStream.Mode = adModeReadWrite
    objStream.Type = adTypeText
    objStream.Open
    
    ' write bytes into stream
    objStream.WriteText InputStr, adWriteChar
    objStream.Flush
    
    ' rewind stream and read text
    objStream.position = 0
    objStream.Type = adTypeBinary
    objStream.Read 3 ' skip first 3 bytes as this is the utf-8 marker
    data = objStream.Read()
    
    ' close up and return
    objStream.Close
'    fstrConvierteStringUTF8 = data
   
    '|  Convierte los datos a Unicode
    strDato = fstrUTF8ToUni(data)

   fstrConvierteStringUTF8 = strDato
   
End Function


Public Sub pParametrosCuartos()
On Error GoTo Errs
Dim rs As ADODB.Recordset
Dim strData As String
Dim strNoCensables As String
Dim strCensables As String

    Set rs = frsRegresaRs("select * from ADBLOB where intId = 1")
    strData = rs("blbData").GetChunk(255)
    rs.Close
    strData = fstrEncrypt2(fstrConvierteChr(strData), "carlos")
    If fblnEsValida(strData, strCensables, strNoCensables) Then
        If IsNumeric(strCensables) Then
            gintNumeroCuartosCensablesPermitidos = CInt(strCensables)
        Else
            gintNumeroCuartosCensablesPermitidos = -1
        End If
        If IsNumeric(strNoCensables) Then
            gintNumeroCuartosNoCensablesPermitidos = CInt(strNoCensables)
        Else
            gintNumeroCuartosNoCensablesPermitidos = -1
        End If
    Else
        gintNumeroCuartosCensablesPermitidos = 0
        gintNumeroCuartosNoCensablesPermitidos = 0
    End If

Exit Sub
Errs:
    gintNumeroCuartosCensablesPermitidos = 0
    gintNumeroCuartosNoCensablesPermitidos = 0
End Sub

Private Function fblnEsValida(strData As String, strCensables As String, strNoCensables As String) As Boolean
    Dim intPosC As Integer
    Dim intPosN As Integer
    intPosC = InStr(1, strData, "C")
    intPosN = InStr(1, strData, "N")
    If intPosC = 0 Then
        fblnEsValida = False
        Exit Function
    Else
        If intPosN = 0 Or intPosN <> Len(strData) Then
            fblnEsValida = False
            Exit Function
        Else
            strCensables = Mid(strData, 1, InStr(1, strData, "C") - 1)
            strNoCensables = Mid(strData, InStr(1, strData, "C") + 1, InStr(1, strData, "N") - InStr(1, strData, "C") - 1)
            If Not IsNumeric(strCensables) Then
                If strCensables <> "UL" Then
                    fblnEsValida = False
                    Exit Function
                End If
            End If
            If Not IsNumeric(strNoCensables) Then
                If strNoCensables <> "UL" Then
                    fblnEsValida = False
                    Exit Function
                End If
            End If
        End If
    End If
    fblnEsValida = True
End Function

Public Sub pRegistrarCuentaHistorial(lngnumCuenta As Long, strTipoPac As String, strTipoIngreso As String, lngCveEmpleado As Long, lngCveDepartamento As Long)
    Dim strParam As String
    strParam = lngnumCuenta & "|" & strTipoPac & "|" & strTipoIngreso & "|" & lngCveEmpleado & "|" & lngCveDepartamento
    frsEjecuta_SP strParam, "sp_ADInsCuentaHistorial", True
End Sub

Public Sub pParametrosAdmision()

    Dim rs As ADODB.Recordset
    
On Error GoTo NotificaError
    
    vgblnBanderaParametrosRegistrados = False
    'Carga los parámetros del módulo de Admisión (AD)
    Set rs = frsSelParametros("AD", -1)
    
    If rs.RecordCount <> 0 Then
        vgblnBanderaParametrosRegistrados = True
        While Not rs.EOF
            Select Case rs("Nombre")
                Case "INTCVERELIGIONPREDETERMINADA"
                    vglngCveReligionPredeterminada = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTDIASINGRESOPREVIO"
                    vglngDiasIngresoPrevio = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "VCHOBSERVACIONESINGRESO"
                    vgstrObservacionesIngreso = IIf(IsNull(rs("Valor")), "", rs("Valor"))
                Case "CHRPATERNODESCONOCIDO"
                    vgstrPaternoDesconocido = IIf(IsNull(rs("Valor")), "", rs("Valor"))
                Case "CHRMATERNODESCONOCIDO"
                    vgstrMaternoDesconocido = IIf(IsNull(rs("Valor")), "", rs("Valor"))
                Case "CHRNOMBREDESCONOCIDO"
                    vgstrNombreDesconocido = IIf(IsNull(rs("Valor")), "", rs("Valor"))
                Case "INTCVEESTADOCUARTODISPONIBLE"
                    vglngCveEstadoCuartoDisponible = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "INTCVEESTADOCUARTOOCUPADO"
                    vglngCveEstadoCuartoOcupado = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
                Case "BITASIGNARPAQUETE"
                    vgblnAsignarPaqueteAdmision = IIf(IsNull(rs("Valor")), 0, rs("Valor"))
            End Select
            rs.MoveNext
        Wend
    Else
        vglngCveReligionPredeterminada = 0
        vglngDiasIngresoPrevio = 0
        vgstrObservacionesIngreso = ""
        vgstrPaternoDesconocido = ""
        vgstrMaternoDesconocido = ""
        vgstrNombreDesconocido = ""
        vglngCveEstadoCuartoDisponible = 0
        vglngCveEstadoCuartoOcupado = 0
        vgblnAsignarPaqueteAdmision = True
        
        'No están registrados los parámetros del módulo.
        MsgBox SIHOMsg(1043), vbOKOnly + vbExclamation, "Mensaje"
    End If
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pParametrosAdmision"))
    
End Sub

Public Function fStrRFCValido(strRFC As String) As String
' Función que regresa un RFC en formato válido, dejando solo Letras o Números
    Dim vlAscii As Integer
    Dim vlRFCValido As String
    Dim vlintContLongitud As Integer

    vlAscii = 0
    vlRFCValido = ""
    For vlintContLongitud = 1 To Len(strRFC)
        vlAscii = Asc(Mid(strRFC, vlintContLongitud, 1))
        If (vlAscii >= 48 And vlAscii <= 57) Or (vlAscii >= 65 And vlAscii <= 90) Or (vlAscii >= 97 And vlAscii <= 122) Or (vlAscii = 38 Or vlAscii = 209 Or vlAscii = 241) Then
            vlRFCValido = vlRFCValido & Mid(strRFC, vlintContLongitud, 1)
        End If
    Next vlintContLongitud
    
    fStrRFCValido = vlRFCValido
    
End Function

' Verifica que el Hospital haya adquirido la aplicación móvil
Public Function fblAplicacionMovil() As Boolean
    Dim rsTemp As ADODB.Recordset
    Dim strEncriptado As String
    Dim strSql As String
    
    fblAplicacionMovil = False
    
    strSql = ""
    'Determina si se adquirio licencia para la Aplicacion Movil
    strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC, TRIM(SIPARAMETRO.VCHVALOR) AS VALOR " & _
        "FROM SIPARAMETRO,CNEMPRESACONTABLE WHERE " & _
        "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable & " AND SIPARAMETRO.VCHNOMBRE = 'VCHAPLICACIONMOVIL' AND SIPARAMETRO.INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable
    Set rsTemp = frsRegresaRs(strSql)
    If Not rsTemp.EOF Then
        strEncriptado = fstrEncrypt(rsTemp!RFC, "SIHOMOVIL")
        fblAplicacionMovil = IIf(rsTemp!Valor = strEncriptado, True, False)
    End If
End Function


'|  Valida si se va a realizar una comunicación con un sistema externo (PACS)
Public Sub pActualizaTablaDeControl(vlintNumSolEstudio As Long)
    Dim rsTablaControl As New ADODB.Recordset
    Dim strSentencia As String
    
    '|  Consulta si existe la tabla 'PACSIMTABLACONTROL'
    strSentencia = "SELECT * FROM USER_TABLES UT WHERE UT.TABLE_NAME = 'PACSIMTABLACONTROL'"
    Set rsTablaControl = frsRegresaRs(strSentencia, adLockReadOnly, adOpenForwardOnly)
    '|  Si existe la tabla significa que esta instalada la interfaz con el PACS y se tiene que actualizar la tabla PACSIMTABLACONTROL
    '|  para que se ejecute el trigger de actualización que es el que realiza la comunicación.
    If rsTablaControl.RecordCount > 0 Then
        strSentencia = "UPDATE PACSIMTABLACONTROL " & _
                       "   SET PACSIMTABLACONTROL.INTPROCESADO = 1 " & _
                       " WHERE PACSIMTABLACONTROL.INTID IN (SELECT MAX(INTID) " & _
                       "                                      FROM PACSIMTABLACONTROL " & _
                       "                                     WHERE PACSIMTABLACONTROL.INTNUMSOLESTU = " & vlintNumSolEstudio & ")"
        pEjecutaSentencia strSentencia
    End If
End Sub

' PROCEDIMIENTO PARA EL INTERCAMBIO DE INFORMACIÓN DE ORACLE A SQL SERVER A TRAVÉS DE DB LINK '
'-- NOTA: Si no existe el procedimiento SP_EXPORTARECE no se realiza ninguna operación --'
Public Sub pInsertaPacienteRemoto(lngnumCuenta As Long, lngTipoIngreso As Long, blnAlta As Boolean, Optional lngNumExpediente As Long = 0)
On Error GoTo NotificaError

    Dim vlrsSP As New ADODB.Recordset
    Dim vlstrParametros As String
    Dim vlstrAccion As String 'Tipo de acción
    Dim vlstrQry As String
    
    If lngnumCuenta > 0 Then 'Existe cuenta de paciente >>INTERNO<<
        '-- Revisar si existe el procedimiento almacenado SP_EXPORTARECE --'
        Set vlrsSP = frsRegresaRs("SELECT * FROM USER_PROCEDURES WHERE object_name = 'SP_EXPORTARECE'", adLockReadOnly, adOpenForwardOnly)
        If vlrsSP.RecordCount > 0 Then
            vlstrQry = "SELECT * FROM EXPACIENTEINGRESO WHERE INTNUMCUENTA = " & lngnumCuenta & " AND INTCVETIPOINGRESO = " & lngTipoIngreso
            If lngNumExpediente > 0 Then 'Agrega como condicional también el número de expediente
                vlstrQry = vlstrQry & " AND INTNUMPACIENTE = " & lngNumExpediente
            End If
            
            Set vlrsSP = frsRegresaRs(vlstrQry, adLockReadOnly, adOpenForwardOnly)
            If vlrsSP.RecordCount > 0 Then 'Asegura que exista información de ingreso de la cuenta del paciente
                If blnAlta Then
                    vlstrAccion = "I" 'Inserción
                Else
                    vlstrAccion = "A" 'Actualización
                End If
                
                EntornoSIHO.ConeccionSIHO.BeginTrans
                
                vlstrParametros = lngnumCuenta & "|" & lngTipoIngreso & "|" & vlstrAccion
                frsEjecuta_SP vlstrParametros, "SP_EXPORTARECE"
                
                EntornoSIHO.ConeccionSIHO.CommitTrans 'Se debe cometer la transacción para que los datos aparezcan en la BD remota
            End If
            vlrsSP.Close
        End If
    End If
    
    Exit Sub
    
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":InsertaPacienteRemoto"))
End Sub

Public Function fblnCancelaCFDi(lngComprobante As Long, strTipo As String) As Boolean
On Error GoTo NotificaError:

    Dim fsoArchivoXML As New FileSystemObject
    Dim RsComprobante As New ADODB.Recordset
    Dim rsAcuse As New ADODB.Recordset
    Dim strSentencia As String
    Dim strDestino As String
    Dim strXMLCancelado As String
    Dim lngConsecutivo As Long
    Dim strUUId As String
    Dim strRFC As String
    Dim strRFCReceptor As String '--> Agregado para la cancelación del CFDi en Buzón Fiscal
    Dim strTotalComprobante As String '| Solicitad en el nuevo esquema de cancelación
    Dim strXMLCancelacion As String
    Dim blnCFDI As Boolean
    Dim rsPAC As New ADODB.Recordset
    Dim lngUUIDPacInterfaz As Long
    Dim intPAC As Integer
    Dim blnMostrarMsjNotificaError As Boolean 'Esta variable indica si se mostrará un mensaje de error, en caso de que se presente alguno
    Dim ObjRS As New ADODB.Recordset
    Dim strArchivoCertificado As String
    Dim strArchivoLlave As String
    Dim strContrasena As String
    Dim strNombreBase As String
    Dim stmComprobante As New ADODB.Stream
    Dim strError As String
    
    Dim strCerRFC As String
    Dim strCerFechaHoraValidaDesde As String
    Dim strCerFechaHoraValidaDesdeLetra As String
    Dim strCerFechaValidaDesde As String
    Dim strCerHoraValidaDesde As String
    Dim strCerFechaHoraValidaHasta As String
    Dim strCerFechaHoraValidaHastaLetra As String
    Dim strCerFechaValidaHasta As String
    Dim strCerHoraValidaHasta As String
    Dim strCerEmpresaEmisora As String
    Dim strCerNumCertificado As String
    Dim intlineaGoto As Integer
    
    Dim strFechaHoraServer As String
    Dim strFechaServer As String
    Dim strHoraServer As String
    Dim strFechaHoraServerLetra As String
    
    Dim lngTiempoRestanteHrs As Long
    Dim lngTiempoRestanteMins As Long
    Dim strTiempoRestanteTotal As String
    
    Dim fsoComprobante As New FileSystemObject
    
     'Se obtienen fecha y hora (formateadas) del servidor para las validaciones de la vigencia del certificado
1    strFechaHoraServer = Format(fdtmServerFechaHora, "DD/MM/YYYY HH:MM:SS")
2    strFechaServer = Mid(strFechaHoraServer, 1, 10)
3    strHoraServer = Mid(strFechaHoraServer, 12)
4    strFechaHoraServerLetra = Mid(strFechaHoraServer, 1, 3) & fstrMesLetra(Mid(strFechaHoraServer, 4, 2), False) & Mid(strFechaHoraServer, 6)
    
    blnMostrarMsjNotificaError = True
    
    
    
     'Se elimina el contenido de la carpeta temporal
5    strDestino = Environ$("temp") & "\dA-Ms19"
6    pCreaDirectorio strDestino
7    On Error Resume Next
    
     'Checa que el directorio se haya creado, para proceder a eliminar el archivo (evita el error 53)
8    If Dir$(strDestino & "\") <> "" Then
9        Kill strDestino & "\*.*"
10        If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
11            Err.Clear
          Else
13              Err.Raise Err.Number
          End If
     End If

     '|  Inicializa nombre de archivos de trabajo y variables de control
     strNombreBase = strDestino & "\" & "CANC_"
20    strArchivoLlave = strNombreBase & ".key"
21    strArchivoCertificado = strNombreBase & ".cer"
23    blnMostrarMsjNotificaError = True
      
      '|  Consulta archivo .CER, .KEY y Contraseña almacenado en la base de datos
28    strSentencia = "SELECT BLBCERTIFICADO " & _
                   "     , BLBLLAVE " & _
                   "     , VCHCONTRASENA " & _
                   "     , VCHRFC " & _
                   "  FROM CNEMPRESACONTABLE " & _
                   " WHERE CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
29    Set RsComprobante = frsRegresaRs(strSentencia)

      '|  Descarga archivo Certificado en directorio local del cliente
30    If Not IsNull(RsComprobante!BLBCERTIFICADO) Then
31       With stmComprobante
32            .Type = adTypeBinary
33            .Open
34            .Write RsComprobante!BLBCERTIFICADO
35            .SaveToFile strArchivoCertificado, adSaveCreateOverWrite
36            .Close
         End With
        
         'Se digiere el contenido del certificado...
37        strError = "Error en la digestión del archivo .CER"
38        strCerRFC = Trim(satQueryCert(strArchivoCertificado, "rfc"))
39        strCerRFC = Trim(Replace(Replace(Replace(strCerRFC, "-", ""), "_", ""), " ", ""))
40        strCerNumCertificado = Trim(satQueryCert(strArchivoCertificado, "serialNumber"))
41        strCerEmpresaEmisora = Trim(satQueryCert(strArchivoCertificado, "organizationName"))
42        strCerFechaHoraValidaDesde = Trim(satQueryCert(strArchivoCertificado, "notBefore"))
43        strCerFechaHoraValidaHasta = Trim(satQueryCert(strArchivoCertificado, "notAfter"))
        
          'Formateo y desglose de las fechas y horas del certificado
44        strError = "Error de formateo de las fecha de vigencia del certificado"
45        strCerFechaHoraValidaDesde = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaDesde, 12, 8)
46        strCerFechaValidaDesde = Mid(strCerFechaHoraValidaDesde, 1, 10)
47        strCerHoraValidaDesde = Mid(strCerFechaHoraValidaDesde, 12)
48        strCerFechaHoraValidaDesdeLetra = Mid(strCerFechaHoraValidaDesde, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaDesde, 4, 2), False) & Mid(strCerFechaHoraValidaDesde, 6)
49        strCerFechaHoraValidaHasta = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaHasta, 12, 8)
50        strCerFechaValidaHasta = Mid(strCerFechaHoraValidaHasta, 1, 10)
51        strCerHoraValidaHasta = Mid(strCerFechaHoraValidaHasta, 12)
52        strCerFechaHoraValidaHastaLetra = Mid(strCerFechaHoraValidaHasta, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaHasta, 4, 2), False) & Mid(strCerFechaHoraValidaHasta, 6)
          
          'Validaciones simples del archivo .CER
          'Si se utiliza un certificado de pruebas, se omiten las validaciones
53        If strCerRFC <> "ACO560518KW7" Then
54           If strCerRFC = "" Then 'Si el RFC del certificado está vació, significa que no se ha instalado el complemento de sellado (librerías de FirmaSAT en system32)
55              MsgBox SIHOMsg(1) & "." & vbCrLf & vbCrLf & "No se detectó el complemento de sellado de comprobantes. ", vbCritical, "Mensaje"
56              strError = "No se detectó el complemento de sellado de comprobantes."
57              blnMostrarMsjNotificaError = False
                intlineaGoto = 58
58              GoTo NotificaError
59           ElseIf strCerRFC <> Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) Then 'Compara el RFC del certificado vs el RFC de la empresa contable
60                  MsgBox "El certificado configurado en el sistema no corresponde a la empresa contable emisora: " & vbNewLine & vbNewLine & _
                                                        "- RFC de la empresa:" & vbTab & Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) & vbNewLine & _
                                                        "- RFC del certificado:" & vbTab & strCerRFC, vbCritical + vbOKOnly, "Mensaje"
61                  strError = "El certificado configurado en el sistema no corresponde a la empresa contable emisora"
62                  blnMostrarMsjNotificaError = False
                    intlineaGoto = 63
63                  GoTo NotificaError
64           ElseIf CDate(strCerFechaValidaDesde) > CDate(strFechaServer) Then 'La fecha de inicio validez del certificado aún no entra en vigor
65                  MsgBox "El certificado configurado en el sistema aún no entra en su período de validez: " & vbNewLine & vbNewLine & _
                                                        "- Válido a partir de:" & vbTab & strCerFechaHoraValidaDesdeLetra & vbNewLine & _
                                                        "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
66                  strError = "El certificado configurado en el sistema aún no entra en período de validez"
67                  blnMostrarMsjNotificaError = False
                    intlineaGoto = 68
68                  GoTo NotificaError
69           ElseIf CDate(strCerFechaValidaHasta) < CDate(strFechaServer) Then 'La fecha de expiración del certificado ha excedido su validez
70                  MsgBox "El certificado configurado en el sistema excede su período de validez: " & vbNewLine & vbNewLine & _
                                                        "- Válido hasta el:" & vbTab & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                                        "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
71                  strError = "El certificado configurado en el sistema excede su período de validez"
72                  blnMostrarMsjNotificaError = False
                    intlineaGoto = 73
73                  GoTo NotificaError
74           ElseIf CDate(strCerFechaValidaDesde) = CDate(strFechaServer) Then 'La fecha de inicio de validez del certificado es igual a la fecha actual
75                    If Format(CDate(strCerHoraValidaDesde), "HH:MM:SS") > Format(CDate(strHoraServer), "HH:MM:SS") Then 'Se compara la hora de inicio de validez con la hora actual
76                       MsgBox "El certificado configurado en el sistema aún no entra en su período de validez: " & vbNewLine & vbNewLine & _
                                                            "- Válido a partir de:" & vbTab & strCerFechaHoraValidaDesdeLetra & vbNewLine & _
                                                            "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
77                       strError = "El certificado configurado en el sistema aún no entra en período de validez"
78                       blnMostrarMsjNotificaError = False
79                       intlineaGoto = 80
80                       GoTo NotificaError
                    End If
81           ElseIf CDate(strCerFechaValidaHasta) = CDate(strFechaServer) Then 'La fecha de expiración del certificado es igual a la fecha actual
82                    If Format(CDate(strCerHoraValidaHasta), "HH:MM:SS") > Format(CDate(strHoraServer), "HH:MM:SS") Then 'Certificado válido por pocas horas
83                       lngTiempoRestanteHrs = DateDiff("h", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
84                       lngTiempoRestanteMins = DateDiff("n", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
85                       strTiempoRestanteTotal = CStr(lngTiempoRestanteHrs) & " horas " & CStr(Abs(lngTiempoRestanteMins - (60 * lngTiempoRestanteHrs))) & " minutos!"
86                       MsgBox "¡El certificado expirará en " & strTiempoRestanteTotal & ", por favor solicite uno nuevo al SAT.", vbExclamation, "Mensaje"
                      Else 'Certificado expirado
87                       MsgBox "El certificado configurado en el sistema excede su período de validez: " & vbNewLine & vbNewLine & _
                                                            "- Válido hasta el:" & vbTab & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                                            "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
88                       strError = "El certificado configurado en el sistema excede su período de validez"
89                       blnMostrarMsjNotificaError = False
                         intlineaGoto = 90
90                       GoTo NotificaError
                    End If
                End If
            Else
91              If fblnAutoVerificacion Then
                   'Este mensaje es para que los clientes se percaten de que estén utilizando un certificado de pruebas
                   '(Solamente se mostrará, si se tiene habilitado el bit de autoverificación y si el esquema en el que se está probando, no es un esquema SiC (RFC = CSI040928HX4))
92                   If Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) <> "CSI040928HX4" Then
93                      MsgBox "Se está utilizando un certificado de pruebas: " & vbNewLine & vbNewLine & _
                                        "- RFC del certificado:  " & strCerRFC & vbNewLine & _
                                        "- Válido del  " & strCerFechaHoraValidaDesdeLetra & " al " & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                        "- Número de certificado:  " & strCerNumCertificado & vbNewLine & _
                                        "- Empresa certificadora:  " & strCerEmpresaEmisora, vbInformation + vbOKOnly, "Mensaje"
                    End If
                End If
            End If
      Else
94        strError = "No se ha configurado un archivo de certificado .CER para emitir comprobantes fiscales digitales"
          intlineaGoto = 95
95        GoTo NotificaError
      End If

      '|  Descarga archivo .KEY en directorio local del cliente
96    If Not IsNull(RsComprobante!BLBLLAVE) Then
97       With stmComprobante
98            .Type = adTypeBinary
100           .Open
101           .Write RsComprobante!BLBLLAVE
102            .SaveToFile strArchivoLlave, adSaveCreateOverWrite
103            .Close
         End With
      Else
104        strError = "No existe configurada un archivo llave .KEY para emitir facturas comprobantes fiscales digitales"
           intlineaGoto = 105
105        GoTo NotificaError
      End If
    
      '| Almacena contraseña
106   If Not IsNull(RsComprobante!vchContrasena) Then
107      strContrasena = fstrEncrypt2(fstrConvierteChr(RsComprobante!vchContrasena), RsComprobante!vchRFC)
      Else
108      strError = "No existe configurada una contraseña para emitir facturas comprobantes fiscales digitales"
         intlineaGoto = 109
109      GoTo NotificaError
      End If

       'En caso de timbrar con Prodigia
       vgStrCertBase64 = satGetCertAsString(strArchivoCertificado)
       vgStrKeyBase64 = satGetKeyAsPEMString(strArchivoLlave, strContrasena)
       vgStrKeyBase64 = Trim(Mid(vgStrKeyBase64, 39, (Len(vgStrKeyBase64) - 75)))
       vgStrKeyToKey = strContrasena
    
228    If fsoComprobante.FileExists(strArchivoLlave) Then fsoComprobante.DeleteFile strArchivoLlave
229    If fsoComprobante.FileExists(strArchivoCertificado) Then fsoComprobante.DeleteFile strArchivoCertificado
    
    

    'Se busca información del comprobante fiscal digital para revisar si es CFDi
    strSentencia = "SELECT intIdComprobante, vchUUID, vchRFCEmisor, vchRFCReceptor, numTotalComprobante FROM GnComprobanteFiscalDigital " & _
                   "WHERE intComprobante = " & lngComprobante & " AND chrTipoComprobante = '" & strTipo & "'"
    Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
    
    'Si no hay información, significa que se está utilizando formato FÍSICO, se permitirá cancelar el comprobante
    If RsComprobante.RecordCount = 0 Then
        fblnCancelaCFDi = True
        Exit Function
    End If
    
    blnCFDI = IIf(IsNull(RsComprobante!VCHUUID), False, True)
    
    If blnCFDI Then 'Si es CFDi buscará si viene de la interfaz con otros PACs para no intentar cancelar via la configuración del PAC
        lngUUIDPacInterfaz = 1
        frsEjecuta_SP "'" & Trim(RsComprobante!VCHUUID) & "'", "FN_PVSELUUIDPACINTERFAZ", True, lngUUIDPacInterfaz
        If lngUUIDPacInterfaz <> 0 Then
            blnCFDI = False
        End If
    End If
    
    If blnCFDI Then
        '----- Si existe un código de timbrado, se procede a hacer la cancelación por medio del PAC -----'
        lngConsecutivo = RsComprobante!INTIDCOMPROBANTE
        strUUId = RsComprobante!VCHUUID
        strRFC = RsComprobante!VCHRFCEMISOR
        strRFCReceptor = RsComprobante!VCHRFCRECEPTOR
        strTotalComprobante = IIf(IsNull(RsComprobante!numTotalComprobante), 0, RsComprobante!numTotalComprobante)
        
        'Se elimina el contenido de la carpeta temporal
        strDestino = Environ$("temp") & "\dA-Ms19"
        pCreaDirectorio strDestino
        On Error Resume Next

        'Checa que el directorio se haya creado, para proceder a eliminar el archivo (evita el error 53)
        If Dir$(strDestino & "\") <> "" Then
            Kill strDestino & "\*.*"
            If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
                Err.Clear
            Else
                Err.Raise Err.Number
            End If
        End If

        strXMLCancelacion = strDestino & "\" & strTipo & "_" & lngComprobante & "AcuseCancelacion.xml"
    
        '----------------------------------------------'
        '|  Inicia el proceso de cancelación de CFDi  |'
        '----------------------------------------------'
        'Se obtiene el PAC para el proceso de cancelación (Buzón Fiscal: INTIDPAC = 1) (PAX: INTIDPAC = 2)
        Set rsPAC = frsEjecuta_SP(CStr(vgintClaveEmpresaContable), "SP_GNSELCONFIGPAC")
        If rsPAC.RecordCount > 0 Then
            intPAC = Val(rsPAC!PAC)
            Select Case intPAC
                Case 1 '>> Buzón Fiscal <<
                    If fblLicenciaCancelacionBuzonFiscal Then ' se verifica la licencia para poder cancelar*******************
                       fblnCancelaCFDi = fblnCancelarCFDiBuzon(strUUId, strRFC, strRFCReceptor, strXMLCancelacion)
                       If fblnCancelaCFDi Then
                            If fsoArchivoXML.FileExists(strXMLCancelacion) Then
                                strXMLCancelado = fstrConvierteArchivoUTF8(strXMLCancelacion)
                                '- Guarda el XML del acuse de cancelación en GNACUSECANCELACIONCFDI -'
                                strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTCONSECUTIVO = -1"
                                Set rsAcuse = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
                                With rsAcuse
                                    .AddNew
                                    !INTIDCOMPROBANTE = lngConsecutivo
                                    !CLBXMLACUSE = strXMLCancelado
                                    .Update
                                End With
                                rsAcuse.Close
        
                                fsoArchivoXML.DeleteFile strXMLCancelacion 'Borra el archivo de Request de la carpeta temporal
                            End If
                        End If
                    Else 'no se cuenta con la licencia ***********************************************************************
                        fblnCancelaCFDi = True
                    End If '**************************************************************************************************
                    
                Case 2 '>> PAX <<
                    '''A ESTA VALIDACION NUNCA DEBE DE ENTRAR EL PROCESO DE LOS CLIENTES, SOLAMENTE ES PARA PRUEBAS YA QUE NO HAY FORMA DE HACER UNA PRUEBA
                    ''' PARA LA CANCELACIóN DE UN CFDI ANTE LA SAT, EN EL CLIENTE NUNCA DEBE DE EXISTIR EL PARAMETRO 'BITPRUEBACANCELACIONCFDI'
                    Set ObjRS = frsRegresaRs("Select vchvalor from siparametro where vchnombre = 'BITPRUEBACANCELACIONCFDI'", adLockOptimistic)
                    If ObjRS.RecordCount > 0 Then
                        If ObjRS!VCHVALOR = "1" Then
                           strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTCONSECUTIVO = -1"
                           ' se inserta un XML de cancelación que no es válido, es sólo para pruebas                                                                                                                                                                                                                                                                                                                a000aaaa-00a0-000a-aaa0-a000a0aaaaa0
                           strXMLCancelado = "<Cancelacion xmlns:xsd=" & Chr(34) & "http://www.w3.org/2001/XMLSchema" & Chr(34) & " xmlns:xsi=" & Chr(34) & "http://www.w3.org/2001/XMLSchema-instance" & Chr(34) & " RfcEmisor=" & Chr(34) & "AAA01010101AAA" & Chr(34) & " Fecha=" & Chr(34) & "2099-01-01T23:59:59" & Chr(34) & " xmlns=" & Chr(34) & "http://cancelacfd.sat.gob.mx" & Chr(34) & "><Folios><UUID>a000aaaa-00a0-000a-aaa0-a000a0aaaaa0 </UUID><UUIDEstatus>201 </UUIDEstatus><UUIDdescripcion>201 - UUID Cancelado PRUEBAS. </UUIDdescripcion><UUIDfecha>01/01/2099 11:59:59 PM </UUIDfecha></Folios></Cancelacion>"
                           Set rsAcuse = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
                           With rsAcuse
                               .AddNew
                               !INTIDCOMPROBANTE = lngConsecutivo
                               !CLBXMLACUSE = strXMLCancelado
                               .Update
                           End With
                           rsAcuse.Close
                           fblnCancelaCFDi = True
                           Exit Function
                        End If
                    End If
                    '&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
                    fblnCancelaCFDi = fblnCancelarCFDiPAX(strUUId, strRFC, strRFCReceptor, strTotalComprobante, strXMLCancelacion)
                    If fblnCancelaCFDi Then
                        If fsoArchivoXML.FileExists(strXMLCancelacion) Then
                            strXMLCancelado = fstrConvierteArchivoUTF8(strXMLCancelacion)
                            '- Guarda el XML del acuse de cancelación en GNACUSECANCELACIONCFDI -'
                            strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTCONSECUTIVO = -1"
                            Set rsAcuse = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
                            With rsAcuse
                                .AddNew
                                !INTIDCOMPROBANTE = lngConsecutivo
                                !CLBXMLACUSE = strXMLCancelado
                                .Update
                            End With
                            rsAcuse.Close
    
                            fsoArchivoXML.DeleteFile strXMLCancelacion 'Borra el archivo de Request de la carpeta temporal
                        End If
                    End If
                Case 3 '>> Prodigia <<
                    '''A ESTA VALIDACION NUNCA DEBE DE ENTRAR EL PROCESO DE LOS CLIENTES, SOLAMENTE ES PARA PRUEBAS YA QUE NO HAY FORMA DE HACER UNA PRUEBA
                    ''' PARA LA CANCELACIóN DE UN CFDI ANTE LA SAT, EN EL CLIENTE NUNCA DEBE DE EXISTIR EL PARAMETRO 'BITPRUEBACANCELACIONCFDI'
                    Set ObjRS = frsRegresaRs("Select vchvalor from siparametro where vchnombre = 'BITPRUEBACANCELACIONCFDI'", adLockOptimistic)
                    If ObjRS.RecordCount > 0 Then
                        If ObjRS!VCHVALOR = "1" Then
                           strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTCONSECUTIVO = -1"
                           ' se inserta un XML de cancelación que no es válido, es sólo para pruebas                                                                                                                                                                                                                                                                                                                a000aaaa-00a0-000a-aaa0-a000a0aaaaa0
                           strXMLCancelado = "<Cancelacion xmlns:xsd=" & Chr(34) & "http://www.w3.org/2001/XMLSchema" & Chr(34) & " xmlns:xsi=" & Chr(34) & "http://www.w3.org/2001/XMLSchema-instance" & Chr(34) & " RfcEmisor=" & Chr(34) & "AAA01010101AAA" & Chr(34) & " Fecha=" & Chr(34) & "2099-01-01T23:59:59" & Chr(34) & " xmlns=" & Chr(34) & "http://cancelacfd.sat.gob.mx" & Chr(34) & "><Folios><UUID>a000aaaa-00a0-000a-aaa0-a000a0aaaaa0 </UUID><UUIDEstatus>201 </UUIDEstatus><UUIDdescripcion>201 - UUID Cancelado PRUEBAS. </UUIDdescripcion><UUIDfecha>01/01/2099 11:59:59 PM </UUIDfecha></Folios></Cancelacion>"
                           Set rsAcuse = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
                           With rsAcuse
                               .AddNew
                               !INTIDCOMPROBANTE = lngConsecutivo
                               !CLBXMLACUSE = strXMLCancelado
                               .Update
                           End With
                           rsAcuse.Close
                           fblnCancelaCFDi = True
                           Exit Function
                        End If
                    End If
                    '&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
                    fblnCancelaCFDi = fblnCancelarCFDiProdigia(strUUId, strRFC, strRFCReceptor, strTotalComprobante, strXMLCancelacion)
                    If fblnCancelaCFDi Then
                        If fsoArchivoXML.FileExists(strXMLCancelacion) Then
                            strXMLCancelado = fstrConvierteArchivoUTF8(strXMLCancelacion)
                            '- Guarda el XML del acuse de cancelación en GNACUSECANCELACIONCFDI -'
                            strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTCONSECUTIVO = -1"
                            Set rsAcuse = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
                            With rsAcuse
                                .AddNew
                                !INTIDCOMPROBANTE = lngConsecutivo
                                !CLBXMLACUSE = strXMLCancelado
                                .Update
                            End With
                            rsAcuse.Close
    
                            fsoArchivoXML.DeleteFile strXMLCancelacion 'Borra el archivo de Request de la carpeta temporal
                        End If
                    End If
            End Select
        Else
            '¡No se ha configurado un PAC activo para realizar la cancelación del comprobante!
            MsgBox SIHOMsg(1224), vbCritical, "Mensaje"
            blnMostrarMsjNotificaError = False
            GoTo NotificaError
        End If
    Else
        'El comprobante a cancelar es CFD, se procede con  la cancelación normal
        fblnCancelaCFDi = True
    End If
    
Exit Function
NotificaError:
    'Elimina archivos de trabajo
    If fsoArchivoXML.FileExists(strXMLCancelacion) Then fsoArchivoXML.DeleteFile strXMLCancelacion
    
    'Muestra el mensaje de error
    Call pErrorGeneraCFD(1225, "Error en el proceso de cancelación del comprobante.", blnMostrarMsjNotificaError)
    
    'Se regresa el error de la función
    fblnCancelaCFDi = False
End Function

''''''Public Sub pCancelaCFDiMasivo(strComprobantes() As String, aComprobantesCancelados() As String, lngCantidadComprobantes As Long, Optional strforma As String, Optional vllngPgraba As Long)
''''''    Dim fsoArchivoXML As New FileSystemObject
''''''    Dim RsComprobante As New ADODB.Recordset
''''''    Dim rsAcuse As New ADODB.Recordset
''''''    Dim strSentencia As String
''''''    Dim strDestino As String
''''''    Dim strXMLCancelado As String
''''''    Dim lngConsecutivo As Long
''''''    Dim strUUId As String
''''''    Dim strRFC As String
''''''    Dim strRFCReceptor As String 'Agregado para Buzón Fiscal
''''''    Dim strXMLCancelacion As String
''''''    Dim blnCFDI As Boolean
''''''    Dim rsPAC As New ADODB.Recordset
''''''    Dim intPAC As Integer
''''''    Dim blnMostrarMsjNotificaError As Boolean 'Esta variable indica si se mostrará un mensaje de error, en caso de que se presente alguno
''''''    Dim lngContador As Long
''''''    Dim blnNoError As Boolean
''''''    Dim strfolioDoc As String
''''''    Dim strFacNoCanceladas As String
''''''    Dim intCanceladas As Integer
''''''    Dim intNoCanceladas As Integer
''''''    Dim intResultado As Integer '0 = NO fue cancelada, 1 = fue cancelada , 2 = detiene la operación
''''''    Dim strTotalComprobante As String
''''''
''''''    blnNoError = False
''''''    strFacNoCanceladas = ""
''''''    intCanceladas = 0
''''''    intNoCanceladas = 0
''''''    'Se obtiene el PAC para el proceso de cancelación (Buzón Fiscal: INTIDPAC = 1) (PAX: INTIDPAC = 2)
''''''    Set rsPAC = frsEjecuta_SP(CStr(vgintClaveEmpresaContable), "SP_GNSELCONFIGPAC")
''''''    If rsPAC.RecordCount > 0 Then
''''''       intPAC = Val(rsPAC!PAC)
''''''        Select Case intPAC
''''''            Case 1 '>> Buzón Fiscal <<
''''''            If fblLicenciaCancelacionBuzonFiscal Then ' verificar si se tiene la licencia para cancelar con Buzon fiscal
''''''                '- Agregado (CR) -'
''''''                For lngContador = 1 To lngCantidadComprobantes '--------------------------------------------------------------------------------------------
''''''On Error GoTo NotificaErrorCicloFORBuzon
''''''
''''''                     blnMostrarMsjNotificaError = True
''''''
''''''                     'Se busca información del comprobante fiscal digital para revisar si es CFDi
''''''                    If strComprobantes(3, lngContador) = 1 Then
''''''                       strSentencia = "SELECT intIdComprobante, vchUUID, vchRFCEmisor, vchRFCReceptor, vchSerieComprobante, vchFolioComprobante FROM GnComprobanteFiscalDigital " & _
''''''                       "WHERE intComprobante = " & strComprobantes(1, lngContador) & " AND chrTipoComprobante = '" & strComprobantes(2, lngContador) & "'"
''''''                    Else '2
''''''                       strSentencia = "select INTIDCOMPROBANTE,VCHUUID,VCHRFCEMISOR,VCHRFCRECEPTOR,CHRFOLIOCOMPROBANTE From PVCANCELARCOMPROBANTES " & _
''''''                       "Where INTCOMPROBANTE =" & strComprobantes(1, lngContador) & " And VCHTIPOCOMPROBANTE = '" & strComprobantes(2, lngContador) & "'"
''''''                    End If
''''''
''''''                     Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
''''''                     'Si no hay información, significa que se está utilizando formato FÍSICO, se permitirá cancelar el comprobante
''''''                     If RsComprobante.RecordCount > 0 Then
''''''                        blnCFDI = IIf(IsNull(RsComprobante!VCHUUID), False, True)
''''''                        If blnCFDI Then
''''''                            '----- Si existe un código de timbrado, se procede a hacer la cancelación por medio del PAC -----'
''''''                            lngConsecutivo = RsComprobante!INTIDCOMPROBANTE
''''''                            strUUId = RsComprobante!VCHUUID
''''''                            strRFC = RsComprobante!VCHRFCEMISOR
''''''                            strRFCReceptor = RsComprobante!VCHRFCRECEPTOR
''''''
''''''                            If strComprobantes(3, lngContador) = 1 Then
''''''                               strfolioDoc = RsComprobante!VCHSERIECOMPROBANTE & RsComprobante!VCHFOLIOCOMPROBANTE
''''''                            Else
''''''                               strfolioDoc = RsComprobante!CHRFOLIOCOMPROBANTE
''''''                            End If
''''''
''''''                            'Se elimina el contenido de la carpeta temporal
''''''                            strDestino = Environ$("temp") & "\dA-Ms19"
''''''                            pCreaDirectorio strDestino
''''''                            On Error Resume Next
''''''
''''''                            'Checa que el directorio se haya creado, para proceder a eliminar el archivo (evita el error 53)
''''''                            If Dir$(strDestino & "\") <> "" Then
''''''                                Kill strDestino & "\*.*"
''''''                                If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
''''''                                    Err.Clear
''''''                                Else
''''''                                    Err.Raise Err.Number
''''''                                End If
''''''                            End If
''''''
''''''                            strXMLCancelacion = strDestino & "\" & strComprobantes(2, lngContador) & "_" & strComprobantes(1, lngContador) & "AcuseCancelacion.xml"
''''''                            intResultado = fintCancelarCFDiBuzon(strUUId, strRFC, strRFCReceptor, strXMLCancelacion, strfolioDoc)
''''''                            If intResultado = 0 Then ' no se canceló pero continua el proceso
''''''                                If strFacNoCanceladas = "" Then
''''''                                    strFacNoCanceladas = strfolioDoc & vbNewLine
''''''                                Else
''''''                                    strFacNoCanceladas = strFacNoCanceladas & strfolioDoc & vbNewLine
''''''                                End If
''''''                                intNoCanceladas = intNoCanceladas + 1
''''''
''''''                            ElseIf intResultado = 1 Then ' Se canceló correctamente
''''''                                If strComprobantes(3, lngContador) = 1 Then
''''''                                    If fsoArchivoXML.FileExists(strXMLCancelacion) Then
''''''                                        strXMLCancelado = fstrConvierteArchivoUTF8(strXMLCancelacion)
''''''                                        '- Guarda el XML del acuse de cancelación en GNACUSECANCELACIONCFDI -'
''''''                                        strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTCONSECUTIVO = -1"
''''''                                        Set rsAcuse = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
''''''                                        With rsAcuse
''''''                                            .AddNew
''''''                                            !INTIDCOMPROBANTE = lngConsecutivo
''''''                                            !CLBXMLACUSE = strXMLCancelado
''''''                                            .Update
''''''                                        End With
''''''                                        rsAcuse.Close
''''''                                        fsoArchivoXML.DeleteFile strXMLCancelacion 'Borra el archivo de Request de la carpeta temporal
''''''                                        Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CANCELACIÓN DE CFDI", strfolioDoc)
''''''                                    Else 'YA ESTABA CANCELADO EL CFDi
''''''                                        Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CFDI YA CANCELADO", strfolioDoc)
''''''                                    End If
''''''                                    '----------------------------------------------------------------------------
''''''                                    'SE SACAN ESTAS LINEAS PARA QUE SE ACTUALICE LA TABLA PVPENDIENTESCANCELARSAT
''''''                                    '----------------------------------------------------------------------------
''''''                                     intCanceladas = intCanceladas + 1
''''''                                     frsEjecuta_SP strUUId & "|0|PA", "Sp_PvPendientesCancelarSAT"
''''''                                     frsEjecuta_SP strUUId & "|0|CR", "Sp_PvPendientesCancelarSAT"
''''''                                    '---------------------------------------------------------------------------
''''''                                 Else
''''''                                     If fsoArchivoXML.FileExists(strXMLCancelacion) Then
''''''                                        strXMLCancelado = fstrConvierteArchivoUTF8(strXMLCancelacion)
''''''
''''''                                        pEjecutaSentencia " UPDATE PVCANCELARCOMPROBANTES SET CBLXMLACUSECANCELACION = '" & strXMLCancelado & "'" & _
''''''                                                       "Where INTCOMPROBANTE =" & strComprobantes(1, lngContador) & " And VCHTIPOCOMPROBANTE = '" & strComprobantes(2, lngContador) & "'"
''''''
''''''                                        fsoArchivoXML.DeleteFile strXMLCancelacion 'Borra el archivo de Request de la carpeta temporal
''''''                                        Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CANCELACIÓN DE CFDI NO ESTABA EN SIHO", strComprobantes(2, lngContador) & ": " & Trim(strfolioDoc) & " Id: " & strComprobantes(1, lngContador))
''''''                                     Else 'YA ESTABA CANCELADO EL CFDi
''''''                                        Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CFDI YA CANCELADO NO ESTABA EN SIHO", strComprobantes(2, lngContador) & ": " & Trim(strfolioDoc) & " Id: " & strComprobantes(1, lngContador))
''''''                                     End If
''''''
''''''                                     'QUITAMOS EL BIT DE LA TABLA PVCANCELARCOMPROBANTES YA ESTA CANCELADO EL CFDI
''''''                                     pEjecutaSentencia " UPDATE PVCANCELARCOMPROBANTES SET BITPENDIENTECANCELAR = 0 " & _
''''''                                                       "Where INTCOMPROBANTE =" & strComprobantes(1, lngContador) & " And VCHTIPOCOMPROBANTE = '" & strComprobantes(2, lngContador) & "'"
''''''                                 End If
''''''                            ElseIf intResultado = 3 Then ' para hacer la pruebas de cancelación solo entra a esta opción cuando en la base existe el parametro
''''''                                intCanceladas = intCanceladas + 1
''''''
''''''                                 ' se inserta un XML de cancelación que no es válido, es sólo para pruebas
''''''                                 strXMLCancelado = "<Cancelacion xmlns:xsd=" & Chr(34) & "http://www.w3.org/2001/XMLSchema" & Chr(34) & " xmlns:xsi=" & Chr(34) & "http://www.w3.org/2001/XMLSchema-instance" & Chr(34) & " RfcEmisor=" & Chr(34) & "AAA01010101AAA" & Chr(34) & " Fecha=" & Chr(34) & "2099-01-01T23:59:59" & Chr(34) & " xmlns=" & Chr(34) & "http://cancelacfd.sat.gob.mx" & Chr(34) & "><Folios><UUID>e428bffe-19a5-400a-adb5-a216f4fcced6 </UUID><UUIDEstatus>201 </UUIDEstatus><UUIDdescripcion>201 - UUID Cancelado PRUEBAS. </UUIDdescripcion><UUIDfecha>01/01/2099 11:59:59 PM </UUIDfecha></Folios></Cancelacion>"
''''''
''''''                                If strComprobantes(3, lngContador) = 1 Then
''''''                                   strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTCONSECUTIVO = -1"
''''''
''''''                                   Set rsAcuse = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
''''''                                   With rsAcuse
''''''                                        .AddNew
''''''                                        !INTIDCOMPROBANTE = lngConsecutivo
''''''                                        !CLBXMLACUSE = strXMLCancelado
''''''                                        .Update
''''''                                   End With
''''''                                   rsAcuse.Close
''''''
''''''                                   frsEjecuta_SP strUUId & "|0|PC", "Sp_PvPendientesCancelarSAT"
''''''                                   MsgBox "Se realizó una cancelación de prueba (NO válida ante el SAT) del CFDi con folio: " & strfolioDoc, vbInformation, "Mensaje"
''''''                                   Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CANCELACIÓN DE CFDI PRUEBA", Trim(strfolioDoc))
''''''                                Else
''''''                                   MsgBox "Se realizó una cancelación de prueba (NO válida ante el SAT) del CFDi con folio: " & strfolioDoc, vbInformation, "Mensaje"
''''''                                   Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CANCELACIÓN DE CFDI PRUEBA NO ESTABA EN SIHO", strComprobantes(2, lngContador) & ": " & Trim(strfolioDoc) & " Id: " & strComprobantes(1, lngContador))
''''''
''''''                                   'QUITAMOS EL BIT DE LA TABLA PVCANCELARCOMPROBANTES YA ESTA CANCELADO EL CFDI
''''''                                   pEjecutaSentencia " UPDATE PVCANCELARCOMPROBANTES SET BITPENDIENTECANCELAR = 0, CBLXMLACUSECANCELACION = '" & strXMLCancelado & "'" & _
''''''                                                     "Where INTCOMPROBANTE =" & strComprobantes(1, lngContador) & " And VCHTIPOCOMPROBANTE = '" & strComprobantes(2, lngContador) & "'"
''''''                                End If 'strComprobantes(3, lngContador) = 1
''''''                            Else 'No se canceló, se detiene la operación intResultado = 2
''''''                                Exit Sub      'sale de la función ----------------------------------------------------------------------
''''''                            End If 'intResultado
''''''                        End If 'blnCFDi
''''''                    End If 'rsComprobante.RecordCount > 0
''''''
''''''                    If blnNoError Then '----------------------------------------------------------------------------------------------
''''''NotificaErrorCicloFORBuzon:
''''''                        'Elimina archivos de trabajo
''''''                        If fsoArchivoXML.FileExists(strXMLCancelacion) Then fsoArchivoXML.DeleteFile strXMLCancelacion
''''''
''''''                        'Muestra el mensaje de error
''''''                        Call pErrorGeneraCFD(1225, "Error en el proceso de cancelación del comprobante. " & strfolioDoc, blnMostrarMsjNotificaError)
''''''                    End If '----------------------------------------------------------------------------------------------------------
''''''                Next lngContador
''''''
''''''                If intCanceladas > 0 Then '--------------------------------------------------------------------------------------------
''''''                    If intNoCanceladas = 0 Then 'todas canceladas
''''''                        MsgBox "La operación ha terminado satisfactoriamente", vbInformation, "Mensaje"
''''''                    Else 'quedaron sin cancelar
''''''                        MsgBox "La cancelación ha terminado, no se pudieron cancelar los siguientes documentos:" & strFacNoCanceladas, vbInformation, "Mensaje"
''''''                    End If
''''''                Else 'no se cancelo ni una sola
''''''                    If intNoCanceladas > 0 Then
''''''                       MsgBox "No se ha podido realizar la cancelación de los documentos", vbInformation, "Mensaje"
''''''                    End If
''''''                End If '---------------------------------------------------------------------------------------------------------------
''''''
''''''        Else 'No se tiene licencia para cancelar con buzon fiscal
''''''           For lngContador = 1 To lngCantidadComprobantes
''''''               If strComprobantes(3, lngContador) = 1 Then
''''''                  'Se busca información del comprobante fiscal digital para revisar si es CFDi
''''''                  strSentencia = "SELECT vchUUID FROM GnComprobanteFiscalDigital " & _
''''''                                    "WHERE intComprobante = " & strComprobantes(1, lngContador) & _
''''''                                     " AND chrTipoComprobante = '" & strComprobantes(2, lngContador) & "'"
''''''
''''''                  Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
''''''                  If RsComprobante.RecordCount > 0 Then
''''''                     strUUId = RsComprobante!VCHUUID
''''''                     frsEjecuta_SP strUUId & "|0|PC", "Sp_PvPendientesCancelarSAT"
''''''                  End If
''''''               Else
''''''                  'QUITAMOS EL BIT DE LA TABLA PVCANCELARCOMPROBANTES YA ESTA CANCELADO EL CFDI
''''''                  pEjecutaSentencia " UPDATE PVCANCELARCOMPROBANTES SET BITPENDIENTECANCELAR = 0" & _
''''''                                    "Where INTCOMPROBANTE =" & strComprobantes(1, lngContador) & " And VCHTIPOCOMPROBANTE = '" & strComprobantes(2, lngContador) & "'"
''''''               End If
''''''           Next
''''''               MsgBox "La operación ha terminado satisfactoriamente", vbInformation, "Mensaje"
''''''        End If
''''''        Case 2 '>> PAX <<
''''''                   Erase aComprobantesCancelados
''''''
''''''                   For lngContador = 1 To lngCantidadComprobantes '--------------------------------------------------------------------------------------------
''''''On Error GoTo NotificaErrorCicloFOR
''''''
''''''                        blnMostrarMsjNotificaError = True
''''''
''''''                        'Se busca información del comprobante fiscal digital para revisar si es CFDi
''''''                        If strComprobantes(3, lngContador) = "PA" Or strComprobantes(3, lngContador) = "PC" Then
''''''                           strSentencia = "SELECT intIdComprobante, vchUUID, vchRFCEmisor, vchRFCReceptor, numTotalComprobante, vchSerieComprobante, vchFolioComprobante FROM GnComprobanteFiscalDigital " & _
''''''                           "WHERE intComprobante = " & strComprobantes(1, lngContador) & " AND chrTipoComprobante = '" & strComprobantes(2, lngContador) & "'"
''''''                        Else '2
''''''                           strSentencia = "select INTIDCOMPROBANTE,VCHUUID,VCHRFCEMISOR,CHRFOLIOCOMPROBANTE From PVCANCELARCOMPROBANTES " & _
''''''                           "Where INTCOMPROBANTE =" & strComprobantes(1, lngContador) & " And VCHTIPOCOMPROBANTE = '" & strComprobantes(1, lngContador) & "'"
''''''                        End If
''''''
''''''                        Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
''''''                        'Si no hay información, significa que se está utilizando formato FÍSICO, se permitirá cancelar el comprobante
''''''                        If RsComprobante.RecordCount > 0 Then
''''''                           blnCFDI = IIf(IsNull(RsComprobante!VCHUUID), False, True)
''''''
''''''                           If blnCFDI Then
''''''                              '----- Si existe un código de timbrado, se procede a hacer la cancelación por medio del PAC -----'
''''''                              lngConsecutivo = RsComprobante!INTIDCOMPROBANTE
''''''                              strUUId = RsComprobante!VCHUUID
''''''                              strRFC = RsComprobante!VCHRFCEMISOR
''''''                              strRFCReceptor = RsComprobante!VCHRFCRECEPTOR
''''''                              strTotalComprobante = IIf(IsNull(RsComprobante!numTotalComprobante), 0, RsComprobante!numTotalComprobante)
''''''
''''''                              If strComprobantes(3, lngContador) = "PA" Or strComprobantes(3, lngContador) = "PC" Then
''''''                                strfolioDoc = RsComprobante!VCHSERIECOMPROBANTE & RsComprobante!VCHFOLIOCOMPROBANTE
''''''                              Else
''''''                                strfolioDoc = RsComprobante!CHRFOLIOCOMPROBANTE
''''''                              End If
''''''
''''''                              'Se elimina el contenido de la carpeta temporal
''''''                              strDestino = Environ$("temp") & "\dA-Ms19"
''''''                              pCreaDirectorio strDestino
''''''                              On Error Resume Next
''''''
''''''                              'Checa que el directorio se haya creado, para proceder a eliminar el archivo (evita el error 53)
''''''                              If Dir$(strDestino & "\") <> "" Then
''''''                                 Kill strDestino & "\*.*"
''''''                                 If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
''''''                                    Err.Clear
''''''                                 Else
''''''                                    Err.Raise Err.Number
''''''                                 End If
''''''                              End If
''''''
''''''                              strXMLCancelacion = strDestino & "\" & strComprobantes(2, lngContador) & "_" & strComprobantes(1, lngContador) & "AcuseCancelacion.xml"
''''''                              intResultado = fIntCancelarCFDiPAX(strUUId, strRFC, strRFCReceptor, strTotalComprobante, strXMLCancelacion, strfolioDoc)
''''''
''''''                              Select Case intResultado
''''''                                    Case 0 ' no se canceló pero continua el proceso
''''''                                         If strFacNoCanceladas = "" Then
''''''                                            strFacNoCanceladas = strfolioDoc & vbNewLine
''''''                                         Else
''''''                                            strFacNoCanceladas = strFacNoCanceladas & strfolioDoc & vbNewLine
''''''                                         End If
''''''                                         intNoCanceladas = intNoCanceladas + 1
''''''                                    Case 1 ' Se canceló correctamente
''''''                                        If strComprobantes(3, lngContador) <> "NP" Then
''''''                                            If fsoArchivoXML.FileExists(strXMLCancelacion) Then
''''''                                               strXMLCancelado = fstrConvierteArchivoUTF8(strXMLCancelacion)
''''''                                               '- Guarda el XML del acuse de cancelación en GNACUSECANCELACIONCFDI -'
''''''                                               strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTCONSECUTIVO = -1"
''''''                                               Set rsAcuse = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
''''''                                               With rsAcuse
''''''                                                    .AddNew
''''''                                                    !INTIDCOMPROBANTE = lngConsecutivo
''''''                                                    !CLBXMLACUSE = strXMLCancelado
''''''                                                    .Update
''''''                                               End With
''''''                                               rsAcuse.Close
''''''                                               fsoArchivoXML.DeleteFile strXMLCancelacion 'Borra el archivo de Request de la carpeta temporal
''''''                                               Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CANCELACIÓN DE CFDI", strfolioDoc)
''''''                                            Else 'YA ESTABA CANCELADO EL CFDi
''''''                                               Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CFDI YA CANCELADO", strfolioDoc)
''''''                                            End If
''''''                                            '----------------------------------------------------------------------------
''''''                                            'SE SACAN ESTAS LINEAS PARA QUE SE ACTUALICE LA TABLA PVPENDIENTESCANCELARSAT
''''''                                            '----------------------------------------------------------------------------
''''''                                            intCanceladas = intCanceladas + 1
''''''                                            frsEjecuta_SP strUUId & "|0|PA", "Sp_PvPendientesCancelarSAT"
''''''                                            frsEjecuta_SP strUUId & "|0|CR", "Sp_PvPendientesCancelarSAT"
''''''
''''''
''''''                                         Else
''''''                                             If fsoArchivoXML.FileExists(strXMLCancelacion) Then
''''''                                                strXMLCancelado = fstrConvierteArchivoUTF8(strXMLCancelacion)
''''''
''''''                                                pEjecutaSentencia " UPDATE PVCANCELARCOMPROBANTES SET CBLXMLACUSECANCELACION = '" & strXMLCancelado & "'" & _
''''''                                                               "Where INTCOMPROBANTE =" & strComprobantes(1, lngContador) & " And VCHTIPOCOMPROBANTE = '" & strComprobantes(2, lngContador) & "'"
''''''
''''''                                                fsoArchivoXML.DeleteFile strXMLCancelacion 'Borra el archivo de Request de la carpeta temporal
''''''                                                Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CANCELACIÓN DE CFDI NO ESTABA EN SIHO", strComprobantes(2, lngContador) & ": " & Trim(strfolioDoc) & " Id: " & strComprobantes(1, lngContador))
''''''                                             Else 'YA ESTABA CANCELADO EL CFDi
''''''                                                Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CFDI YA CANCELADO NO ESTABA EN SIHO", strComprobantes(2, lngContador) & ": " & Trim(strfolioDoc) & " Id: " & strComprobantes(1, lngContador))
''''''                                             End If
''''''
''''''                                             'QUITAMOS EL BIT DE LA TABLA PVCANCELARCOMPROBANTES YA ESTA CANCELADO EL CFDI
''''''                                             pEjecutaSentencia " UPDATE PVCANCELARCOMPROBANTES SET BITPENDIENTECANCELAR = 0 " & _
''''''                                                               "Where INTCOMPROBANTE =" & strComprobantes(1, lngContador) & " And VCHTIPOCOMPROBANTE = '" & strComprobantes(2, lngContador) & "'"
''''''                                         End If
''''''                                         ReDim Preserve aComprobantesCancelados(2, lngContador)
''''''                                         aComprobantesCancelados(1, lngContador) = strComprobantes(4, lngContador)
''''''                                         aComprobantesCancelados(2, lngContador) = strComprobantes(3, lngContador)
''''''
''''''                                         '---------------------------------------------------------------------------
''''''                                    Case 3 ' para hacer la pruebas de cancelación solo entra a esta opción cuando en la base existe el parametro
''''''                                           intCanceladas = intCanceladas + 1
''''''
''''''                                          ' se inserta un XML de cancelación que no es válido, es sólo para pruebas
''''''                                            strXMLCancelado = "<Cancelacion xmlns:xsd=" & Chr(34) & "http://www.w3.org/2001/XMLSchema" & Chr(34) & " xmlns:xsi=" & Chr(34) & "http://www.w3.org/2001/XMLSchema-instance" & Chr(34) & " RfcEmisor=" & Chr(34) & "AAA01010101AAA" & Chr(34) & " Fecha=" & Chr(34) & "2099-01-01T23:59:59" & Chr(34) & " xmlns=" & Chr(34) & "http://cancelacfd.sat.gob.mx" & Chr(34) & "><Folios><UUID>e428bffe-19a5-400a-adb5-a216f4fcced6 </UUID><UUIDEstatus>201 </UUIDEstatus><UUIDdescripcion>201 - UUID Cancelado PRUEBAS. </UUIDdescripcion><UUIDfecha>01/01/2099 11:59:59 PM </UUIDfecha></Folios></Cancelacion>"
''''''
''''''                                           If strComprobantes(3, lngContador) = 1 Then
''''''                                              strSentencia = "SELECT * FROM GNACUSECANCELACIONCFDI WHERE INTCONSECUTIVO = -1"
''''''
''''''                                              Set rsAcuse = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
''''''                                              With rsAcuse
''''''                                                   .AddNew
''''''                                                   !INTIDCOMPROBANTE = lngConsecutivo
''''''                                                   !CLBXMLACUSE = strXMLCancelado
''''''                                                   .Update
''''''                                              End With
''''''                                              rsAcuse.Close
''''''
''''''                                              frsEjecuta_SP strUUId & "|0|PC", "Sp_PvPendientesCancelarSAT"
''''''                                              MsgBox "Se realizó una cancelación de prueba (NO válida ante el SAT) del CFDi con folio: " & strfolioDoc, vbInformation, "Mensaje"
''''''                                              Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CANCELACIÓN DE CFDI PRUEBA", Trim(strfolioDoc))
''''''                                           Else
''''''                                              MsgBox "Se realizó una cancelación de prueba (NO válida ante el SAT) del CFDi con folio: " & strfolioDoc, vbInformation, "Mensaje"
''''''                                              Call pGuardarLogTransaccion(strforma, EnmGrabar, vllngPgraba, "CANCELACIÓN DE CFDI PRUEBA NO ESTABA EN SIHO", strComprobantes(2, lngContador) & ": " & Trim(strfolioDoc) & " Id: " & strComprobantes(1, lngContador))
''''''
''''''                                              'QUITAMOS EL BIT DE LA TABLA PVCANCELARCOMPROBANTES YA ESTA CANCELADO EL CFDI
''''''                                              pEjecutaSentencia " UPDATE PVCANCELARCOMPROBANTES SET BITPENDIENTECANCELAR = 0, CBLXMLACUSECANCELACION = '" & strXMLCancelado & "'" & _
''''''                                                                "Where INTCOMPROBANTE =" & strComprobantes(1, lngContador) & " And VCHTIPOCOMPROBANTE = '" & strComprobantes(2, lngContador) & "'"
''''''
''''''                                           End If 'strComprobantes(3, lngContador) = 1
''''''                                    Case 2 ' no se canceló y se detiene la operación intResultado = 2
''''''                                         Exit Sub      'sale de la función ----------------------------------------------------------------------
''''''                              End Select 'intResultado
''''''                           End If 'blnCFDi
''''''                        End If 'rsComprobante.RecordCount > 0
''''''
''''''                        If blnNoError Then '----------------------------------------------------------------------------------------------
''''''NotificaErrorCicloFOR:
''''''                            'Elimina archivos de trabajo
''''''                            If fsoArchivoXML.FileExists(strXMLCancelacion) Then fsoArchivoXML.DeleteFile strXMLCancelacion
''''''
''''''                            'Muestra el mensaje de error
''''''                            Call pErrorGeneraCFD(1225, "Error en el proceso de cancelación del comprobante. " & strfolioDoc, blnMostrarMsjNotificaError)
''''''                        End If '----------------------------------------------------------------------------------------------------------
''''''                   Next lngContador
''''''                   If intCanceladas > 0 Then '--------------------------------------------------------------------------------------------
''''''                      If intNoCanceladas = 0 Then 'todas canceladas
''''''                         MsgBox "La operación ha terminado satisfactoriamente", vbInformation, "Mensaje"
''''''                      Else 'quedaron sin cancelar
''''''                         MsgBox "La cancelación ha terminado, no se pudieron cancelar los siguientes documentos:" & strFacNoCanceladas, vbInformation, "Mensaje"
''''''                      End If
''''''                   Else 'no se cancelo ni una sola
''''''                      If intNoCanceladas > 0 Then
''''''                         MsgBox "No se ha podido realizar la cancelación de los documentos", vbInformation, "Mensaje"
''''''                      End If
''''''                   End If '---------------------------------------------------------------------------------------------------------------
''''''              End Select
''''''    Else
''''''    '¡No se ha configurado un PAC activo para realizar la cancelación del comprobante!
''''''      MsgBox Replace(SIHOMsg(1224), "del comprobante", ""), vbCritical, "Mensaje"
''''''    End If
''''''End Sub



' Verifica la licencia para Cancelar con Buzon Fiscal
Public Function fblLicenciaCancelacionBuzonFiscal() As Boolean
    Dim rsTemp As ADODB.Recordset
    Dim strEncriptado As String
    Dim strSql As String
    
    fblLicenciaCancelacionBuzonFiscal = False
    strSql = ""
    
    'Determina si se adquirio licencia para poder realizar cancelaciones de CFDi con Buzon fiscal.
    strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC," & _
                   " TRIM(SIPARAMETRO.VCHVALOR) AS VALOR " & _
               "FROM SIPARAMETRO,CNEMPRESACONTABLE " & _
              "WHERE CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable & _
               " AND SIPARAMETRO.VCHNOMBRE = 'VCHLICENCIACANCELABUZONFISCAL' " & _
                "AND SIPARAMETRO.INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable
    
    Set rsTemp = frsRegresaRs(strSql)
    If Not rsTemp.EOF Then
        strEncriptado = fstrEncrypt(rsTemp!RFC, "SIHOCANCELABUZON")
        fblLicenciaCancelacionBuzonFiscal = IIf(rsTemp!Valor = strEncriptado, True, False)
    End If
End Function
' Verifica la licencia para IEPS
Public Function fblLicenciaIEPS() As Boolean
    Dim rsTemp As ADODB.Recordset
    Dim strEncriptado As String
    Dim strSql As String
    
    fblLicenciaIEPS = False

    
    strSql = ""
    'Determina si se adquirio licencia para IEPS
    strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC, TRIM(SIPARAMETRO.VCHVALOR) AS VALOR " & _
        "FROM SIPARAMETRO,CNEMPRESACONTABLE WHERE " & _
        "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable & " AND SIPARAMETRO.VCHNOMBRE = 'VCHLICENCIAIEPS' AND SIPARAMETRO.INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable



    Set rsTemp = frsRegresaRs(strSql)
    If Not rsTemp.EOF Then
        strEncriptado = fstrEncrypt(rsTemp!RFC, "SIHOIEPS")
        fblLicenciaIEPS = IIf(rsTemp!Valor = strEncriptado, True, False)
    End If
End Function

Public Function fblnLicenciaContaElectronica() As Boolean
    Dim strSql As String
    Dim strEncriptado As String
    Dim rsTemp As ADODB.Recordset
    
    fblnLicenciaContaElectronica = False
    
    strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC, TRIM(SIPARAMETRO.VCHVALOR) AS VALOR " & _
        "FROM SIPARAMETRO,CNEMPRESACONTABLE WHERE " & _
        "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable & " AND SIPARAMETRO.VCHNOMBRE = 'VCHCONTABILIDADELECTRONICA' AND SIPARAMETRO.INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable
    Set rsTemp = frsRegresaRs(strSql)
    If Not rsTemp.EOF Then
        strEncriptado = fstrEncrypt(rsTemp!RFC, "CONTASIHO041099ELECTRO")
        fblnLicenciaContaElectronica = IIf(rsTemp!Valor = strEncriptado, True, False)
    End If
End Function

Public Sub pCancelarFactura(vlstrFolioFactura As String, vllngPersonaGraba As Long, strNombreForma As String, Optional QuitarPendienteTimbre As Boolean = True, Optional Mostrarmensaje As Boolean = True, Optional blnRefacturacion As Boolean = False, Optional vlstrFolioFacturaAnterior As String)
    Dim lngContador As Long
    Dim blnInsertoMovimientos As Boolean
    Dim blnFacturaAutomatica As Boolean     'Indica si la factura se generó automáticamente en una venta al público
    Dim vllngMensaje As Long                'Mensaje que se recibe al momento de validar el corte
    Dim vlblnSePuedeCancelar As Boolean
    Dim rsDC As New ADODB.Recordset             'Es el detalle corte pero como consulta
    Dim strTipoDoc As String
    Dim strFecha As String
    Dim vlintErrorAlBorrarCargo As Long
    Dim blncontrolaseguradora As Boolean
    Dim rsTipoCambio As New ADODB.Recordset
    Dim intTipoCambio As Double
    Dim dblCantidad As Double
    Dim dblNotas As Double
    Dim blnbitpesos As Boolean
    Dim rsCantidadNota As New ADODB.Recordset
    Dim lngMovimientoCredito As Long
    Dim rsMovimientosT As New ADODB.Recordset
    Dim strFolioTicketAut As String         'Folio del ticket que originó la factura automática
    Dim rsTickets As ADODB.Recordset
    Dim rsCorteTiKets As New ADODB.Recordset    'RS para guardar los tikets que se estan reactivando despues de cancelar la factura
    Dim vldblTotalIVACredito As Double      'Solo para cálculos de totales de IVA a crédito en los Cargos (CA, OD y OC)
    Dim vllngNumCorteFactura As Long            'Es el número de corte en el que se registró la factura.
    Dim vllngNumeroCorte As Long                'Trae el numero de corte actual
    Dim rsChecaCredito As New ADODB.Recordset   'RS para saber si la factura fue a crédito y ya tiene pagos
    Dim vlstrSentencia As String                'Sirve pa TODOS los RS's
    Dim strParametros As String
    Dim lngMovPaciente As Long
    Dim lngCveEmpresaConvenio As Long
    Dim strTipoPaciente As String
    Dim strFacturaPacienteEmpresa As String
    Dim lngConsecutivoFactura As Long
    Dim strTipoFactura As String
    Dim blnValidarFacturaEmpresa As Boolean
    Dim rsTemp As New ADODB.Recordset
    Dim rsFactura As New ADODB.Recordset
    Dim strFechaFactura As String
    Dim rsCredito As New ADODB.Recordset
    Dim dblHonorariosFacturados As Double
    Dim vllngCorteUsado As Long
    Dim intBitCuentaPuenteBanco As Long
    Dim blnValidaCuentaPuenteBanco As Boolean
    Dim lngCuentaPuenteBanco As Long
    '--------------------------------------------------
    Dim vllngFoliosFaltantes As Long
    Dim alstrParametrosSalida() As String
    Dim strFolio As String
    Dim strSerie As String
    Dim strNumeroAprobacion As String
    Dim strAnoAprobacion As String
    Dim vlstrFolioDocumento As String
    Dim strSql As String
    Dim rs As New ADODB.Recordset
    Dim vlblnValidarDesglosarIVA As Boolean
    Dim vllngConceptoPago As Long
    Dim vldblSumaaBancos As Double
    Dim lngNumPagoSalida  As Long
    Dim ObjRS As New ADODB.Recordset
    Dim dblCantidadConcepto As Double
    Dim dblCantidadIVA As Double
    Dim vllngNumeroCuenta As Long
    Dim rsPvDetalleCorte As New ADODB.Recordset
    Dim rsDCP As New ADODB.Recordset
    Dim rsPolizaenPuente As New ADODB.Recordset
    Dim rsPagoenPuente As New ADODB.Recordset
    Dim blnexitsub As Boolean
    Dim strNombreFactura As String
    '--------------------------------------------------
    Dim intlineaGoto As Integer
    Dim strError As String
    Dim vlintTotalTickets As Integer
    Dim vlngSigReg As Long
    Dim vlstrFolio As String
    Dim vlintFacturacionConsolidada As Integer
    Dim vllngCveCarta As Long
    
    On Error GoTo NotificaError:
    
    lngConsecutivoFactura = 0
    lngMovPaciente = 0
    lngCveEmpresaConvenio = 0
    strTipoPaciente = ""
    strFacturaPacienteEmpresa = ""
    blnValidarFacturaEmpresa = 0
    strNombreFactura = ""
  
    
    blnFacturaAutomatica = False
    strFolioTicketAut = ""
    blnInsertoMovimientos = False
    vlblnSePuedeCancelar = False
          
    If vlstrFolioFacturaAnterior <> "" Then
        vlstrFolio = vlstrFolioFacturaAnterior
    Else
        vlstrFolio = vlstrFolioFactura
    End If
          
    '----------------------
    'CONSULTA DE LA FACTURA
    '----------------------
1    Set rsFactura = frsEjecuta_SP(Trim(vlstrFolioFactura), "Sp_PvSelFactura")
2    If rsFactura.RecordCount <> 0 Then
3       With rsFactura
4             lngConsecutivoFactura = !IdFactura
5             lngMovPaciente = !cuenta
6             strTipoPaciente = Trim(!CHRTIPOPACIENTE)
7             strFacturaPacienteEmpresa = !chrTipoFactura
8             strNombreFactura = Trim(!RazonSocial)
            
             ' Esto es que una factura puede ser :
             ' "Normal" = Que no se hizo en el POS
             ' "Ticket" = Que se facturo uno o varios tickets
             ' "Directo" = Que fue Venta al publico pero con Factura, sin ticket
9             strTipoFactura = IIf(!intCveVentaPublico = 0, "N", IIf(!intCveVentaPublico = -1, "T", "D"))
10             blnbitpesos = IIf(IsNull(!BITPESOS), 1, 0)
11             strFechaFactura = Format(!fecha, "DD/MM/YYYY")
12             dblHonorariosFacturados = IIf(IsNull(!mnyHonorariosFacturados), 0, !mnyHonorariosFacturados)
              vllngCveCarta = IIf(IsNull(!intCveCarta), 0, !intCveCarta)
13       End With
    Else
        'no existe información algo pasó?
14        MsgBox SIHOMsg(13), vbExclamation + vbOKOnly, "Mensaje"
          intlineaGoto = 15
          strError = SIHOMsg(13)
15        GoTo NotificaError
         'Exit Sub
    End If
    
    '------------------------------------------------------------------------------------------------------------------------'
    ' Obtener la forma en que se facturó, FFS = Separada con factura al paciente, RFS = Consolidada con recibo al paciente
    '------------------------------------------------------------------------------------------------------------------------'
    vlintFacturacionConsolidada = 0
    vlstrSentencia = "Select CHRFORMAFACTURACION " & _
                     "  From pvControlAseguradora " & _
                     " Where pvControlAseguradora.INTMOVPACIENTE = " & Trim(lngMovPaciente) & _
                     "   And pvControlAseguradora.CHRTIPOPACIENTE = '" & strTipoPaciente & "'"
    Set rsTemp = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)           'RS de consulta
    If rsTemp.RecordCount > 0 Then
        vlintFacturacionConsolidada = IIf(rsTemp!CHRFORMAFACTURACION = "RFS", 1, 0)
    End If
    
16    blncontrolaseguradora = False
17    strParametros = str(lngMovPaciente) & "|" & str(vgintClaveEmpresaContable)
    
    'Internos ó Externos
18    Set rsTemp = IIf(strTipoPaciente = "I", frsEjecuta_SP(strParametros, "SP_PVSELINTERNOFACTURA"), frsEjecuta_SP(strParametros, "SP_PVSELEXTERNOFACTURA"))
19    If rsTemp.RecordCount > 0 Then
20        If rsTemp!bitUtilizaConvenio = 1 And rsTemp!bitAseguradora = 1 Then
21            blncontrolaseguradora = True
22            blnValidarFacturaEmpresa = IIf(strFacturaPacienteEmpresa = "P", 1, 0)
23            lngCveEmpresaConvenio = rsTemp!cveEmpresa
        End If
    End If
24    rsTemp.Close
25    rsFactura.Close
    
    '------------------------------
    'Regresa cantidad de la nota(s)
    '------------------------------
26    strParametros = vlstrFolioFactura & "|" & CStr(vgintClaveEmpresaContable) & "|" & IIf(strTipoPaciente = "I", "I", "E") & "|" & lngMovPaciente
27    Set rsCantidadNota = frsEjecuta_SP(strParametros, "SP_PVSELNOTADECREDITO")
28    If rsCantidadNota.RecordCount > 0 Then
29        dblCantidad = rsCantidadNota!cantidad
        
30        If blnbitpesos = 0 Then
31            strParametros = strFechaFactura
32            Set rsTipoCambio = frsEjecuta_SP(strParametros, "Sp_GnSelTipoCambio")
33            If rsTipoCambio.RecordCount > 0 Then intTipoCambio = rsTipoCambio!Venta
34            rsTipoCambio.Close
            
35            dblCantidad = Round(dblCantidad / intTipoCambio, 2)
        End If
    Else
36        dblCantidad = 0
    End If
37    rsCantidadNota.Close
    
38    dblNotas = dblCantidad
       
    '------------------------------------------------------------------------------------------------------------------
    '------------------------------------------------------------------------------------------------------------------
  
39    vlstrSentencia = "SELECT chrestatus FROM PvFactura WHERE chrFolioFactura = '" & Trim(vlstrFolioFactura) & "' and smiDepartamento = " & Trim(str(vgintNumeroDepartamento))
40    Set rsTemp = frsRegresaRs(vlstrSentencia)
41    If rsTemp.RecordCount > 0 Then
42        If rsTemp!chrEstatus = "C" Then
            'No se puede cancelar la factura <FOLIO DE LA FACTURA>, el estado cambió. Consulte de nuevo.
            MsgBox Replace(SIHOMsg(1228), "esta factura", "la factura " & Trim(vlstrFolioFactura)), vbExclamation, "Mensaje"
            intlineaGoto = 43
            strError = SIHOMsg(1228)
43          GoTo NotificaError
           'Exit Sub
        End If
    End If

44    vlstrSentencia = "SELECT PvFacturasParciales.INTFACTURABASE FROM PvFacturasParciales WHERE PvFacturasParciales.INTFACTURAPARCIAL = " & lngConsecutivoFactura
45    Set rsTemp = frsRegresaRs(vlstrSentencia)
    
    '-----------------------------------------------------------------------------
    'Si aun no se ha facturado la base de la factura parcial o es una factura base
    '-----------------------------------------------------------------------------
46    If IsNull(rsTemp!INTFACTURABASE) Or rsTemp.RecordCount = 0 Then
47        vlblnSePuedeCancelar = True
      End If
48    rsTemp.Close

49    If blnValidarFacturaEmpresa = 4 Then
        '-------------------------------------------------------------------
        'Si la factura está en PvFacturaParcialEmpresa, no se puede cancelar
        'porque significa que ya se descontó en una factura de la empresa
        '-------------------------------------------------------------------
50        vlstrSentencia = "SELECT * FROM PvFacturaParcialEmpresa WHERE intFacturaParcial = " & lngConsecutivoFactura
51        Set rsTemp = frsRegresaRs(vlstrSentencia)
52        If rsTemp.RecordCount > 0 Then
             MsgBox SIHOMsg(983), vbExclamation, "Mensaje"
            'Para poder cancelar la factura del paciente, se debe cancelar primero la factura de la empresa
             intlineaGoto = 53
             strError = SIHOMsg(983)
53           GoTo NotificaError
            'Exit Sub
        Else
            '--------------------------------------------------------------------------------------
            'Si todos los cargos (no excluídos) de la cuenta están facturados, no se puede facturar
            'porque significa que ya se facturó todo a la empresa
            '--------------------------------------------------------------------------------------
             vlstrSentencia = "SELECT COUNT(*) cargos FROM PvCargo WHERE bitExcluido = 0 " & _
                             " AND chrTipoPaciente = '" & IIf(strTipoPaciente = "I", "I", "E") & _
                             "' AND intMovPaciente = " & lngMovPaciente
54            Set rsTemp = frsRegresaRs(vlstrSentencia)
55            If rsTemp!Cargos = -99 Then
56                vlstrSentencia = "SELECT * FROM PvCargo WHERE bitExcluido = 0 " & _
                                 " AND chrTipoPaciente = '" & IIf(strTipoPaciente = "I", "I", "E") & _
                                 " 'AND intMovPaciente = " & lngMovPaciente & " " & _
                                 " AND chrFolioFactura Is Null "
57                Set rsTemp = frsRegresaRs(vlstrSentencia)
58                If rsTemp.EOF Then
                    'Para poder cancelar la factura del paciente, se debe cancelar primero la factura de la empresa
                    MsgBox SIHOMsg(983), vbExclamation, "Mensaje"
                    intlineaGoto = 59
                    strError = SIHOMsg(983)
59                   GoTo NotificaError
                    'Exit Sub
                End If
            End If
        End If
        rsTemp.Close
    End If

60    Set rsTemp = frsEjecuta_SP(Trim(vlstrFolioFactura), "Sp_PvSelFacturaAutomatica")
61    If rsTemp.RecordCount > 0 Then
62        blnFacturaAutomatica = True
63        strFolioTicketAut = Trim(rsTemp!chrFolioTicket)
    End If
64    rsTemp.Close

65    If vlblnSePuedeCancelar Then

        '------------------------------------------------------------------------'
        ' Checo que esa factura no tenga pagos registrados en Crédito y cobranza '
        '------------------------------------------------------------------------'
66        vlstrSentencia = " SELECT COUNT(intNumMovimiento) FROM CcMovimientoCredito " & _
                         " WHERE chrFolioReferencia = '" & Trim(vlstrFolioFactura) & "'" & _
                         " AND chrTipoReferencia = 'FA' " & _
                         " AND mnyCantidadPagada > 0 "
67        Set rsChecaCredito = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
68        If rsChecaCredito.Fields(0) > 0 Then
             'No se puede cancelar la factura <Folio>, el crédito tiene pagos registrados.
             MsgBox Replace(SIHOMsg(368), "el documento", "la factura " & Trim(vlstrFolioFactura) & ", "), vbCritical, "Mensaje"
             intlineaGoto = 69
             strError = SIHOMsg(368)
69           GoTo NotificaError
            'Exit Sub
        End If
70        rsChecaCredito.Close

        '-----------------------------------------------------------------------------'
        ' Valida parámetros para usar la cuenta puente para abonos a cuentas de banco '
        '-----------------------------------------------------------------------------'
71        blnValidaCuentaPuenteBanco = True
        'Regresa bit para validar cuenta puente a banco
72        intBitCuentaPuenteBanco = 1
73        frsEjecuta_SP CStr(vgintClaveEmpresaContable) & "|" & "bitUtilizaCuentaPuenteBanco", "FN_PVSELBITPARAMETRO", True, intBitCuentaPuenteBanco
        'Si intBitCuentaPuenteBanco = 0, no se usará la cuenta puente para abonos a cuentas de banco y se registrará la póliza de la cancelación como normalmente se hace
        'Si intBitCuentaPuenteBanco = 1, si se usará la cuenta puente para abonos a cuentas de banco y enseguida se validan otros valores para su uso
    
74        If intBitCuentaPuenteBanco = 1 Then
           ' Regresa valor de parámetro que indica la cuenta puente a banco
75           If blnValidaCuentaPuenteBanco Then
76              lngCuentaPuenteBanco = 0
77              Set rsTemp = frsSelParametros("CN", vgintClaveEmpresaContable, "INTNUMCUENTAPUENTEBANCO")
78              If rsTemp.EOF Then
                 'No se ha registrado la "Cuenta puente para abonos a cuentas de banco por cancelación y/o re facturación".
79                 MsgBox SIHOMsg(1327), vbOKOnly + vbInformation, "Mensaje"
                   strError = SIHOMsg(1327) & "79"
80                 blnValidaCuentaPuenteBanco = False
              Else
81                 lngCuentaPuenteBanco = IIf(IsNull(rsTemp!Valor), 0, CLng(rsTemp!Valor))
82                 If lngCuentaPuenteBanco = 0 Then
                    'No se ha registrado la "Cuenta puente para sustituir cuenta de banco al cancelar y/o re facturar".
83                    MsgBox SIHOMsg(1327), vbOKOnly + vbInformation, "Mensaje"
84                    strError = SIHOMsg(1327) & "83"
                      blnValidaCuentaPuenteBanco = False
                 End If
              End If
85              rsTemp.Close
           End If
        
           'Verifica el estatus del concepto de pago que se generará automáticamente por la cancelación de la factura
86           If blnValidaCuentaPuenteBanco Then
87              vlstrSentencia = "select pvconceptopago.bitestatusactivo From pvconceptopago Where pvconceptopago.bitpagocancelafactura = 1"
88              Set rsTemp = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
89              If rsTemp.RecordCount > 0 Then
90                 If IsNull(rsTemp!bitestatusactivo) Or rsTemp!bitestatusactivo = 0 Then
                    'El concepto para generar pagos automáticos al cancelar facturas no está activo.
91                    MsgBox SIHOMsg(1330), vbOKOnly + vbInformation, "Mensaje"
                      strError = SIHOMsg(1330) & "91"
92                    blnValidaCuentaPuenteBanco = False
                 End If
              Else
                 'El concepto para generar pagos automáticos al cancelar facturas no está activo.
93                  MsgBox Replace(SIHOMsg(1330), "activo", "configurado"), vbOKOnly + vbInformation, "Mensaje"
                    strError = SIHOMsg(1330) & "93"
94                  blnValidaCuentaPuenteBanco = False
              End If
              rsTemp.Close
           End If
        
           'Regresa valores de la cuenta puente para abonos a cuentas de bancos
95           If blnValidaCuentaPuenteBanco Then
96              Set rsTemp = frsEjecuta_SP(CStr(lngCuentaPuenteBanco), "Sp_CnSelCuentaContable")
97              If rsTemp.RecordCount > 0 Then
98                 If IsNull(rsTemp!bitEstatusActiva) Or rsTemp!bitEstatusActiva = 0 Then
                    'La cuenta puente para sustituir cuenta de banco al cancelar y/o re facturar no está activa.
99                    MsgBox SIHOMsg(1328), vbOKOnly + vbInformation, "Mensaje"
                      strError = SIHOMsg(1328) & "99"
100                   blnValidaCuentaPuenteBanco = False
                 Else
101                    If IsNull(rsTemp!Bitestatusmovimientos) Or rsTemp!Bitestatusmovimientos = 0 Then
102                       'La cuenta puente para sustituir cuenta de banco al cancelar y/o re facturar no acepta movimientos.
103                        MsgBox SIHOMsg(1329), vbOKOnly + vbInformation, "Mensaje"
                           strError = SIHOMsg(1329) & "103"
104                        blnValidaCuentaPuenteBanco = False
                    End If
                 End If
              End If
105              rsTemp.Close
           End If
        End If
        
106        If Not blnValidaCuentaPuenteBanco Then
              intlineaGoto = 106
              GoTo NotificaError
              'Exit Sub
           End If
               
        '---------------------------------------------------
        'Reiniciamos el arreglo de los movimientos del corte
        '---------------------------------------------------
107        pAgregarMovArregloCorte 0, 0, "NA", "NA", 0, 0, False, "NA", 0, 0, "NA", 0, 0, "NA", "NA"
        
        '-----------------------------------'
        ' Obtener el numero de corte actual '
        '-----------------------------------'
108        vllngMensaje = flngCorteValido(vgintNumeroDepartamento, vglngNumeroEmpleado, "P")
109        If vllngMensaje <> 0 Then
            'Que el corte debe ser cerrado por cambio de día, Que no existe corte abierto
110          MsgBox SIHOMsg(str(vllngMensaje)), vbOKOnly + vbInformation, "Mensaje"
             intlineaGoto = 110
             strError = SIHOMsg(str(vllngMensaje))
             GoTo NotificaError
            'Exit Sub
        End If

111        vllngNumeroCorte = flngNumeroCorte(vgintNumeroDepartamento, vglngNumeroEmpleado, "P")
        
        '-----------------------'
        ' Inicio de Transacción '
        '-----------------------'
112        EntornoSIHO.ConeccionSIHO.BeginTrans

        '----------------------------------------------------------------------------
        'Pone la fecha actual como fecha de cancelación en GnComprobanteFiscalDigital
        '----------------------------------------------------------------------------
113        frsEjecuta_SP lngConsecutivoFactura & "|FA" & "|" & fstrFechaSQL(fdtmServerFecha, fdtmServerHora), "SP_GNUPDCANCELACOMPROBANTEFIS"

114        vllngNumCorteFactura = frsRegresaRs("SELECT intNumCorte FROM PvFactura WHERE chrFolioFactura = '" & Trim(vlstrFolioFactura) & "'").Fields(0)
            
        '------------------------------------------------------------'
        ' Generar registros al reves en PvDetalleCorte para cancelar '
        '------------------------------------------------------------'
115         vlstrSentencia = "SELECT * FROM PvDetalleCorte WHERE chrFolioDocumento = '" & Trim(vlstrFolioFactura) & "' AND chrTipoDocumento = 'FA'"
116         Set rsDC = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)           'RS de consulta
117         If rsDC.RecordCount > 0 Then
             
118                    Do While Not rsDC.EOF
         
119                        pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, rsDC!chrFolioDocumento, rsDC!chrTipoDocumento, 0, rsDC!mnyCantidadPagada * -1, False, _
                                                CStr(fdtmServerFecha + fdtmServerHora), rsDC!intFormaPago, rsDC!mnytipocambio, rsDC!intfoliocheque, _
                                                rsDC!intNumCorteDocumento, 1, vlstrFolioFactura, "FA"
120                        rsDC.MoveNext
                    Loop
               
         End If

121         vlstrSentencia = "SELECT DISTINCT chrFolioDocumento, chrTipoDocumento, intFormaPago, " & _
                          " mnyCantidadPagada, mnyTipoCambio, intFolioCheque, intNumCorteDocumento " & _
                          " FROM PvDetalleCorte " & _
                          " WHERE chrFolioDocumento IN (SELECT chrFolioRecibo " & _
                                                        " FROM PvPago " & _
                                                       " WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "')" & _
                            " AND mnyCantidadPagada > 0 " & _
                            " AND chrTipoDocumento = 'RE' "
         
122         If strFacturaPacienteEmpresa = "P" Then  ' Sólo las facturas de pacientes tienen salidas de Efectivo

123            vlstrSentencia = vlstrSentencia & " UNION SELECT DISTINCT chrFolioDocumento, chrTipoDocumento, intFormaPago, " & _
                                              " mnyCantidadPagada, mnyTipoCambio, intFolioCheque, intNumCorteDocumento " & _
                                              " FROM PvDetalleCorte " & _
                                              " WHERE chrFolioDocumento IN (SELECT chrFolioRecibo " & _
                                                                            " FROM PvSalidaDinero " & _
                                                                            " WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "') " & _
                                              " AND mnyCantidadPagada > 0 " & _
                                              " AND chrTipoDocumento = 'SD' "
         End If
            
124         Set rsDC = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly) 'RS de consulta
125         vldblTotalIVACredito = 0
126         If rsDC.RecordCount > 0 Then
127            Do While Not rsDC.EOF
               'Aqui se obtiene el total del Iva a crédito para poder hacer
128               Set rsTemp = frsRegresaRs("SELECT PvFormaPago.chrTipo FROM PvFormaPago WHERE PvFormaPago.intFormaPago = " & rsDC!intFormaPago, adLockOptimistic, adOpenForwardOnly)
129               If rsTemp!chrTipo = "C" Then vldblTotalIVACredito = vldblTotalIVACredito + rsDC!mnyCantidadPagada
'
130               pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, rsDC!chrFolioDocumento, rsDC!chrTipoDocumento, 0, rsDC!mnyCantidadPagada, False, _
                                       CStr(fdtmServerFecha + fdtmServerHora), rsDC!intFormaPago, rsDC!mnytipocambio, rsDC!intfoliocheque, _
                                       rsDC!intNumCorteDocumento, 1, vlstrFolioFactura, "FA"
131               rsDC.MoveNext
            Loop
         End If

         '------------------------------------------------------------------------------------------------------'
         ' Registrar en el corte movimientos, solo para Facturas de Tickets, para que se quede la venta intacta '
         '------------------------------------------------------------------------------------------------------'
132         If strTipoFactura = "T" Then 'Sólo se reactivan las ventas de las facturas de tikets
133            vlstrSentencia = "SELECT DISTINCT chrFolioDocumento, " & _
                                 " chrTipoDocumento, intFormaPago, mnyCantidadPagada, " & _
                                 " mnyTipoCambio, intFolioCheque, intNumCorteDocumento " & _
                                 " FROM PvDetalleCorte " & _
                                 " WHERE mnyCantidadPagada > 0 " & _
                                 " AND chrTipoDocumento = 'TI' " & _
                                 " AND chrFolioDocumento IN (SELECT chrFolioTicket FROM PvVentaPublico WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "')"
134            Set rsCorteTiKets = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
                
135            If rsCorteTiKets.RecordCount > 0 Then
            
136                        Do While Not rsCorteTiKets.EOF
'
137                             pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, rsCorteTiKets!chrFolioDocumento, "TI", 0, rsCorteTiKets!mnyCantidadPagada, _
                             False, CStr(fdtmServerFecha + fdtmServerHora), rsCorteTiKets!intFormaPago, rsCorteTiKets!mnytipocambio, rsCorteTiKets!intfoliocheque, _
                             rsCorteTiKets!intNumCorteDocumento, 1, vlstrFolioFactura, "FA"
                             
138                             rsCorteTiKets.MoveNext
                        Loop
           
                Else
                    'Si no encuentra nada es que fué un ticket que generó factura automática
                    'Selecciona los tickets de la factura
139                    vlstrSentencia = "SELECT chrFolioTicket FROM PvVentaPublico WHERE chrTipoRecivo = 'T' AND Trim(chrFolioFactura) = '" & Trim(vlstrFolioFactura) & "'"
140                    Set rsTickets = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
                       vlintTotalTickets = rsTickets.RecordCount
141                    If rsTickets.RecordCount > 0 Then
142                        vlstrSentencia = "SELECT * FROM PvDetallecorte " & _
                                         " WHERE chrFolioDocumento = '" & Trim(vlstrFolioFactura) & "'" & _
                                         " AND chrTipoDocumento = 'FA'" & _
                                         " AND mnyCantidadPagada > 0"
143                        Set rsDC = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
144                        If rsDC.RecordCount > 0 Then
145                           Do While Not rsDC.EOF
'
146                                     pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(rsTickets!chrFolioTicket), "TI", 0, rsDC!mnyCantidadPagada, False, rsDC!dtmFechahora, _
                                     rsDC!intFormaPago, rsDC!mnytipocambio, rsDC!intfoliocheque, rsDC!intNumCorteDocumento, 1, vlstrFolioFactura, "FA"
147                              rsDC.MoveNext
                           Loop
                        End If
                    End If
148                    rsTickets.Close
                End If
149                rsCorteTiKets.Close
         End If

         ' Cancelación de la factura
150         vlstrSentencia = "SELECT chrestatus FROM PvFactura WHERE chrFolioFactura = '" & Trim(vlstrFolioFactura) & "'"
151         Set rsTemp = frsRegresaRs(vlstrSentencia)
         
152         If rsTemp.RecordCount > 0 Then
153            If rsTemp!chrEstatus = "C" Then
154               EntornoSIHO.ConeccionSIHO.RollbackTrans
155               MsgBox Replace(SIHOMsg(1228), "esta factura", "la factura " & Trim(vlstrFolioFactura)), vbExclamation, "Mensaje"
                  intlineaGoto = 155
                  strError = Replace(SIHOMsg(1228), "esta factura", "la factura " & Trim(vlstrFolioFactura))
                  GoTo NotificaError
                  'Exit Sub
            End If
         End If

156         vlstrSentencia = "UPDATE PvFactura SET chrEstatus = 'C' WHERE chrFolioFactura = '" & Trim(vlstrFolioFactura) & "'"
157         pEjecutaSentencia (vlstrSentencia)

        '----------------------------------'
        ' Actualiza el estatus de la carta '
        '----------------------------------'
        vlstrSentencia = "UPDATE PvCartaControlSeguro SET chrEstatus = 'A'" & _
                         " WHERE intNumCuenta = " & lngMovPaciente & " AND intCveCarta = " & vllngCveCarta
        pEjecutaSentencia (vlstrSentencia)


158         If Not blnRefacturacion Then
             ' Eliminación de la factura de facturas parciales
159             vlstrSentencia = " DELETE FROM PvFacturasParciales WHERE PvFacturasParciales.INTFACTURAPARCIAL = " & lngConsecutivoFactura
160             pEjecutaSentencia vlstrSentencia
    
             '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
             ' Actualiza las facturas parciales con el número de factura base '
             '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
161             vlstrSentencia = "UPDATE PvFacturasParciales SET PvFacturasParciales.INTFACTURABASE = NULL "
162             vlstrSentencia = vlstrSentencia & " WHERE PvFacturasParciales.INTFACTURABASE = " & lngConsecutivoFactura
163             pEjecutaSentencia vlstrSentencia
    
             '---------------------------------------------------------'
             ' Quita las facturas parciales de PvFacturaParcialEmpresa '
             '---------------------------------------------------------'
164             vlstrSentencia = "DELETE FROM PvFacturaParcialEmpresa WHERE PvFacturaParcialEmpresa.INTFACTURAEMPRESA = " & lngConsecutivoFactura
165             pEjecutaSentencia vlstrSentencia
         End If
         '---------------------------------'
         ' Guardo en documentos cancelados '
         '---------------------------------'
166         vlstrSentencia = "SELECT chrFolioDocumento FROM PvDocumentoCancelado WHERE chrFolioDocumento = '" & Trim(vlstrFolioFactura) & "' and smiDepartamento = " & Trim(str(vgintNumeroDepartamento))
167         Set rsTemp = frsRegresaRs(vlstrSentencia)
         
168         If rsTemp.RecordCount > 0 Then
169            EntornoSIHO.ConeccionSIHO.RollbackTrans
170            MsgBox Replace(SIHOMsg(1228), "esta factura", "la factura " & Trim(vlstrFolioFactura)), vbExclamation, "Mensaje"  'No se puede cancelar esta factura, el estado cambió. Consulte de nuevo.
               intlineaGoto = 170
               strError = Replace(SIHOMsg(1228), "esta factura", "la factura " & Trim(vlstrFolioFactura))
               GoTo NotificaError
              'Exit Sub
         End If

172         vlstrSentencia = "INSERT INTO PVDocumentoCancelado VALUES('" & Trim(vlstrFolioFactura) & "','FA'," & _
                          Trim(str(vgintNumeroDepartamento)) & "," & Trim(str(vllngPersonaGraba)) & ",getdate())"
173         pEjecutaSentencia (vlstrSentencia)

         '----------------------------------------------------------------------------'
         ' Si es factura automática, se guarda el ticket en los documentos cancelados '
         '----------------------------------------------------------------------------'
174         If blnFacturaAutomatica Then
175                vlstrSentencia = "INSERT INTO PvDocumentoCancelado VALUES('" & Trim(strFolioTicketAut) & "','TI'," & _
                                 Trim(str(vgintNumeroDepartamento)) & "," & Trim(str(vllngPersonaGraba)) & ",getdate())"
                pEjecutaSentencia (vlstrSentencia)
         End If

         '-------------------------------------------------------------'
         ' Inserta los movimientos del(los) Ticket(s) en PvCortePoliza '
         '-------------------------------------------------------------'
176         If strTipoFactura = "T" Then
            'Solo cuando son Facturas(no automáticas, ni directas) del POS
            'Selecciona los tickets de la factura
177            vlstrSentencia = "SELECT chrFolioTicket, intCveVenta, intNumCorte FROM PvVentaPublico WHERE chrTipoRecivo = 'T' AND Trim(chrFolioFactura) = '" & Trim(vlstrFolioFactura) & "'"
178            Set rsTickets = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
179            If rsTickets.RecordCount > 0 Then
                rsTickets.MoveFirst
180               Do While Not rsTickets.EOF
                     blnInsertoMovimientos = False
                     'Selecciona los movimientos de ticket
181                  strParametros = Trim(rsTickets!chrFolioTicket) & "|" & "TI" & "|" & Trim(rsTickets!intNumCorte)
182                  Set rsMovimientosT = frsEjecuta_SP(strParametros, "sp_PvSelPolizaDocto")
183                  Do While Not rsMovimientosT.EOF
184                            pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(rsMovimientosT!chrFolioDocumento), "TI", rsMovimientosT!intNumCuenta, rsMovimientosT!MNYCantidad, rsMovimientosT!bitcargo, _
                               "NA", 0, 0, "NA", 0, 2, vlstrFolioFactura, "FA"
185                            rsMovimientosT.MoveNext
186                            blnInsertoMovimientos = True
187                   Loop
                   
                   'Revive el crédito del ticket
188                   vlstrSentencia = " UPDATE CcMovimientoCredito SET bitCancelado = 0," & _
                                    " dtmFechaCancelacion = Null " & _
                                    " WHERE chrFolioReferencia = '" & Trim(rsTickets!chrFolioTicket) & "'" & _
                                    " AND chrTipoReferencia = 'TI' " & _
                                    " AND mnyCantidadPagada = 0 "
189                   pEjecutaSentencia (vlstrSentencia)


                   'Se reactiva el ticket, borrando el registro en pvDcocumentoCancelado
                   vlstrSentencia = " DELETE pvDocumentoCancelado " & _
                                    " WHERE trim(chrFolioDocumento) = '" & Trim(rsTickets!INTCVEVENTA) & "'" & _
                                    " AND chrTipoDocumento = 'TI' " & _
                                    " AND smiDepartamento = " & Trim(str(vgintNumeroDepartamento))
                   pEjecutaSentencia (vlstrSentencia)
                                      
                                      
                   'Reactivar las formas de pago del ticket en la tabla intermedia -'
                   'pActivarTicket rsTickets!intCveVenta, rsTickets!intNumCorte, vllngNumeroCorte, vllngPersonaGraba
                   'pActivarTicket------------------------------------------------------------------------------------------
190                   vlstrSentencia = "SELECT MB.intFormaPago, MB.chrTipoMovimiento, MB.mnyCantidad, MB.mnyTipoCambio," & _
                                    " FP.chrTipo, ISNULL(B.tnyNumeroBanco, MB.intCveBanco) AS IdBanco " & _
                                    " FROM PvMovimientoBancoForma MB " & _
                                    " INNER JOIN PvFormaPago FP ON MB.intFormaPago = FP.intFormaPago " & _
                                    " LEFT  JOIN CpBanco B ON B.intNumeroCuenta = FP.intCuentaContable " & _
                                    " WHERE TRIM(MB.chrTipoDocumento) = 'TI' AND MB.intNumDocumento = " & rsTickets!INTCVEVENTA & _
                                    " AND MB.intNumCorte = " & rsTickets!intNumCorte & " AND MB.mnyCantidad > 0"
191                   Set rsTemp = frsRegresaRs(vlstrSentencia)
192                   If Not rsTemp.EOF Then
193                        rsTemp.MoveFirst
194                        Do While Not rsTemp.EOF
195                            If rsTemp!chrTipo <> "C" Then
196                                strFecha = fstrFechaSQL(fdtmServerFecha, fdtmServerHora) '- Fecha y hora del movimiento -'
                
                                '- Guardar información en tabla intermedia -'
197                                strParametros = vllngNumeroCorte & _
                                                 "|" & strFecha & _
                                                 "|" & rsTemp!intFormaPago & _
                                                 "|" & rsTemp!IdBanco & _
                                                 "|" & rsTemp!MNYCantidad & _
                                                 "|" & IIf(rsTemp!mnytipocambio = 0, 1, 0) & _
                                                 "|" & rsTemp!mnytipocambio & _
                                                 "|" & rsTemp!chrTipoMovimiento & _
                                                 "|" & "TI" & "|" & rsTickets!INTCVEVENTA & _
                                                 "|" & vllngPersonaGraba & _
                                                 "|" & vgintNumeroDepartamento & _
                                                 "|" & strFecha & _
                                                 "|" & "1" & "|" _
                                                 & cgstrModulo
198                                frsEjecuta_SP strParametros, "Sp_PvInsMovimientoBancoForma"
199                            End If
200                            rsTemp.MoveNext
201                        Loop
                   End If
202                rsTemp.Close
                    '------------------------------------------------------------------------------------------------
                        
                  'Si no insertó nada,
                  'Quiere decir que el ticket no tenía movimientos porque fué factura automática
                  'Se insertan los movimientos de la factura, con los datos del cliente



205               If Not blnInsertoMovimientos Then
207                        vlstrSentencia = "select " & _
                                             "case when " & intBitCuentaPuenteBanco & " = 1  then " & _
                                                " case when fn_pvCuentaRelacionadaConBanco (trim(chrfoliodocumento), intnumcuenta, mnycantidad, trim(chrtipodocumento)) = 1 then " & _
                                                    lngCuentaPuenteBanco & _
                                                " else INTNUMCUENTA end " & _
                                             "else INTNUMCUENTA end  intnumcuenta " & _
                                         ", mnyCantidad, bitcargo ,INTCONSECUTIVO  " & _
                                          "from pvcortepoliza " & _
                                         "where trim(chrfoliodocumento) = '" & Trim(rsTickets!chrFolioTicket) & "' and chrtipomovimiento = 'TIK'" & _
                                          " and trim(chrtipodocumento) = 'TI' ORDER BY INTCONSECUTIVO"

208                        Set rsMovimientosT = frsRegresaRs(vlstrSentencia)
                           'vlngSigReg = 0
209                        Do While Not rsMovimientosT.EOF
                           '   If vlngSigReg = 0 Then
                           '      vlngSigReg = rsMovimientosT!INTCONSECUTIVO
210                              pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(rsTickets!chrFolioTicket), "TI", rsMovimientosT!intNumCuenta, rsMovimientosT!MNYCantidad, rsMovimientosT!bitcargo, _
                                 "NA", 0, 0, "NA", 0, 2, vlstrFolioFactura, "FA"
211                        '   Else
                           '      If (vlngSigReg + 1) = rsMovimientosT!INTCONSECUTIVO Then
                           '         vlngSigReg = rsMovimientosT!INTCONSECUTIVO
                           '         pAgregarMovArregloCorte vllngNumeroCorte, Trim(rsTickets!CHRFOLIOTICKET), "TI", rsMovimientosT!intnumcuenta, rsMovimientosT!mnycantidad, rsMovimientosT!bitcargo, _
                           '         "NA", 0, 0, "NA", 0, 2, vlstrFolioFactura, "FA"
                           '      Else
                           '         Exit Do
                           '      End If
                           '   End If
                              rsMovimientosT.MoveNext
212                        Loop
                        rsMovimientosT.Close
                        '--------------------------------
                        'Inserta el movimiento del ticket
                        'Usa los datos de la factura
                        '--------------------------------
213                     'vlstrSentencia = "SELECT * FROM CcMovimientoCredito " & _
                        '                 " WHERE Trim(chrFolioReferencia) = '" & Trim(vlstrFolioFactura) & "'" & _
                        '                 " AND chrTipoReferencia = 'FA' " & _
                        '                 " AND mnyCantidadPagada = 0 "
                        '
214                     'Set rsCredito = frsRegresaRs(vlstrSentencia)
215                     'If rsCredito.RecordCount > 0 Then
216                     '     vgstrParametrosSP = fstrFechaSQL(Format(rsCredito!dtmFechaMovimiento, "dd/mm/yyyy")) & "|" & _
                        '                        CStr(rsCredito!INTNUMCLIENTE) & "|" & _
                        '                        CStr(rsCredito!INTNUMCUENTACONTABLE) & "|" & _
                        '                        Trim(rsTickets!chrFolioTicket) & _
                        '                        "|TI|" & _
                        '                        CStr(rsCredito!mnyCantidadCredito) & "|" & _
                        '                        CStr(rsCredito!SMIDEPARTAMENTO) & "|" & _
                        '                        CStr(rsCredito!intCveEmpleado) & _
                        '                        "| |0|" & _
                        '                        CStr(rsCredito!MNYSUBTOTAL) & "|" & _
                        '                        CStr(rsCredito!MNYIVA)
217                     '       lngMovimientoCredito = 1
218                     '       frsEjecuta_SP vgstrParametrosSP, "SP_GNINSCREDITO", True, lngMovimientoCredito
                        'End If
219                     'rsCredito.Close
                    End If
220                 rsTickets.MoveNext

                   Loop
                End If
          End If

            '-----------------------------------------------------------'
            ' Quitar numero de factura del registro de Venta al Público '
            '-----------------------------------------------------------'
            'Si es factura automática el bitCancelado queda en 1 como ya estaba
221            vlstrSentencia = "UPDATE PvVentaPublico SET bitCancelado = " & IIf(blnFacturaAutomatica, "1", "0") & " , chrFolioFactura = null WHERE chrFolioFactura = '" & Trim(vlstrFolioFactura) & "'"
223            pEjecutaSentencia vlstrSentencia
            
            '-----------------------------------------------'
            ' Borrar los movimientos de CCMovimientoCredito '
            '-----------------------------------------------'
232            vlstrSentencia = " UPDATE CcMovimientoCredito SET bitCancelado = 1, " & _
                             " dtmFechaCancelacion = " & fstrFechaSQL(fdtmServerFecha) & _
                             " WHERE chrFolioReferencia = '" & vlstrFolioFactura & "'" & _
                             " AND chrTipoReferencia = 'FA' " & _
                             " AND mnyCantidadPagada = 0 "
233            pEjecutaSentencia (vlstrSentencia)

            '---------------------------------------------------------------'
            ' Actualiza la fecha de facturación en caso de que sea un grupo '
            '---------------------------------------------------------------'
234            If strTipoPaciente = "G" And lngMovPaciente <> 0 Then
235                vlstrSentencia = "UPDATE PvFacturacionConsolidada SET chrFolioFactura = Null WHERE INTCVEGRUPO = " & lngMovPaciente
236                pEjecutaSentencia vlstrSentencia
            End If

            '-----------------------------------------------------------'
            ' Quitar el estatus de "Facturada" a la cuenta del paciente '
            '-----------------------------------------------------------'
237            If strTipoPaciente = "I" Or strTipoPaciente = "E" Then
                'Factura de una cuenta:
238                vgstrParametrosSP = lngMovPaciente & "|" & strTipoPaciente & "|" & "0"
239                frsEjecuta_SP vgstrParametrosSP, "SP_PVUPDCUENTAFACTURADA"
            Else
240                If strTipoPaciente = "G" Then
                    'Factura de un grupo
241                    Set rsTemp = frsEjecuta_SP(CStr(lngMovPaciente), "SP_PVSELCUENTAGRUPO")
242                    Do While Not rsTemp.EOF
243                        vgstrParametrosSP = rsTemp!INTMOVPACIENTE & "|" & rsTemp!CHRTIPOPACIENTE & "|" & "0"
244                        frsEjecuta_SP vgstrParametrosSP, "SP_PVUPDCUENTAFACTURADA"
245                        rsTemp.MoveNext
                    Loop
                End If
            End If

            '---------------------------------------------------------'
            ' Quitar o actualizar el folio del control de aseguradora '
            ' Y actualiza mnyHonorariosFacturadosPac                  '
            '---------------------------------------------------------'
246            If strFacturaPacienteEmpresa = "P" And blncontrolaseguradora Then
            'Busca si hay otra factura de paciente por concepto de seguro que no sea parcial y actualiza el Control
            'Si no borra el folio del control y de PvFacturaPacienteConcepto
            'Deja en 0 los exedentes por honorarios
247                vgstrParametrosSP = lngMovPaciente & "|" & _
                                    IIf(strTipoPaciente = "I", "I", "E") & "|" & _
                                    CStr(vgintClaveEmpresaContable) & "|" & _
                                    CStr(lngConsecutivoFactura) & "|" & _
                                    CStr(lngCveEmpresaConvenio) & "|" & _
                                    Trim(vlstrFolioFactura) & "|" & _
                                    str(dblHonorariosFacturados)
248                frsEjecuta_SP vgstrParametrosSP, "Sp_PvUpdFacturaBaseOld"

249            ElseIf strFacturaPacienteEmpresa = "E" And blncontrolaseguradora Then
250                vgstrParametrosSP = lngMovPaciente & "|" & _
                                    IIf(strTipoPaciente = "I", "I", "E") & "|" & _
                                    CStr(lngCveEmpresaConvenio)
251                frsEjecuta_SP vgstrParametrosSP, "Sp_PvUpdFacturaEmpresaOld"
            End If

252            rsDC.Close
            '¿***************************************************************************************************************************pLiberaCorte vllngNumeroCorte

            'Quita el folio de la factura del paciente de los cargos
253            If strFacturaPacienteEmpresa = "P" Then
254               vlstrSentencia = "UPDATE PvCargo SET chrFolioFacturaPaciente = Null, intPaquetesPaciente = 0 WHERE INTMOVPACIENTE = " & lngMovPaciente & " And CHRTIPOPACIENTE = '" & IIf(strTipoPaciente = "I", "I", "E") & "' And chrFolioFacturaPaciente = '" & RTrim(vlstrFolioFactura) & "'"
255               pEjecutaSentencia vlstrSentencia
            End If
            
            '****************Se agregó la opción de cancelar los honorarios facturados al paciente *******
            frsEjecuta_SP Trim(vlstrFolio), "Sp_CCDelHonorarioMedicoContado", True
            '*********************************************************************************************
            
            '-----------------------------------------------------------------'
            ' Quito el numero de factura del cargo, para que los pueda borrar '
            '-----------------------------------------------------------------'
256            vlstrSentencia = "SELECT IntNumCargo, intFolioDocumento, chrTipoDocumento FROM PvCargo WHERE PvCargo.CHRFOLIOFACTURA = '" & RTrim(vlstrFolioFactura) & "'"
257            Set rsTemp = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenStatic)

258            vlstrSentencia = "UPDATE PvCargo SET chrFolioFactura = Null WHERE chrFolioFactura = '" & RTrim(vlstrFolioFactura) & "'"
259            pEjecutaSentencia vlstrSentencia

260            While Not rsTemp.EOF
261              If Trim(rsTemp!chrTipoDocumento) = "T" Then
262                If strTipoFactura = "D" Then 'Sólo se Borran las facturas del POS que no tienen tickets y las automáticas
263                    vlintErrorAlBorrarCargo = 1
                    Dim rsVentaAlmacen As New ADODB.Recordset
                    Dim vlintAlmacenVenta As Integer
                    Dim intMemoria As Integer

264                    intMemoria = vgintNumeroDepartamento
265                    vlstrSentencia = "SELECT smiCveDepartamento FROM NoDepartamento WHERE NoDepartamento.chrClasificacion = 'A' AND smiCveDepartamento = " & vgintNumeroDepartamento
266                    Set rsVentaAlmacen = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
267                    If Not rsVentaAlmacen.RecordCount = 0 Then
268                        With rsVentaAlmacen
269                            vgintNumeroDepartamento = !smicvedepartamento
                        End With
                    Else
270                        vlstrSentencia = "SELECT intNumAlmacen FROM PvAlmacenes WHERE intNumDepartamento = " & vgintNumeroDepartamento
271                        Set rsVentaAlmacen = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
272                        With rsVentaAlmacen
273                            vgintNumeroDepartamento = !intnumalmacen
                        End With
                    End If

274                    vgstrParametrosSP = rsTemp!IntNumCargo & "|" & "EVP" & "|" & vllngPersonaGraba & "|" & vgintNumeroDepartamento & "|" & "T" & "|" & rsTemp!intFolioDocumento & "|" & 0 & "|" & "" & "|" & 2
275                    frsEjecuta_SP vgstrParametrosSP, "SP_PVUPDBORRACARGO", False, vlintErrorAlBorrarCargo
276                    vgintNumeroDepartamento = intMemoria
                End If
            End If
277            rsTemp.MoveNext
           Wend

278           vlstrSentencia = "DELETE FROM PvCargoExcedente WHERE chrFolioFactura = '" & RTrim(vlstrFolioFactura) & "'"
279           pEjecutaSentencia vlstrSentencia
            
           'ABUSADO
           '------------------------------------------------------------------------------------'
           ' Genera todos los movimientos de la factura en la poliza con el siguiente criterio: '
           '   » Si el Corte en el que se realizó la factura y el corte actual son IGUALES      '
           '       - Si es un Cargo. Cantidad = Cantidad * -1 y Tipo Movimiento = Cargo         '
           '       - Si es un Abono. Cantidad = Cantidad * -1 y Tipo Movimiento = Abono         '
           '   » Si el Corte en el que se realizó la factura y el corte actual son DIFERENTES   '
           '       - Si es un Cargo. Cantidad = Cantidad y Tipo Movimiento = Abono              '
           '       - Si es un Abono. Cantidad = Cantidad y Tipo Movimiento = Cargo              '
           '------------------------------------------------------------------------------------'
            If ((strTipoFactura = "D" And vlintTotalTickets = 0) _
                  Or (strTipoFactura = "N" And strFacturaPacienteEmpresa = "E" And vlintFacturacionConsolidada = 0)) Then
                pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(vlstrFolioFactura) & "," & Trim(vlstrFolioFactura), "FAF", 0, 0, _
                False, "", 0, 0, "", -1, 3, "", ""
            Else
                If (strTipoFactura = "N" And strFacturaPacienteEmpresa = "P") Or (strTipoFactura = "N" And strFacturaPacienteEmpresa = "E" And vlintFacturacionConsolidada = 1) Then
                    pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, vlstrFolioFactura, "FAF", 0, 0, False, "NA", 0, 0, "NA", 0, 6, vlstrFolioFactura, "FA"
                Else
280                 pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, vlstrFolioFactura, "FA", 0, 0, False, "NA", 0, 0, "NA", 0, 4, vlstrFolioFactura, "FA"
                End If
            End If
281           rsTemp.Close
                                                                                
'282           If intBitCuentaPuenteBanco And strFacturaPacienteEmpresa = "P" And strTipoFactura <> "D" And strTipoFactura <> "T" Then
'                'pRegistraPagoCuentasBanco vllngNumeroCorte, True, 0, vllngPersonaGraba
'283                 blnexitsub = False
'                'Busca los importes que se registraron con formas de pago ligadas a bancos para obtener el total de ellos
'                'para generar un pago automático
'284                 vlstrSentencia = "select pvdetallecorte.* " & _
'                               ",case when pvmovimientobancoforma.bitpesos = 1 then pvmovimientobancoforma.mnycantidad " & _
'                                "else pvmovimientobancoforma.mnycantidad * pvmovimientobancoforma.mnytipocambio " & _
'                                "end As cantidadPago " & _
'                          " from pvmovimientobancoforma, pvdetallecorte, pvformapago, cpbanco " & _
'                          "where pvmovimientobancoforma.intnumdocumento = " & lngConsecutivoFactura & _
'                           " and pvmovimientobancoforma.CHRTIPODOCUMENTO = 'FA' " & _
'                           " and trim(pvdetallecorte.chrfoliodocumento) = '" & Trim(vlstrFolioFactura) & "'" & _
'                           " and pvdetallecorte.intformapago = pvmovimientobancoforma.intformapago " & _
'                           " and pvmovimientobancoforma.intnumcorte = pvdetallecorte.intnumcorte " & _
'                           " and pvmovimientobancoforma.mnycantidad = pvdetallecorte.mnycantidadpagada " & _
'                           " and pvformapago.intformapago = pvmovimientobancoforma.intformapago " & _
'                           " and (pvformapago.intcuentacontable = cpbanco.intnumerocuenta " & _
'                                "or cpbanco.tnynumerobanco = pvmovimientobancoforma.intcvebanco) " & _
'                           " and pvdetallecorte.intconsecutivo = (select max(pvdetallecorte2.intconsecutivo)" & _
'                                                                   "from pvdetallecorte pvdetallecorte2 " & _
'                                                                  "where trim (pvdetallecorte2.chrfoliodocumento) = '" & Trim(vlstrFolioFactura) & "'" & _
'                                                                    "and pvdetallecorte2.intformapago = pvdetallecorte.intformapago " & _
'                                                                    "and pvdetallecorte2.intnumcorte = pvdetallecorte.intnumcorte " & _
'                                                                    "and pvdetallecorte2.mnycantidadpagada = pvdetallecorte.mnycantidadpagada " & _
'                                                                    "and pvdetallecorte2.chrtipodocumento = pvdetallecorte.chrtipodocumento)"
'285                Set rsDCP = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
'286                If rsDCP.RecordCount > 0 Then
'287                   rsDCP.MoveFirst
'288                   vldblSumaaBancos = 0
'289                   Do While Not rsDCP.EOF
'290                      vldblSumaaBancos = vldblSumaaBancos + rsDCP!cantidadpago
'                      rsDCP.MoveNext
'291                   Loop
'                Else
'                   'Si no hay movimientos de cuentas relacionadas con bancos, busca si hay movimientos en cuenta puente por refacturación
'                   'para generar pago por ese monto
'292                 vlstrSentencia = "select * from pvcortepoliza " & _
'                                  " where trim (pvcortepoliza.chrfoliodocumento) = '" & Trim(vlstrFolioFactura) & "'" & _
'                                  " and pvcortepoliza.intnumcuenta = " & lngCuentaPuenteBanco & _
'                                  " and pvcortepoliza.bitcargo = 1 and pvcortepoliza.chrtipodocumento = 'FA'"
'
'                   'Busca si hay pagos automáticos generados en otras cancelaciones para restarlo
'                   'y registrar un pago solo por lo que no se ha generado un pago
'293                   Set rsPolizaenPuente = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
'294                    If rsPolizaenPuente.RecordCount > 0 Then
'295                       rsPolizaenPuente.MoveFirst
'296                       vldblSumaaBancos = 0
'297                       Do While Not rsPolizaenPuente.EOF
'298                          vldblSumaaBancos = vldblSumaaBancos + rsPolizaenPuente!mnyCantidad
'299                          rsPolizaenPuente.MoveNext
'                       Loop
'300                       vlstrSentencia = "select nvl(sum(pvpago.mnycantidad), 0) pagosautomaticos from pvpago, pvconceptopago " & _
'                                      "where pvpago.chrfoliofactura = '" & Trim(vlstrFolioFactura) & "'" & _
'                                      "  and pvpago.intnumconcepto = pvconceptopago.intnumconcepto and pvconceptopago.bitpagocancelafactura = 1"
'301                       Set rsPagoenPuente = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
'302                        If rsPagoenPuente.RecordCount > 0 Then
'303                           vldblSumaaBancos = vldblSumaaBancos - rsPagoenPuente!pagosautomaticos
'                        End If
'304                        If vldblSumaaBancos <= 0 Then
'305                           blnexitsub = True ' No hay movimientos de la factura que hayan afectado a bancos
'                        Else
'306                           vlstrSentencia = " select distinct pvdetallecorte.* " & _
'                                          ",case when pvdetallecorte.mnytipocambio = 0 then pvdetallecorte.mnycantidadpagada " & _
'                                          " else pvdetallecorte.mnycantidadpagada * pvdetallecorte.mnytipocambio " & _
'                                          " end As cantidadpago " & _
'                                     " from pvcortepoliza, pvdetallecorte, pvformapago, cpbanco  " & _
'                                    " where trim(pvcortepoliza.chrfoliodocumento) = '" & Trim(vlstrFolioFactura) & "'" & _
'                                      " and pvcortepoliza.intnumcuenta = " & lngCuentaPuenteBanco & _
'                                      " and pvcortepoliza.bitcargo = 1 and pvcortepoliza.chrtipodocumento = 'FA'" & _
'                                      " and trim(pvcortepoliza.chrfoliodocumento) = trim(pvdetallecorte.chrfoliodocumento) " & _
'                                      " and pvformapago.intformapago = pvdetallecorte.intformapago " & _
'                                      " and (pvformapago.intcuentacontable = cpbanco.intnumerocuenta " & _
'                                       " or (pvdetallecorte.intformapago = pvformapago.intformapago and pvformapago.chrtipo = 'B') )"
'307                           Set rsPolizaenPuente = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
'308                            If rsPolizaenPuente.RecordCount = 0 Then
'309                               blnexitsub = True   ' No hay movimientos de la factura que hayan afectado a bancos
'                            Else
'310                               rsPolizaenPuente.MoveFirst
'311                               vldblSumaaBancos = 0
'312                               Do While Not rsPolizaenPuente.EOF
'313                                  vldblSumaaBancos = vldblSumaaBancos + rsPolizaenPuente!cantidadpago
'314                                  rsPolizaenPuente.MoveNext
'                               Loop
'315                               If rsPagoenPuente.RecordCount > 0 Then
'316                                  vldblSumaaBancos = vldblSumaaBancos - rsPagoenPuente!pagosautomaticos
'                               End If
'317                               If vldblSumaaBancos <= 0 Then
'318                                  blnexitsub = True ' No hay movimientos de la factura que hayan afectado a bancos
'                               End If
'                            End If
'                        End If
'                    Else
'319                        blnexitsub = True ' No hay movimientos de la factura que hayan afectado a bancos
'                    End If
'                End If
'
'320                If Not blnexitsub Then
'                   '-----------------------'
'                   '   Control de FOLIOS   '
'                   '-----------------------'
'321                   vllngFoliosFaltantes = 0
'322                   pCargaArreglo alstrParametrosSalida, vllngFoliosFaltantes & "|" & adInteger & "|" & strFolio & "|" & ADODB.adBSTR & "|" & strSerie & "|" & ADODB.adBSTR & "|" & strNumeroAprobacion & "|" & ADODB.adBSTR & "|" & strAnoAprobacion & "|" & ADODB.adBSTR
'323                   frsEjecuta_SP "RE" & "|" & vgintNumeroDepartamento & "|1", "Sp_GnFolios", , , alstrParametrosSalida
'324                   pObtieneValores alstrParametrosSalida, vllngFoliosFaltantes, strFolio, strSerie, strNumeroAprobacion, strAnoAprobacion
'                   '|  Si la serie está vacía el SP regresa un espacio en blanco por eso se debe de hacer el TRIM
'325                   strSerie = Trim(strSerie)
'326                   vlstrFolioDocumento = strSerie & strFolio
'
'327                   If Trim(vlstrFolioDocumento) = "0" Then
'328                      EntornoSIHO.ConeccionSIHO.RollbackTrans
'                      'No existen folios activos para este documento.
'329                     MsgBox Replace(SIHOMsg(291), "este documento", "pagos"), vbCritical, "Mensaje"
'                        intlineaGoto = 329
'                        strError = SIHOMsg(291)
'                        GoTo NotificaError
'                      End If
'
'                   'Para validar si el parametro "Desglosar IVA en pagos" está activo
'330                   vlstrSentencia = "select pvconceptopago.intnumconcepto, pvconceptopago.bitdesglosaiva, pvconceptopagoempresa.intnumerocuenta" & _
'                                  " From pvconceptopago, pvconceptopagoempresa Where pvconceptopago.bitpagocancelafactura = 1 and pvconceptopago.intnumconcepto = pvconceptopagoempresa.intnumconcepto"
'
'331                   Set rsTemp = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
'332                   vlblnValidarDesglosarIVA = IIf(rsTemp!bitdesglosaiva = 0, False, True)
'333                   vllngConceptoPago = rsTemp!intnumconcepto
'334                   vllngNumeroCuenta = rsTemp!intNumeroCuenta
'
'335                   vgstrParametrosSP = vlstrFolioDocumento & "|" & _
'                                       CStr(lngMovPaciente) & "|" & _
'                                       IIf(strTipoPaciente = "I", "I", "E") & "|" & _
'                                       fstrFechaSQL(fdtmServerFecha, , True) & "|" & _
'                                       strNombreFactura & "|" & _
'                                       Format(vldblSumaaBancos, "############.00") & "|" & _
'                                       1 & "|" & _
'                                       0 & "|" & _
'                                       CStr(vgintNumeroDepartamento) & "|" & _
'                                       CStr(vllngPersonaGraba) & "|" & _
'                                       CStr(vllngNumeroCorte) & "|" & _
'                                       vllngConceptoPago & "|" & _
'                                       "Pago automático por cancelación de factura " & Trim(vlstrFolioFactura) & "|" & _
'                                       "NO" & "|" & _
'                                       IIf(vlblnValidarDesglosarIVA, 1, 0)
'
'336                   lngNumPagoSalida = 1
'337                   frsEjecuta_SP vgstrParametrosSP, "SP_PVINSPAGO", True, lngNumPagoSalida, , , True
'
'338                   If lngNumPagoSalida = 1 Then ' validamos si se tiene 1 por que trono o por si inserto el registro 1
'339                      Set ObjRS = frsRegresaRs("Select max(intnumpago) from pvpago", adLockOptimistic)
'340                          If ObjRS.RecordCount = 0 Then
'341                             lngNumPagoSalida = -1
'                          Else
'342                             If ObjRS.Fields(0) <> 1 Then lngNumPagoSalida = -1
'                          End If
'                   End If
'
'343                   If lngNumPagoSalida > -1 Then ' que continue con el proceso si se inserto el pago o la salida de dinero.
'                      '---------------------------------------------------------'
'                      ' Si es entrada de dinero abono a la cuenta del concepto, '
'                      '---------------------------------------------------------'
'                      ' Para validar si el parametro "Desglosar IVA en pagos" está activo '
'344                      If vlblnValidarDesglosarIVA Then
'                         '********** >>SI<< desglosar IVA **********'
'345                         dblCantidadConcepto = Val(Format(vldblSumaaBancos, "############.00"))
'346                         dblCantidadIVA = dblCantidadConcepto - dblCantidadConcepto / (1 + (vgdblCantidadIvaGeneral / 100))
'347                         dblCantidadConcepto = dblCantidadConcepto - dblCantidadIVA
'
'348                         pAgregarMovArregloCorte vllngNumeroCorte, vlstrFolioDocumento, "RE", vllngNumeroCuenta, _
'                                                 dblCantidadConcepto, 0, "", 0, 0, "", 0, 2, "", ""
'
'349                         pAgregarMovArregloCorte vllngNumeroCorte, vlstrFolioDocumento, "RE", glngCtaIVACobrado, _
'                                                 dblCantidadIVA, 0, "", 0, 0, "", 0, 2, "", ""
'
'                      Else
'                         '********** >>NO<< desglosar IVA **********'
'350                         dblCantidadConcepto = Val(Format(vldblSumaaBancos, "############.00"))
'351                         dblCantidadIVA = 0
'352                         dblCantidadConcepto = dblCantidadConcepto - dblCantidadIVA
'
'353                         pAgregarMovArregloCorte vllngNumeroCorte, vlstrFolioDocumento, "RE", vllngNumeroCuenta, _
'                                                 dblCantidadConcepto, 0, "", 0, 0, "", 0, 2, "", ""
'                      End If
'
'354                         pAgregarMovArregloCorte vllngNumeroCorte, vlstrFolioDocumento, "RE", lngCuentaPuenteBanco, _
'                                                 (dblCantidadConcepto + dblCantidadIVA), 1, "", 0, 0, "", 0, 2, "", ""
'
'                      '--------------------------------------------------------------------------------'
'                      '   Guarda movimientos en el corte (PvDetalleCorte)   '
'                      '--------------------------------------------------------------------------------'
'355                      If rsDCP.RecordCount > 0 Then
'356                         rsDCP.MoveFirst
'357                         Do While Not rsDCP.EOF
'358                            pAgregarMovArregloCorte vllngNumeroCorte, vlstrFolioDocumento, "RE", 0, (rsDCP!mnycantidadpagada), _
'                                                    False, (fdtmServerFecha + fdtmServerHora), rsDCP!intFormaPago, rsDCP!mnytipocambio, rsDCP!intfoliocheque, rsDCP!intNumCorteDocumento, _
'                                                    1, "", ""
'359                             rsDCP.MoveNext
'                         Loop
'                      Else
'360                         If rsPolizaenPuente.RecordCount > 0 Then
'361                            rsPolizaenPuente.MoveFirst
'362                            Do While Not rsPolizaenPuente.EOF
'363                               pAgregarMovArregloCorte vllngNumeroCorte, vlstrFolioDocumento, "RE", 0, (rsPolizaenPuente!mnycantidadpagada), _
'                                                       False, (fdtmServerFecha + fdtmServerHora), rsPolizaenPuente!intFormaPago, rsPolizaenPuente!mnytipocambio, rsPolizaenPuente!intfoliocheque, rsPolizaenPuente!intNumCorteDocumento, _
'                                                       1, "", ""
'364                                rsPolizaenPuente.MoveNext
'                            Loop
'                         End If
'                      End If
'                   End If
'                End If
'           End If
                       
           'se agregan los movimientos al corte
365           vllngCorteUsado = fRegistrarMovArregloCorte(vllngNumeroCorte)
        
224            If strFacturaPacienteEmpresa = "P" And dblNotas > 0 Then
                '-------------------------------------------'
                ' Activar las notas de crédito del paciente '
                '-------------------------------------------'
225                vlstrSentencia = "UPDATE CcNota SET chrEstatus = 'A' WHERE intMovPaciente = " & lngMovPaciente & _
                                " AND chrTipoPaciente = " & IIf(strTipoPaciente = "I", "'I'", "'E'") & _
                                " AND chrNotaDirigida = 'P' And bitAutomatica = 0 And chrEstatus = 'P' " & _
                                " AND Trim(vchFacturaImpresion) = '" & Trim(vlstrFolioFactura) & "'"
226                pEjecutaSentencia (vlstrSentencia)

227                If blncontrolaseguradora Then
                      '-------------------------------------------'
                      ' Cancelar las notas de crédito automáticas '
                      '-------------------------------------------'
228                   vlstrSentencia = "UPDATE CcNota SET chrEstatus = 'C', intPersonaBorra = " & CStr(vllngPersonaGraba) & _
                                    " WHERE intMovPaciente = " & lngMovPaciente & _
                                    " AND chrTipoPaciente = " & IIf(strTipoPaciente = "I", "'I'", "'E'") & _
                                    " AND chrNotaDirigida = 'P' AND bitAutomatica = 1 " & _
                                    " AND Trim(vchFacturaImpresion) = '" & Trim(vlstrFolioFactura) & "'"
229                   pEjecutaSentencia vlstrSentencia
                      'cancelamos la nota automatica en gncomprobantefiscaldigital también____________________________________________________________________
                      vlstrSentencia = "SELECT INTCONSECUTIVO, CHRFOLIONOTA FROM CcNota" & _
                                       " WHERE intMovPaciente = " & lngMovPaciente & _
                                       " AND chrTipoPaciente = " & IIf(strTipoPaciente = "I", "'I'", "'E'") & _
                                       " AND chrNotaDirigida = 'P' AND bitAutomatica = 1 " & _
                                       " AND Trim(vchFacturaImpresion) = '" & Trim(vlstrFolioFactura) & "'"
                      Set rsTemp = frsRegresaRs(vlstrSentencia, adLockOptimistic)
                      If rsTemp.RecordCount > 0 Then
                         rsTemp.MoveFirst
                         Do While Not rsTemp.EOF
                            frsEjecuta_SP rsTemp!intConsecutivo & "|CR" & "|" & fstrFechaSQL(fdtmServerFecha, fdtmServerHora), "SP_GNUPDCANCELACOMPROBANTEFIS"
                                  
                            pEjecutaSentencia ("INSERT INTO PVDocumentoCancelado VALUES('" & Trim(rsTemp!chrFolioNota) & "','NC'," & Trim(str(vgintNumeroDepartamento)) & "," & Trim(str(vllngPersonaGraba)) & ",getdate())")
                            
                            rsTemp.MoveNext
                         Loop
                      End If
                      rsTemp.Close
                        '______________

                      'Dejar el excedente por honorarios en 0
230                   vlstrSentencia = "UPDATE PvControlaseguradora SET mnyExcedenteHonorarioEx = 0, mnyExcedenteHonorarioDe = 0, mnyExcedenteHonorarioCo = 0, mnyExcedenteHonorarioCa = 0, mnyExcedenteHonorarioCp = 0 " & _
                                    " WHERE intMovPaciente = " & lngMovPaciente & _
                                    " AND chrTipoPaciente = " & IIf(strTipoPaciente = "I", "'I'", "'E'")
231                   pEjecutaSentencia vlstrSentencia
                   End If
              End If
        
366           If vllngCorteUsado = 0 Then
367              EntornoSIHO.ConeccionSIHO.RollbackTrans
              'No se pudieron agregar los movimientos de la operación al corte, intente de nuevo.
368              MsgBox SIHOMsg(1320), vbExclamation, "Mensaje"
              intlineaGoto = 368
              strError = SIHOMsg(1320)
              GoTo NotificaError
              'Exit Sub
           End If
                   
369           If vllngCorteUsado <> vllngNumeroCorte Then
370              vllngNumeroCorte = vllngCorteUsado
           End If
                                 
           '---------------------------------------------------------------------------'
           ' Quitar el cancelado de PAGOS (BitCancelado) y Quitar el numero de factura '
           '---------------------------------------------------------------------------'
371           vlstrSentencia = "UPDATE PvPago SET chrFolioFactura = NULL, bitCancelado = 0 " & _
                            " WHERE chrFolioFactura = '" & Trim(vlstrFolioFactura) & "'"
372           pEjecutaSentencia (vlstrSentencia)

           '----------------------------------------------------------------------------------'
           ' Quitar el cancelado de DEVOLUCIONES (BitCancelado) y Quitar el numero de factura '
           '----------------------------------------------------------------------------------'
373           vlstrSentencia = "UPDATE PvSalidaDinero SET chrFolioFactura = NULL, bitCancelado = 0 " & _
                         " WHERE chrFolioFactura = '" & Trim(vlstrFolioFactura) & "'"
374           pEjecutaSentencia (vlstrSentencia)

           '--------------------------------------'
           ' Actualiza PVPAQUETEPACIENTEFACTURADO '
           '--------------------------------------'
375           strParametros = lngMovPaciente & "|" & IIf(strTipoPaciente = "G", "'G'", IIf(strTipoPaciente = "I", "'I'", "'E'")) & "|" & Trim(vlstrFolioFactura)
376           frsEjecuta_SP strParametros, "SP_PVUPDPAQUETESFACTURADOS"


                    
           '----------------------------------------------'
           ' Se cancela el movimiento de la forma de pago '
           '----------------------------------------------'
           ' Si el BitCuentaPuenteBanco está activo y la factura no es a paciente si se cancela el movimiento
'377           If intBitCuentaPuenteBanco = 0 Or (intBitCuentaPuenteBanco = 1 And (vgstrFacturaPacienteEmpresa <> "P" And vgstrFacturaPacienteEmpresa <> "V")) Or (intBitCuentaPuenteBanco = 1 And vgstrFacturaPacienteEmpresa = "P" And (vgstrTipoFactura = "D" Or vgstrTipoFactura = "T")) Or (intBitCuentaPuenteBanco = 1 And vgstrFacturaPacienteEmpresa = "T" And vlintTotalTickets = 0) Then
'377              If intBitCuentaPuenteBanco = 0 Or (intBitCuentaPuenteBanco = 1 And (strFacturaPacienteEmpresa <> "P" And strFacturaPacienteEmpresa <> "V")) Or (intBitCuentaPuenteBanco = 1 And strFacturaPacienteEmpresa = "P" And (strTipoFactura = "D" Or strTipoFactura = "T")) Or (intBitCuentaPuenteBanco = 1 And strFacturaPacienteEmpresa = "T" And vlintTotalTickets = 0) Then
377        If intBitCuentaPuenteBanco = 0 _
            Or (intBitCuentaPuenteBanco = 1 And strTipoFactura = "N" And strFacturaPacienteEmpresa = "E" Or strFacturaPacienteEmpresa = "P") _
            Or (intBitCuentaPuenteBanco = 1 And strTipoFactura = "D") Then
378              vlstrSentencia = "SELECT MB.intFormaPago, MB.chrTipoMovimiento, MB.mnyCantidad, MB.mnyTipoCambio," & _
                    " FP.chrTipo, ISNULL(B.tnyNumeroBanco, MB.intCveBanco) AS IdBanco, mb.chrtipomovimiento " & _
                    " FROM PvMovimientoBancoForma MB " & _
                    " INNER JOIN PvFormaPago FP ON MB.intFormaPago = FP.intFormaPago " & _
                    " LEFT  JOIN CpBanco B ON B.intNumeroCuenta = FP.intCuentaContable " & _
                    " WHERE TRIM(MB.chrTipoDocumento) = 'FA' AND MB.intNumDocumento = " & lngConsecutivoFactura & _
                    " AND (MB.intNumCorte = " & vllngNumCorteFactura & " OR " & vllngNumCorteFactura & " = -1) " & _
                    " AND ((mb.mnycantidad > 0 AND mb.chrtipomovimiento <> 'CBA') " & _
                           " OR (mb.mnycantidad < 0 AND mb.chrtipomovimiento = 'CBA')) "
           
379              Set rsTemp = frsRegresaRs(vlstrSentencia)
380              If Not rsTemp.EOF Then
381                 rsTemp.MoveFirst
382                 Do While Not rsTemp.EOF
383                    If rsTemp!chrTipo <> "C" Then
384                       strFecha = fstrFechaSQL(fdtmServerFecha, fdtmServerHora) '- Fecha y hora del movimiento -'
                           '- Revisar tipo de movimiento para determinar la cancelación -'
                           If rsTemp!chrTipoMovimiento = "CBA" Then
                                strTipoDoc = "CCB"                 'Comisión bancaria
                           Else
385                             Select Case rsTemp!chrTipoMovimiento
                                    '- Movimientos de facturación -'
                                    Case "EFF": strTipoDoc = "CEF"   'Efectivo en factura
                                    Case "TAF": strTipoDoc = "CJF"   'Tarjeta de crédito en factura
                                    Case "TPF": strTipoDoc = "CTF"   'Transferencia bancaria en factura
                                    Case "CHF": strTipoDoc = "CQF"   'Cheque en factura
                                    '- Movimientos de venta al público -'
                                    Case "EFV": strTipoDoc = "CFV"   'Efectivo en venta al público
                                    Case "TAV": strTipoDoc = "CJV"   'Tarjeta de crédito en venta al público
                                    Case "TPV": strTipoDoc = "CTV"   'Transferencia bancaria en venta al público
                                    Case "CQV": strTipoDoc = "CCV"   'Cheque en venta al público
                                    '- Movimientos de facturación directa -'
                                    Case "EFC": strTipoDoc = "CEC"   'Efectivo en factura de cliente
                                    Case "TAC": strTipoDoc = "CJC"   'Tarjeta de crédito en factura de cliente
                                    Case "TCL": strTipoDoc = "CTC"   'Transferencia bancaria en factura de cliente
                                    Case "CHC": strTipoDoc = "CQC"   'Cheque en factura de cliente
                                End Select
                            End If
394                         dblCantidad = rsTemp!MNYCantidad * (-1) 'Cantidad negativa para que se tome como abono
        
                            '- Guardar información en tabla intermedia -'
395                         strParametros = vllngNumeroCorte & _
                                     "|" & strFecha & _
                                     "|" & rsTemp!intFormaPago & _
                                     "|" & rsTemp!IdBanco & _
                                     "|" & dblCantidad & _
                                     "|" & IIf(rsTemp!mnytipocambio = 0, 1, 0) & _
                                     "|" & rsTemp!mnytipocambio & _
                                     "|" & strTipoDoc & _
                                     "|" & "FA" & _
                                     "|" & lngConsecutivoFactura & _
                                     "|" & vllngPersonaGraba & _
                                     "|" & vgintNumeroDepartamento & _
                                     "|" & strFecha & "|" & "1" & "|" & cgstrModulo
396                         frsEjecuta_SP strParametros, "Sp_PvInsMovimientoBancoForma"
                        End If
397                     rsTemp.MoveNext
                    Loop
                End If
398             rsTemp.Close
           End If
                     
           '---------------------------------------------------------------------------------------------------------------------
399           Call pGuardarLogTransaccion(strNombreForma, EnmGrabar, vllngPersonaGraba, "CANCELACION DE FACTURA", vlstrFolioFactura)
            
           '--------------------------------------------------------------
           'Eliminamos la factura de la tabla de pendientes de cancelación
           '--------------------------------------------------------------
400           If QuitarPendienteTimbre Then pEliminaPendientesTimbre lngConsecutivoFactura, "FA"
                      
           '-------------------------------'
           ' Darle COMMIT a la TRANSACTION '
           '-------------------------------'
401           EntornoSIHO.ConeccionSIHO.CommitTrans

           ''''''''''''''''''''''''''''''''''''''''
           'mensaje de confirmación de cancelacion'
           ''''''''''''''''''''''''''''''''''''''''
402           If Mostrarmensaje Then pMensajeCanelacionCFDi lngConsecutivoFactura, "FA"
    Else
        'Para poder cancelar una factura parcial, antes se tiene que cancelar la factura base
403        MsgBox SIHOMsg(634), vbOKOnly + vbInformation, "Mensaje"
           intlineaGoto = 403
           strError = SIHOMsg(364)
           GoTo NotificaError
    End If
Exit Sub
NotificaError:
    If Err.Number <> 0 Then 'error de código
       If Erl() > 112 And Erl() < 402 Then 'hacer el rollback
          Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":PcancelarFactura"))
       Else 'no hacer rollback
          frsEjecuta_SP Err.Number & "|" & Left(Err.Description, 200) & "|" & cgstrModulo & "|" & "PCancelarFactura" & " Linea:" & Erl() & "|" & "", "SP_GNINSREGISTROERRORES", True
       End If
    Else 'viene de un goto
          frsEjecuta_SP -1 & "|" & Left(strError, 200) & "|" & cgstrModulo & "|" & "PCancelarFactura" & " Linea:" & intlineaGoto & "|" & "", "SP_GNINSREGISTROERRORES", True
    End If
End Sub

Public Sub pEliminaPendientesTimbre(lngId As Long, strTipo As String)
Dim strSentencia As String

On Error GoTo NotificaError
1    strSentencia = "Delete from gnPendientesTimbreFiscal where INTCOMPROBANTE = " & lngId & " and CHRTIPOCOMPROBANTE = '" & strTipo & "'"
2    pEjecutaSentencia strSentencia
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pEliminarPendientesTimbre" & " Linea:" & Erl()), CStr(lngId) & " " & strTipo, False)
    Err.Clear
End Sub

Public Function fblnGeneraCFDpCancelacion(lngComprobante As Long, strTipo As String, blnCFDI As Boolean, lngCveAddenda As Long) As Boolean
    
    Dim strSentencia As String
    Dim RsComprobante As New ADODB.Recordset
    Dim stmComprobante As New ADODB.Stream
    Dim lngError As Long
    Dim strContrasena As String
    Dim strNombreBase As String
    Dim strArchivoXMLFirmado As String
    Dim strArchivoXMLRequestTimbrado As String
    Dim strArchivoLlave As String
    Dim strArchivoCertificado As String
    Dim strComprobanteFiscalFirmado As String
    Dim strCadenaOriginal As String
    Dim strSello As String
    Dim strCertificadoString As String
    Dim fsoComprobante As New FileSystemObject
    Dim tsComprobante As TextStream
    Dim strLinea As String
    Dim strArchivoXMLBase As String
    Dim strDestino As String
    Dim intAno As Integer
    Dim strParametros As String
    Dim XMLSolicitudTimbrado As MSXML2.DOMDocument
    Dim strArchivoXMLFirmadoTimbrado As String
    Dim UUID As String
    Dim strCFDiTimbrado As String
    Dim strNoCertificadoSAT As String
    Dim strSelloSAT As String
    Dim strFechaTimbrado As String
    Dim strCadenaTFD As String
    Dim RefID As String     'Identificador de CFDi, para el archivo Request Timbrado (RFC Emisor (3 primeros y 3 últimos) + Tipo + Serie||Folio)
    Dim vlaryParametrosSalida() As String
    Dim strComplementoAddenda As String
    Dim XMLAddendado As MSXML2.DOMDocument
    Dim strCFDaddendado As String
    Dim rsPAC As New ADODB.Recordset
    Dim intPAC As Integer
    Dim lngTiempoRestanteHrs As Long
    Dim lngTiempoRestanteMins As Long
    Dim strTiempoRestanteTotal As String
    Dim strError As String 'Esta variable almacena el proceso en el cual se presenta un error, para poder ser detectado más rápidamente
    Dim blnMostrarMsjNotificaError As Boolean 'Esta varialble indica si se mostrará un mensaje de error, en caso de que se presente alguno
    
    'Sistema
    Dim strFechaHoraServer As String
    Dim strFechaServer As String
    Dim strHoraServer As String
    Dim strFechaHoraServerLetra As String
    
    'Certificado
    Dim strCerRFC As String
    Dim strCerFechaHoraValidaDesde As String
    Dim strCerFechaHoraValidaDesdeLetra As String
    Dim strCerFechaValidaDesde As String
    Dim strCerHoraValidaDesde As String
    Dim strCerFechaHoraValidaHasta As String
    Dim strCerFechaHoraValidaHastaLetra As String
    Dim strCerFechaValidaHasta As String
    Dim strCerHoraValidaHasta As String
    Dim strCerEmpresaEmisora As String
    Dim strCerNumCertificado As String
    Dim intlineaGoto As Integer
    Dim vlblnCFDiTimbrado As Boolean
    
On Error GoTo NotificaError:
    vlblnCFDiTimbrado = False
    vgIntBanderaTImbradoPendiente = 0
    CFDiblnHaytimbre = False     ' no hay timbre
    CFDiblnBanError = False      ' no hay error
    CFDistrProcesoError = ""     ' no hay proceso de error
    CFDiintLineaError = 0        ' no hay linea de error
    CFDilngNumError = 0          ' no hay error
    CFDistrDescripError = ""     ' no hay descripcion de error
    CFDiintResultadoTimbrado = 0 ' el proceso esta en su inicio, si al final sigue en 0 quiere decir que todo salió bien
    intlineaGoto = 0             ' linea en la que se activa el GOTO(esta variable es local)
    'Se obtienen fecha y hora (formateadas) del servidor para las validaciones de la vigencia del certificado
1    strFechaHoraServer = Format(fdtmServerFechaHora, "DD/MM/YYYY HH:MM:SS")
2    strFechaServer = Mid(strFechaHoraServer, 1, 10)
3    strHoraServer = Mid(strFechaHoraServer, 12)
4    strFechaHoraServerLetra = Mid(strFechaHoraServer, 1, 3) & fstrMesLetra(Mid(strFechaHoraServer, 4, 2), False) & Mid(strFechaHoraServer, 6)
     'Se elimina el contenido de la carpeta temporal
5    strDestino = Environ$("temp") & "\dA-Ms19"
6    pCreaDirectorio strDestino
7    On Error Resume Next
     'Checa que el directorio se haya creado, para proceder a eliminar el archivo (evita el error 53)
8    If Dir$(strDestino & "\") <> "" Then
9        Kill strDestino & "\*.*"
10       If Err.Number = 53 Or Err.Number = 0 Then '|  File not found
11          Err.Clear
         Else
12          Err.Raise Err.Number
         End If
     End If
     '|Inicializa nombre de archivos de trabajo y variables de control
13   strNombreBase = strDestino & "\" & strTipo & "_" & lngComprobante
14   strArchivoXMLBase = strNombreBase & ".xml"
15   strArchivoXMLFirmado = strNombreBase & "Firmado.xml"
16   strArchivoXMLRequestTimbrado = strNombreBase & "RequestTimbrado.xml"
17   strArchivoXMLFirmadoTimbrado = strNombreBase & "Firmado_Timbrado.xml"
18   strArchivoLlave = strNombreBase & ".key"
19   strArchivoCertificado = strNombreBase & ".cer"
20   strError = ""
21   blnMostrarMsjNotificaError = True
     '|Descarga archivo XML firmado en directorio local del cliente
22   If Not fblnDescargaXML(lngComprobante, strTipo, strArchivoXMLBase, "PVCANCELARCOMPROBANTES") Then 'Exit Function
23        intlineaGoto = 25
24        blnMostrarMsjNotificaError = False
25        GoTo NotificaError
     End If
     '|Consulta archivo .CER, .KEY y Contraseña almacenado en la base de datos
26   strSentencia = "SELECT BLBCERTIFICADO " & _
                   "     , BLBLLAVE " & _
                   "     , VCHCONTRASENA " & _
                   "     , VCHRFC " & _
                   "  FROM CNEMPRESACONTABLE " & _
                   " WHERE CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable
27   Set RsComprobante = frsRegresaRs(strSentencia)
     
     '|Descarga archivo Certificado en directorio local del cliente
28   If Not IsNull(RsComprobante!BLBCERTIFICADO) Then
29      With stmComprobante
30           .Type = adTypeBinary
31           .Open
32           .Write RsComprobante!BLBCERTIFICADO
33           .SaveToFile strArchivoCertificado, adSaveCreateOverWrite
34           .Close
35      End With
        'Se digiere el contenido del certificado...
36      strError = "Error en la digestión del archivo .CER"
37      strCerRFC = Trim(satQueryCert(strArchivoCertificado, "rfc"))
38      strCerRFC = Trim(Replace(Replace(Replace(strCerRFC, "-", ""), "_", ""), " ", ""))
39      strCerNumCertificado = Trim(satQueryCert(strArchivoCertificado, "serialNumber"))
40      strCerEmpresaEmisora = Trim(satQueryCert(strArchivoCertificado, "organizationName"))
41      strCerFechaHoraValidaDesde = Trim(satQueryCert(strArchivoCertificado, "notBefore"))
42      strCerFechaHoraValidaHasta = Trim(satQueryCert(strArchivoCertificado, "notAfter"))
        'Formateo y desglose de las fechas y horas del certificado
43      strError = "Error de formateo de las fecha de vigencia del certificado"
44      strCerFechaHoraValidaDesde = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaDesde, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaDesde, 12, 8)
45      strCerFechaValidaDesde = Mid(strCerFechaHoraValidaDesde, 1, 10)
46      strCerHoraValidaDesde = Mid(strCerFechaHoraValidaDesde, 12)
47      strCerFechaHoraValidaDesdeLetra = Mid(strCerFechaHoraValidaDesde, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaDesde, 4, 2), False) & Mid(strCerFechaHoraValidaDesde, 6)
48      strCerFechaHoraValidaHasta = Trim(Replace(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 3, 4), "/" & Mid(Format(CDate(Mid(strCerFechaHoraValidaHasta, 1, 10)), "DD/MM/YYYY"), 4, 2) & "/")) & " " & Mid(strCerFechaHoraValidaHasta, 12, 8)
49      strCerFechaValidaHasta = Mid(strCerFechaHoraValidaHasta, 1, 10)
50      strCerHoraValidaHasta = Mid(strCerFechaHoraValidaHasta, 12)
51      strCerFechaHoraValidaHastaLetra = Mid(strCerFechaHoraValidaHasta, 1, 3) & fstrMesLetra(Mid(strCerFechaHoraValidaHasta, 4, 2), False) & Mid(strCerFechaHoraValidaHasta, 6)
        'Validaciones simples del archivo .CER
        'Si se utiliza un certificado de pruebas, se omiten las validaciones
53      If strCerRFC <> "ACO560518KW7" Then
54           If strCerRFC = "" Then 'Si el RFC del certificado está vació, significa que no se ha instalado el complemento de sellado (librerías de FirmaSAT en system32)
55              MsgBox SIHOMsg(1) & "." & vbCrLf & vbCrLf & "No se detectó el complemento de sellado de comprobantes. ", vbCritical, "Mensaje"
56              strError = "No se detectó el complemento de sellado de comprobantes."
57              blnMostrarMsjNotificaError = False
                intlineaGoto = 58
58              GoTo NotificaError
59           ElseIf strCerRFC <> Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) Then 'Compara el RFC del certificado vs el RFC de la empresa contable
60                  MsgBox "El certificado configurado en el sistema no corresponde a la empresa contable emisora: " & vbNewLine & vbNewLine & _
                                                        "- RFC de la empresa:" & vbTab & Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) & vbNewLine & _
                                                        "- RFC del certificado:" & vbTab & strCerRFC, vbCritical + vbOKOnly, "Mensaje"
61                  strError = "El certificado configurado en el sistema no corresponde a la empresa contable emisora"
62                  blnMostrarMsjNotificaError = False
                    intlineaGoto = 63
63                  GoTo NotificaError
64           ElseIf CDate(strCerFechaValidaDesde) > CDate(strFechaServer) Then 'La fecha de inicio validez del certificado aún no entra en vigor
65                  MsgBox "El certificado configurado en el sistema aún no entra en su período de validez: " & vbNewLine & vbNewLine & _
                                                        "- Válido a partir de:" & vbTab & strCerFechaHoraValidaDesdeLetra & vbNewLine & _
                                                        "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
66                  strError = "El certificado configurado en el sistema aún no entra en período de validez"
67                  blnMostrarMsjNotificaError = False
                    intlineaGoto = 68
68                  GoTo NotificaError
69           ElseIf CDate(strCerFechaValidaHasta) < CDate(strFechaServer) Then 'La fecha de expiración del certificado ha excedido su validez
70                  MsgBox "El certificado configurado en el sistema excede su período de validez: " & vbNewLine & vbNewLine & _
                                                        "- Válido hasta el:" & vbTab & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                                        "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
71                  strError = "El certificado configurado en el sistema excede su período de validez"
72                  blnMostrarMsjNotificaError = False
                    intlineaGoto = 73
73                  GoTo NotificaError
74           ElseIf CDate(strCerFechaValidaDesde) = CDate(strFechaServer) Then 'La fecha de inicio de validez del certificado es igual a la fecha actual
75                    If Format(CDate(strCerHoraValidaDesde), "HH:MM:SS") > Format(CDate(strHoraServer), "HH:MM:SS") Then 'Se compara la hora de inicio de validez con la hora actual
76                       MsgBox "El certificado configurado en el sistema aún no entra en su período de validez: " & vbNewLine & vbNewLine & _
                                                            "- Válido a partir de:" & vbTab & strCerFechaHoraValidaDesdeLetra & vbNewLine & _
                                                            "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
77                       strError = "El certificado configurado en el sistema aún no entra en período de validez"
78                       blnMostrarMsjNotificaError = False
79                       intlineaGoto = 80
80                       GoTo NotificaError
                    End If
81           ElseIf CDate(strCerFechaValidaHasta) = CDate(strFechaServer) Then 'La fecha de expiración del certificado es igual a la fecha actual
82                    If Format(CDate(strCerHoraValidaHasta), "HH:MM:SS") > Format(CDate(strHoraServer), "HH:MM:SS") Then 'Certificado válido por pocas horas
83                       lngTiempoRestanteHrs = DateDiff("h", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
84                       lngTiempoRestanteMins = DateDiff("n", Format(CDate(strHoraServer), "HH:MM:SS"), Format(CDate(strCerHoraValidaHasta), "HH:MM:SS"))
85                       strTiempoRestanteTotal = CStr(lngTiempoRestanteHrs) & " horas " & CStr(Abs(lngTiempoRestanteMins - (60 * lngTiempoRestanteHrs))) & " minutos!"
86                       MsgBox "¡El certificado expirará en " & strTiempoRestanteTotal & ", por favor solicite uno nuevo al SAT.", vbExclamation, "Mensaje"
                      Else 'Certificado expirado
87                       MsgBox "El certificado configurado en el sistema excede su período de validez: " & vbNewLine & vbNewLine & _
                                                            "- Válido hasta el:" & vbTab & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                                            "- Fecha del sistema:" & vbTab & strFechaHoraServerLetra, vbCritical + vbOKOnly, "Mensaje"
88                       strError = "El certificado configurado en el sistema excede su período de validez"
89                       blnMostrarMsjNotificaError = False
                         intlineaGoto = 90
90                       GoTo NotificaError
                    End If
                End If
            Else
91              If fblnAutoVerificacion Then
                   'Este mensaje es para que los clientes se percaten de que estén utilizando un certificado de pruebas
                   '(Solamente se mostrará, si se tiene habilitado el bit de autoverificación y si el esquema en el que se está probando, no es un esquema SiC (RFC = CSI040928HX4))
92                   If Trim(Replace(Replace(Replace(RsComprobante!vchRFC, "-", ""), "_", ""), " ", "")) <> "CSI040928HX4" Then
93                      MsgBox "Se está utilizando un certificado de pruebas: " & vbNewLine & vbNewLine & _
                                        "- RFC del certificado:  " & strCerRFC & vbNewLine & _
                                        "- Válido del  " & strCerFechaHoraValidaDesdeLetra & " al " & strCerFechaHoraValidaHastaLetra & vbNewLine & _
                                        "- Número de certificado:  " & strCerNumCertificado & vbNewLine & _
                                        "- Empresa certificadora:  " & strCerEmpresaEmisora, vbInformation + vbOKOnly, "Mensaje"
                    End If
                End If
            End If
      Else
94        strError = "No se ha configurado un archivo de certificado .CER para emitir comprobantes fiscales digitales"
          intlineaGoto = 95
95        GoTo NotificaError
      End If
      '|  Descarga archivo .KEY en directorio local del cliente
96    If Not IsNull(RsComprobante!BLBLLAVE) Then
97       With stmComprobante
98            .Type = adTypeBinary
99            .Open
100            .Write RsComprobante!BLBLLAVE
101            .SaveToFile strArchivoLlave, adSaveCreateOverWrite
102            .Close
103      End With
      Else
104        strError = "No existe configurada un archivo llave .KEY para emitir facturas comprobantes fiscales digitales"
           intlineaGoto = 106
105        GoTo NotificaError
      End If
      '|Almacena contraseña
106   If Not IsNull(RsComprobante!vchContrasena) Then
107        strContrasena = fstrEncrypt2(fstrConvierteChr(RsComprobante!vchContrasena), RsComprobante!vchRFC)
      Else
108        strError = "No existe configurada una contraseña para emitir facturas comprobantes fiscales digitales"
           intlineaGoto = 110
109        GoTo NotificaError
      End If
      'Se valida que los archivos .CER, .KEY y la contraseña sean correctos...
110   lngError = SAT_CheckKeyAndCert(strArchivoLlave, strContrasena, strArchivoCertificado, 0)
111   If lngError <> 0 Then
112      strError = fstrErrorFirmaSAT(lngError)
         intlineaGoto = 113
113      GoTo NotificaError
      End If
      
      '---------------------------------------------------------------------
      '|Genera XML firmado y decodifica Certificado, Cadena original y Sello
      '---------------------------------------------------------------------
      
      '|Genera XML firmado
114    intAno = Year(fdtmServerFecha)
115    lngError = SAT_SignXml(strArchivoXMLFirmado, strArchivoXMLBase, strArchivoLlave, strContrasena, strArchivoCertificado, IIf(intAno = 2010, SAT_HASH_MD5, SAT_HASH_SHA1))
116    If lngError <> 0 Then
117       strError = fstrErrorFirmaSAT(lngError)
          intlineaGoto = 118
118       GoTo NotificaError
       End If
      '|Valida el sello
119    lngError = SAT_VerifySignature(strArchivoXMLFirmado, strArchivoCertificado, 0)
120    If lngError <> 0 Then
121       strError = fstrErrorFirmaSAT(lngError)
          intlineaGoto = 122
122       GoTo NotificaError
       End If
      '|Valida que el XML generado este correcto
123    lngError = SAT_ValidateXml(strArchivoXMLFirmado, 0)
124    If lngError <> 0 Then
125       strError = fstrErrorFirmaSAT(lngError)
          intlineaGoto = 126
126       GoTo NotificaError
       End If
      '|Obtiene cadena original
127    strCadenaOriginal = fstrCadenaOriginal(strArchivoXMLFirmado, blnCFDI)
128    If Len(strCadenaOriginal) = 0 Then
129       blnMostrarMsjNotificaError = False
          intlineaGoto = 130
130       GoTo NotificaError
       End If
      '|Extrae el string del certificado
131    strCertificadoString = satGetCertAsString(strArchivoXMLFirmado)
132    If Len(strCertificadoString) = 0 Then
          '|No se pudo extraer el string del certificado del comprobante generado. ¡Avisar al área de sistemas!
133        MsgBox SIHOMsg(1085), vbCritical, "Mensaje"
134        blnMostrarMsjNotificaError = False
           intlineaGoto = 135
135        GoTo NotificaError
       End If
       '|Obtiene sello digital
136     strSello = satMakeSignatureFromXml(strArchivoXMLBase, strArchivoLlave, strContrasena)
137    If Len(strSello) = 0 Then
          '|No se pudo obtener el sello digital del comprobante generado. ¡Avisar al área de sistemas!
138       MsgBox SIHOMsg(1028), vbCritical, "Mensaje"
139       blnMostrarMsjNotificaError = False
          intlineaGoto = 140
140       GoTo NotificaError
       End If
       
       '-----------------------------------------------------------------------------
       '|Inserta XML firmado, Cadena original y Sello en GNCOMPROBANTEFISCALDIGITAL
       '-----------------------------------------------------------------------------
141    strComprobanteFiscalFirmado = fstrConvierteArchivoUTF8(strArchivoXMLFirmado)
      
       '|Actualiza la tabla
       strSentencia = "SELECT CHRFOLIOCOMPROBANTE, VCHRFCEMISOR, CLBCOMPROBANTEFISCAL" & _
                      "  FROM PVCANCELARCOMPROBANTES " & _
                      " WHERE PVCANCELARCOMPROBANTES.INTCOMPROBANTE = " & lngComprobante & _
                      "   AND PVCANCELARCOMPROBANTES.vchTIPOCOMPROBANTE = '" & strTipo & "'"
       Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)

142    RefID = "CSI1209" & Trim(Left(Trim(RsComprobante!VCHRFCEMISOR), 3) & Right(Trim(RsComprobante!VCHRFCEMISOR), 3)) & Trim(strTipo) & lngComprobante & Trim(IIf(IsNull(RsComprobante!CHRFOLIOCOMPROBANTE), "", Trim(RsComprobante!CHRFOLIOCOMPROBANTE)))
          
143    If blnCFDI Then
          '--------------------------------------
          '|Inicia el proceso de timbrado de CFDi
          '--------------------------------------
        
          'Se carga el XML para solicitar el request de timbrado
144        Set XMLSolicitudTimbrado = New MSXML2.DOMDocument
145        XMLSolicitudTimbrado.Load (strArchivoXMLFirmado)
           'Se ejecuta el proceso de timbrado...
146        strError = "Error en el proceso de timbrado"
147        TimbrarCFDI XMLSolicitudTimbrado, RefID, strArchivoXMLRequestTimbrado
           'Se validan los error en el proceso de timbrado
148        If CFDiblnBanError Then
149           CFDiblnBanError = False
              intlineaGoto = 150 '*
150           GoTo NotificaError
           End If
           'Se graba el archivo timbrado FINAL en la carpeta temporal
151        XMLSolicitudTimbrado.Save strArchivoXMLFirmadoTimbrado
           'Se asigna el valor del UUID a la variable para el mensaje
152        UUID = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@UUID").Text
           'Validación del mensaje de error en base al PAC configurado:
153        If Trim(UUID) = "" Then
              intlineaGoto = 154
154           GoTo NotificaError
           End If
          '---------------------------------------------------
          '|  Se graba el contenido del XML en strCFDiTimbrado
          '---------------------------------------------------
155        strError = "Error al codificar a UTF8 el comprobante fiscal digital firmado"
156        strCFDiTimbrado = fstrConvierteArchivoUTF8(strArchivoXMLFirmadoTimbrado)
          '|Se obtienen los datos obtenidos con el timbre (incluyendo el UUID)
157        strError = "Error al extraer el contenido del complemento de timbrado"
           If vgstrVersionCFDI = "3.2" Then
158          strNoCertificadoSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@noCertificadoSAT").Text
159          strSelloSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@selloSAT").Text
           Else
             strNoCertificadoSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@NoCertificadoSAT").Text
             strSelloSAT = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@SelloSAT").Text
           End If
160        strFechaTimbrado = XMLSolicitudTimbrado.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@FechaTimbrado").Text
          'Se formatea la fecha de timbrado
161        strError = "Error al formatear la fecha de timbrado"
162        strFechaTimbrado = Mid(strFechaTimbrado, 9, 2) & "/" & fstrMesLetra(Mid(strFechaTimbrado, 6, 2), False) & "/" & Mid(strFechaTimbrado, 1, 4) & "  " & Mid(strFechaTimbrado, 12, 8)
          'Se obtiene la cadena del complemento TFD
163        strCadenaTFD = fstrCadenaOriginalTFD(strArchivoXMLFirmadoTimbrado)
164        If Len(strCadenaTFD) = 0 Then
165           blnMostrarMsjNotificaError = False
              intlineaGoto = 166
166           GoTo NotificaError
           End If
          '|Actualiza la tabla PVCANCELARCOMPROBANTES con lo datos obtenidos
           strSentencia = "SELECT VCHUUID, CLBCOMPROBANTEFISCAL" & _
                          "  FROM PVCANCELARCOMPROBANTES " & _
                          " WHERE PVCANCELARCOMPROBANTES.INTCOMPROBANTE = " & lngComprobante & _
                          "   AND PVCANCELARCOMPROBANTES.vchTIPOCOMPROBANTE = '" & strTipo & "'"
                       
167        Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
168        With RsComprobante
                'inserta el siguiente encabezado si es que no lo tiene el xml <?xml version="1.0" encoding="UTF-8"?>
169             If InStr(1, strCFDiTimbrado, "<?xml version=" & Chr(34) & "1.0" & Chr(34) & " encoding=" & Chr(34) & "UTF-8" & Chr(34) & "?>", 1) = 0 Then
170                strCFDiTimbrado = "<?xml version=" & Chr(34) & "1.0" & Chr(34) & " encoding=" & Chr(34) & "UTF-8" & Chr(34) & "?>" & Chr(13) & strCFDiTimbrado
                End If
171             !CLBCOMPROBANTEFISCAL = strCFDiTimbrado 'GUARDAR EL XML COMO QUEDÓ
172             !VCHUUID = UUID
173             .Update
           End With
           '-----------------------------------------------------------------------------------------------------------------------------------------------------------
           '|Actualiza la tabla GNCOMPROBANTEFISCALDIGITAL con lo datos obtenidos
174        strSentencia = "SELECT CLBCFDITIMBRADO, VCHCERTIFICADOSAT, VCHSELLOSAT, VCHFECHATIMBRADO, VCHUUID, VCHCADENATFD" & _
                          "  FROM GNCOMPROBANTEFISCALDIGITAL " & _
                          " WHERE GNCOMPROBANTEFISCALDIGITAL.INTCOMPROBANTE = " & lngComprobante & _
                          "   AND GNCOMPROBANTEFISCALDIGITAL.CHRTIPOCOMPROBANTE = '" & strTipo & "'"
            
                       
175        Set RsComprobante = frsRegresaRs(strSentencia, adLockOptimistic, adOpenDynamic)
176        If RsComprobante.RecordCount > 0 Then
177           With RsComprobante
                  'inserta el siguiente encabezado si es que no lo tiene el xml <?xml version="1.0" encoding="UTF-8"?>
178                If InStr(1, strCFDiTimbrado, "<?xml version=" & Chr(34) & "1.0" & Chr(34) & " encoding=" & Chr(34) & "UTF-8" & Chr(34) & "?>", 1) = 0 Then
179                   strCFDiTimbrado = "<?xml version=" & Chr(34) & "1.0" & Chr(34) & " encoding=" & Chr(34) & "UTF-8" & Chr(34) & "?>" & Chr(13) & strCFDiTimbrado
180                End If
181                !CLBCFDITIMBRADO = strCFDiTimbrado 'En los CFDi si se conserva la cadena completa, por eso se eliminó el MID de arriba
182                !VCHCERTIFICADOSAT = strNoCertificadoSAT
183                !VCHSELLOSAT = strSelloSAT
184                !VCHFECHATIMBRADO = strFechaTimbrado
185                !VCHUUID = UUID
186                !VCHCADENATFD = strCadenaTFD
187                .Update
188            End With
           End If
       End If
       '|Elimina archivos de trabajo
189    If fsoComprobante.FileExists(strArchivoXMLBase) Then fsoComprobante.DeleteFile strArchivoXMLBase
190    If fsoComprobante.FileExists(strArchivoXMLFirmado) Then fsoComprobante.DeleteFile strArchivoXMLFirmado
191    If fsoComprobante.FileExists(strArchivoLlave) Then fsoComprobante.DeleteFile strArchivoLlave
192    If fsoComprobante.FileExists(strArchivoCertificado) Then fsoComprobante.DeleteFile strArchivoCertificado
193    If fsoComprobante.FileExists(strArchivoXMLFirmadoTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLFirmadoTimbrado
194    If fsoComprobante.FileExists(strArchivoXMLRequestTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLRequestTimbrado
195    fblnGeneraCFDpCancelacion = True
196    strError = ""
197    Exit Function
    
NotificaError:

       If Not CFDiblnBanError Then 'si no existe otro error anterior
              CFDiblnBanError = True
              If Err.Number <> 0 Then 'llega como error del código
                 CFDistrProcesoError = "fblnGeneraCFDpCancelacion"
                 CFDiintLineaError = Erl()
                 CFDistrDescripError = Err.Description
                 CFDilngNumError = Err.Number
                 CFDiMostrarMensajeError = True
                 Err.Clear
              Else 'llega de un goto
                 If intlineaGoto = 150 Or intlineaGoto = 154 Then
                    If blnNOMensajeErrorPAC = False And CFDiintResultadoTimbrado = 1 Then
                       'Se obtiene el PAC con el que se realizó el proceso de timbrado (Buzón Fiscal: INTIDPAC = 1) (PAX: INTIDPAC = 2)
                       Set rsPAC = frsEjecuta_SP(CStr(vgintClaveEmpresaContable), "SP_GNSELCONFIGPAC")
                       If rsPAC.RecordCount > 0 Then
                          intPAC = Val(rsPAC!PAC)
                          Select Case intPAC
                                 Case 1 '(Buzón Fiscal: INTIDPAC = 1)
                                      MsgBox "No se pudo timbrar el CFDi, verifique lo siguiente antes de intentar de nuevo: " & vbNewLine & vbNewLine & _
                                                           "1. Que exista una conexión a Internet." & vbNewLine & _
                                                           "2. Las configuraciones de conexión del PAC sean correctas." & vbNewLine & _
                                                           "3. Si el PAC requiere un certificado X.509: " & vbNewLine & _
                                                           "    a) Que el certificado esté instalado en el equipo." & vbNewLine & _
                                                           "    b) Que el certificado esté vigente." & vbNewLine & _
                                                           "    c) Que el certificado esté relacionado con el RFC emisor/donatario.", vbExclamation + vbOKOnly, "Mensaje"
                                 Case 2 '(PAX: INTIDPAC = 2)
                                      MsgBox "No se pudo timbrar el CFDi, verifique lo siguiente antes de intentar de nuevo: " & vbNewLine & vbNewLine & _
                                                           "1. Que exista una conexión a Internet." & vbNewLine & _
                                                           "2. Las configuraciones de conexión del PAC sean correctas.", vbExclamation + vbOKOnly, "Mensaje"
                          End Select
                       Else
                           '|¡No se ha configurado un PAC activo para realizar el servicio de timbrado!
                           MsgBox SIHOMsg(1155), vbCritical, "Mensaje"
                       End If
                    End If
                    If intlineaGoto = 154 Then 'no se encontró el uuid, se muestra mensaje de configuración del PAC
                       CFDistrProcesoError = "fblnGeneraCFDpCancelacion"
                       CFDiintLineaError = 166
                       CFDistrDescripError = "Error de configuración del PAC"
                       CFDilngNumError = -1
                       CFDiMostrarMensajeError = False
                    End If
                 Else 'de cualquier otra linea goto
                    CFDistrProcesoError = "fblnGeneraCFDpCancelacion"
                    CFDiintLineaError = intlineaGoto
                    CFDistrDescripError = strError
                    CFDilngNumError = -1
                    CFDiMostrarMensajeError = False
                    Call pErrorGeneraCFD(1156, strError, blnMostrarMsjNotificaError)
                 End If
              End If
       End If
       
       If CFDiintResultadoTimbrado = 2 Then 'trono el timbrado
          Call pErrorGeneraCFD(1024, CFDistrDescripError, CFDiMostrarMensajeError)
          vgIntBanderaTImbradoPendiente = 2
       ElseIf CFDiintResultadoTimbrado = 0 Then 'en teoria no llego al timbrado pero primero evaluamos si hay timbre
          If Not CFDiblnHaytimbre Then 'ahora si hay un error antes del timbre
               Call pErrorGeneraCFD(1024, CFDistrDescripError, CFDiMostrarMensajeError)
               vgIntBanderaTImbradoPendiente = 3
          Else
               Call pErrorGeneraCFD(1276, CFDistrDescripError, CFDiMostrarMensajeError)
               vgIntBanderaTImbradoPendiente = 0 'falla despues del timbrado, asi que sigue el proceso
               frsEjecuta_SP CFDilngNumError & "|" & Left(CFDistrDescripError, 200) & "|" & cgstrModulo & "|" & Left(CFDistrProcesoError, 50) & " Linea:" & CFDiintLineaError & "|" & "", "SP_GNINSREGISTROERRORES", True
          End If
       ElseIf CFDiintResultadoTimbrado = 1 Then 'llego hasta el timbre, y quedo pendiente el timbrado
          vgIntBanderaTImbradoPendiente = 1
          frsEjecuta_SP CFDilngNumError & "|" & Left(CFDistrDescripError, 200) & "|" & cgstrModulo & "|" & Left(CFDistrProcesoError, 50) & " Linea:" & CFDiintLineaError & "|" & "", "SP_GNINSREGISTROERRORES", True
       End If
    
       fblnGeneraCFDpCancelacion = CFDiblnHaytimbre 'si hay timbre, aunque exista un error, se queda la información como timbrada
             
       'Elimina archivos de trabajo
       If fsoComprobante.FileExists(strArchivoXMLBase) Then fsoComprobante.DeleteFile strArchivoXMLBase
       If fsoComprobante.FileExists(strArchivoXMLFirmado) Then fsoComprobante.DeleteFile strArchivoXMLFirmado
       If fsoComprobante.FileExists(strArchivoLlave) Then fsoComprobante.DeleteFile strArchivoLlave
       If fsoComprobante.FileExists(strArchivoCertificado) Then fsoComprobante.DeleteFile strArchivoCertificado
       If fsoComprobante.FileExists(strArchivoXMLFirmadoTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLFirmadoTimbrado
       If fsoComprobante.FileExists(strArchivoXMLRequestTimbrado) Then fsoComprobante.DeleteFile strArchivoXMLRequestTimbrado
             
End Function
Public Function flngCorteValido(intCveDepto As Integer, lngCveEmpleado As Long, chrTipoCorte As String) As Long
'----------------------------------------------------------------------------------------
' Revisar si el corte actual es válido o debe cerrarse
'----------------------------------------------------------------------------------------
    On Error GoTo NotificaError
    
    flngCorteValido = 1
    frsEjecuta_SP CStr(intCveDepto) & "|" & CStr(lngCveEmpleado) & "|" & Trim(chrTipoCorte), "SP_PVSELCORTEVALIDO", True, flngCorteValido

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnCorteValido"))
End Function
Public Function flngNumeroCorte(intCveDepto As Integer, lngCveEmpleado As Long, strTipoCorte As String) As Long
    On Error GoTo NotificaError
    '----------------------------------------------------------------------------------------
    ' Regresa el número de corte abierto en este momento
    '----------------------------------------------------------------------------------------
    'lngCveDepto = Clave del departamento
    'lngCveEmpleado = Clave del empleado
    'strTipoCorte = Tipo de corte, P = caja de ingresos, C = caja chica
    
    vgstrParametrosSP = CStr(intCveDepto) & "|" & CStr(lngCveEmpleado) & "|" & Trim(strTipoCorte)
    
    flngNumeroCorte = 1
    frsEjecuta_SP vgstrParametrosSP, "SP_GNSELNUMEROCORTE", True, flngNumeroCorte
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngNumeroCorte"))
End Function

Public Function fstrObtieneInformacionXML(vlstrArchivoXML As String, vlStrRFCSIHO As String, vlStrFolioSIHO As String, vldtmFechaSIHO As Date) As Boolean
    On Error GoTo NotificaError
    Dim vlstrSerie As String
    Dim vlstrFolio As String
    Dim vlstrFecha As String
    Dim vlblnCorrectoRFC As Boolean
    Dim vlblnCorrectoFolio As Boolean
    Dim vlblnCorrectoFecha As Boolean
    Dim vlstrMensaje As String
    Dim vlblnCDFI As Boolean
    Dim vlstrTipoCambio As String
    Dim vlstrTipoCambioFinal As String
    Dim vlintcontador As Integer
    Dim vlintUltimoPunto As Integer
    Dim vlobjDOMNodoXML As MSXML2.IXMLDOMNode
    Dim strVersion As String

    fstrObtieneInformacionXML = False
    vgstrXMLCXP = ""
    
    'Carga el documento
    Set vlobjDOMXML = New DOMDocument
    vlobjDOMXML.async = False
    Call vlobjDOMXML.Load(vlstrArchivoXML)
  
    vgintTipoXMLCXP = 0
  
    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Version")
    If Not vlobjDOMNodoXML Is Nothing Then
            vlblnCDFI = True 'Si es un CFDI
            vgintTipoXMLCXP = 1
            strVersion = vlobjDOMNodoXML.Text
    Else
        Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@version")
        If Not vlobjDOMNodoXML Is Nothing Then
            vlblnCDFI = True 'Si es un CFDI
            vgintTipoXMLCXP = 1
        Else
            Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("Comprobante/@version")
            If Not vlobjDOMNodoXML Is Nothing Then
                vlblnCDFI = False 'Es un CFD
                vgintTipoXMLCXP = 2
            Else
                vgintTipoXMLCXP = 0
            End If
        End If
    End If
    If vgintTipoXMLCXP <> 0 Then
        If vlblnCDFI Then
            'Es un CFDI
            Select Case strVersion
                Case "3.3"
                    'Obtiene UUID
                    vgstrUUIDXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@UUID")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrUUIDXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@UUID").Text
                    End If
                    If vgstrUUIDXMLCXP = "" Then
                        Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/Complemento/tfd:TimbreFiscalDigital/@UUID")
                        If Not vlobjDOMNodoXML Is Nothing Then
                            vgstrUUIDXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/Complemento/tfd:TimbreFiscalDigital/@UUID").Text
                        End If
                    End If
                    
                    'Obtiene SERIE
                    vlstrSerie = ""
                    vgstrSerieCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Serie")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrSerie = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Serie").Text
                    End If

                    'Obtiene FOLIO
                    vlstrFolio = ""
                    vgstrNumFolioCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Folio")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrFolio = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Folio").Text
                    End If
                    
                    'Obtiene FECHA
                    vlstrFecha = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Fecha")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrFecha = Left(vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Fecha").Text, 10)
                    End If
                
                    'Obtiene RFC
                    vgstrRFCXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Emisor/@Rfc")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrRFCXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Emisor/@Rfc").Text
                    End If
                
                    'Obtiene TOTAL
                    vgdblMontoXMLCXP = 0
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Total")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgdblMontoXMLCXP = CDbl(vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Total").Text)
                    End If

                    'Obtiene TIPO DE CAMBIO
                    vlstrTipoCambio = ""
                    vlstrTipoCambioFinal = ""
                    vgdblTipoCambioXMLCXP = 0
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@TipoCambio")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrTipoCambio = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@TipoCambio").Text
                        If Trim(vlstrTipoCambio) = "" Then
                            vgdblTipoCambioXMLCXP = 1
                        Else
                            For vlintcontador = 1 To Len(vlstrTipoCambio)
                                If IsNumeric(Mid(vlstrTipoCambio, vlintcontador, 1)) Or Mid(vlstrTipoCambio, vlintcontador, 1) = "." Then
                                    vlstrTipoCambioFinal = vlstrTipoCambioFinal & Mid(vlstrTipoCambio, vlintcontador, 1)
                                End If
                            Next
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                Do While InStr(1, vlstrTipoCambioFinal, "..") <> 0
                                    vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, InStr(1, vlstrTipoCambioFinal, "..") - 1) & Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - InStr(1, vlstrTipoCambioFinal, ".."))
                                Loop
                            End If
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                Do While Mid(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal), 1) = "." Or Mid(vlstrTipoCambioFinal, 1, 1) = "."
                                    If Mid(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal), 1) = "." Then
                                        vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - 1)
                                    End If
                                    If Mid(vlstrTipoCambioFinal, 1, 1) = "." Then
                                        vlstrTipoCambioFinal = Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - 1)
                                    End If
                                Loop
                            End If
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                vlintUltimoPunto = 0
                                For vlintcontador = 1 To Len(vlstrTipoCambioFinal)
                                    If Mid(vlstrTipoCambioFinal, vlintcontador, 1) = "." Then
                                        vlintUltimoPunto = vlintcontador
                                    End If
                                Next
                            End If
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                For vlintcontador = 1 To vlintUltimoPunto - 1
                                    If Mid(vlstrTipoCambioFinal, vlintcontador, 1) = "." Then
                                        vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, vlintcontador - 1) & Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - vlintcontador)
                                    End If
                                Next
                            End If
        
                            If Trim(vlstrTipoCambioFinal) = "" Or Trim(vlstrTipoCambioFinal) = "." Then
                                vgdblTipoCambioXMLCXP = 1
                            Else
                                vgdblTipoCambioXMLCXP = CDbl(vlstrTipoCambioFinal)
                                If vgdblTipoCambioXMLCXP = 0 Then vgdblTipoCambioXMLCXP = 1
                            End If
                        End If
                    Else
                        vgdblTipoCambioXMLCXP = 1
                    End If
                    
                    'Obtiene MONEDA
                    vgstrMonedaXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Moneda")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrMonedaXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Moneda").Text
                        If vgstrMonedaXMLCXP <> "MXN" And vgstrMonedaXMLCXP <> "USD" Then
                            If vgstrMonedaXMLCXP = "MNX" Or vgstrMonedaXMLCXP = "MXP" Then
                                vgstrMonedaXMLCXP = "MXN"
                            Else
                                If InStr(1, UCase(vgstrMonedaXMLCXP), "PESO") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "MN") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "M.N") <> 0 Then
                                    vgstrMonedaXMLCXP = "MXN"
                                Else
                                    If InStr(1, UCase(vgstrMonedaXMLCXP), "DOLAR") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "DÓLAR") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "USD") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "U.S.D") <> 0 Then
                                        vgstrMonedaXMLCXP = "USD"
                                    Else
                                        If vgdblTipoCambioXMLCXP > 1 Then
                                            vgstrMonedaXMLCXP = "USD"
                                        Else
                                            vgstrMonedaXMLCXP = "MXN"
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Else
                        vgstrMonedaXMLCXP = "MXN"
                    End If
                    
                    'Obtiene el RFC del Receptor
                    vgstrRFCReceptorXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Receptor/@Rfc")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrRFCReceptorXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Receptor/@Rfc").Text
                    End If
                Case "4.0"
                    'Obtiene UUID
                    vgstrUUIDXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@UUID")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrUUIDXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@UUID").Text
                    End If
                    If vgstrUUIDXMLCXP = "" Then
                        Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/Complemento/tfd:TimbreFiscalDigital/@UUID")
                        If Not vlobjDOMNodoXML Is Nothing Then
                            vgstrUUIDXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/Complemento/tfd:TimbreFiscalDigital/@UUID").Text
                        End If
                    End If
                    
                    'Obtiene SERIE
                    vlstrSerie = ""
                    vgstrSerieCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Serie")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrSerie = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Serie").Text
                    End If

                    'Obtiene FOLIO
                    vlstrFolio = ""
                    vgstrNumFolioCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Folio")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrFolio = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Folio").Text
                    End If
                    
                    'Obtiene FECHA
                    vlstrFecha = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Fecha")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrFecha = Left(vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Fecha").Text, 10)
                    End If
                
                    'Obtiene RFC
                    vgstrRFCXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Emisor/@Rfc")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrRFCXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Emisor/@Rfc").Text
                    End If
                
                    'Obtiene TOTAL
                    vgdblMontoXMLCXP = 0
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Total")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgdblMontoXMLCXP = CDbl(vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Total").Text)
                    End If

                    'Obtiene TIPO DE CAMBIO
                    vlstrTipoCambio = ""
                    vlstrTipoCambioFinal = ""
                    vgdblTipoCambioXMLCXP = 0
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@TipoCambio")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrTipoCambio = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@TipoCambio").Text
                        If Trim(vlstrTipoCambio) = "" Then
                            vgdblTipoCambioXMLCXP = 1
                        Else
                            For vlintcontador = 1 To Len(vlstrTipoCambio)
                                If IsNumeric(Mid(vlstrTipoCambio, vlintcontador, 1)) Or Mid(vlstrTipoCambio, vlintcontador, 1) = "." Then
                                    vlstrTipoCambioFinal = vlstrTipoCambioFinal & Mid(vlstrTipoCambio, vlintcontador, 1)
                                End If
                            Next
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                Do While InStr(1, vlstrTipoCambioFinal, "..") <> 0
                                    vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, InStr(1, vlstrTipoCambioFinal, "..") - 1) & Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - InStr(1, vlstrTipoCambioFinal, ".."))
                                Loop
                            End If
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                Do While Mid(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal), 1) = "." Or Mid(vlstrTipoCambioFinal, 1, 1) = "."
                                    If Mid(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal), 1) = "." Then
                                        vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - 1)
                                    End If
                                    If Mid(vlstrTipoCambioFinal, 1, 1) = "." Then
                                        vlstrTipoCambioFinal = Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - 1)
                                    End If
                                Loop
                            End If
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                vlintUltimoPunto = 0
                                For vlintcontador = 1 To Len(vlstrTipoCambioFinal)
                                    If Mid(vlstrTipoCambioFinal, vlintcontador, 1) = "." Then
                                        vlintUltimoPunto = vlintcontador
                                    End If
                                Next
                            End If
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                For vlintcontador = 1 To vlintUltimoPunto - 1
                                    If Mid(vlstrTipoCambioFinal, vlintcontador, 1) = "." Then
                                        vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, vlintcontador - 1) & Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - vlintcontador)
                                    End If
                                Next
                            End If
        
                            If Trim(vlstrTipoCambioFinal) = "" Or Trim(vlstrTipoCambioFinal) = "." Then
                                vgdblTipoCambioXMLCXP = 1
                            Else
                                vgdblTipoCambioXMLCXP = CDbl(vlstrTipoCambioFinal)
                                If vgdblTipoCambioXMLCXP = 0 Then vgdblTipoCambioXMLCXP = 1
                            End If
                        End If
                    Else
                        vgdblTipoCambioXMLCXP = 1
                    End If
                    
                    'Obtiene MONEDA
                    vgstrMonedaXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Moneda")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrMonedaXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Moneda").Text
                        If vgstrMonedaXMLCXP <> "MXN" And vgstrMonedaXMLCXP <> "USD" Then
                            If vgstrMonedaXMLCXP = "MNX" Or vgstrMonedaXMLCXP = "MXP" Then
                                vgstrMonedaXMLCXP = "MXN"
                            Else
                                If InStr(1, UCase(vgstrMonedaXMLCXP), "PESO") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "MN") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "M.N") <> 0 Then
                                    vgstrMonedaXMLCXP = "MXN"
                                Else
                                    If InStr(1, UCase(vgstrMonedaXMLCXP), "DOLAR") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "DÓLAR") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "USD") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "U.S.D") <> 0 Then
                                        vgstrMonedaXMLCXP = "USD"
                                    Else
                                        If vgdblTipoCambioXMLCXP > 1 Then
                                            vgstrMonedaXMLCXP = "USD"
                                        Else
                                            vgstrMonedaXMLCXP = "MXN"
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Else
                        vgstrMonedaXMLCXP = "MXN"
                    End If
                    
                    'Obtiene el RFC del Receptor
                    vgstrRFCReceptorXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Receptor/@Rfc")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrRFCReceptorXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Receptor/@Rfc").Text
                    End If
                Case Else
                    'Obtiene UUID
                    vgstrUUIDXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@UUID")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrUUIDXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital/@UUID").Text
                    End If
                    If vgstrUUIDXMLCXP = "" Then
                        Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/Complemento/tfd:TimbreFiscalDigital/@UUID")
                        If Not vlobjDOMNodoXML Is Nothing Then
                            vgstrUUIDXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/Complemento/tfd:TimbreFiscalDigital/@UUID").Text
                        End If
                    End If
                    
                    'Obtiene SERIE
                    vlstrSerie = ""
                    vgstrSerieCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@serie")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrSerie = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@serie").Text
                    End If
                    
                    'Obtiene FOLIO
                    vlstrFolio = ""
                    vgstrNumFolioCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@folio")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrFolio = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@folio").Text
                    End If
                    
                    'Obtiene FECHA
                    vlstrFecha = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@fecha")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrFecha = Left(vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@fecha").Text, 10)
                    End If
                
                    'Obtiene RFC
                    vgstrRFCXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Emisor/@rfc")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrRFCXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Emisor/@rfc").Text
                    End If
                
                    'Obtiene TOTAL
                    vgdblMontoXMLCXP = 0
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@total")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgdblMontoXMLCXP = CDbl(vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@total").Text)
                    End If
                    
                    'Obtiene TIPO DE CAMBIO
                    vlstrTipoCambio = ""
                    vlstrTipoCambioFinal = ""
                    vgdblTipoCambioXMLCXP = 0
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@TipoCambio")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vlstrTipoCambio = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@TipoCambio").Text
                        If Trim(vlstrTipoCambio) = "" Then
                            vgdblTipoCambioXMLCXP = 1
                        Else
                            For vlintcontador = 1 To Len(vlstrTipoCambio)
                                If IsNumeric(Mid(vlstrTipoCambio, vlintcontador, 1)) Or Mid(vlstrTipoCambio, vlintcontador, 1) = "." Then
                                    vlstrTipoCambioFinal = vlstrTipoCambioFinal & Mid(vlstrTipoCambio, vlintcontador, 1)
                                End If
                            Next
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                Do While InStr(1, vlstrTipoCambioFinal, "..") <> 0
                                    vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, InStr(1, vlstrTipoCambioFinal, "..") - 1) & Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - InStr(1, vlstrTipoCambioFinal, ".."))
                                Loop
                            End If
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                Do While Mid(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal), 1) = "." Or Mid(vlstrTipoCambioFinal, 1, 1) = "."
                                    If Mid(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal), 1) = "." Then
                                        vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - 1)
                                    End If
                                    If Mid(vlstrTipoCambioFinal, 1, 1) = "." Then
                                        vlstrTipoCambioFinal = Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - 1)
                                    End If
                                Loop
                            End If
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                vlintUltimoPunto = 0
                                For vlintcontador = 1 To Len(vlstrTipoCambioFinal)
                                    If Mid(vlstrTipoCambioFinal, vlintcontador, 1) = "." Then
                                        vlintUltimoPunto = vlintcontador
                                    End If
                                Next
                            End If
        
                            If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                                For vlintcontador = 1 To vlintUltimoPunto - 1
                                    If Mid(vlstrTipoCambioFinal, vlintcontador, 1) = "." Then
                                        vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, vlintcontador - 1) & Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - vlintcontador)
                                    End If
                                Next
                            End If
        
                            If Trim(vlstrTipoCambioFinal) = "" Or Trim(vlstrTipoCambioFinal) = "." Then
                                vgdblTipoCambioXMLCXP = 1
                            Else
                                vgdblTipoCambioXMLCXP = CDbl(vlstrTipoCambioFinal)
                                If vgdblTipoCambioXMLCXP = 0 Then vgdblTipoCambioXMLCXP = 1
                            End If
                        End If
                    Else
                        vgdblTipoCambioXMLCXP = 1
                    End If
                    
                    'Obtiene MONEDA
                    vgstrMonedaXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Moneda")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrMonedaXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/@Moneda").Text
                        If vgstrMonedaXMLCXP <> "MXN" And vgstrMonedaXMLCXP <> "USD" Then
                            If vgstrMonedaXMLCXP = "MNX" Or vgstrMonedaXMLCXP = "MXP" Then
                                vgstrMonedaXMLCXP = "MXN"
                            Else
                                If InStr(1, UCase(vgstrMonedaXMLCXP), "PESO") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "MN") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "M.N") <> 0 Then
                                    vgstrMonedaXMLCXP = "MXN"
                                Else
                                    If InStr(1, UCase(vgstrMonedaXMLCXP), "DOLAR") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "DÓLAR") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "USD") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "U.S.D") <> 0 Then
                                        vgstrMonedaXMLCXP = "USD"
                                    Else
                                        If vgdblTipoCambioXMLCXP > 1 Then
                                            vgstrMonedaXMLCXP = "USD"
                                        Else
                                            vgstrMonedaXMLCXP = "MXN"
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Else
                        vgstrMonedaXMLCXP = "MXN"
                    End If
                    
                    'Obtiene el RFC del Receptor
                    vgstrRFCReceptorXMLCXP = ""
                    Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Receptor/@rfc")
                    If Not vlobjDOMNodoXML Is Nothing Then
                        vgstrRFCReceptorXMLCXP = vlobjDOMXML.selectSingleNode("cfdi:Comprobante/cfdi:Receptor/@rfc").Text
                    End If
            End Select
        Else
            'Es un CFD
        
            'Obtiene SERIE
            vlstrSerie = ""
            vgstrSerieCXP = ""
            Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("Comprobante/@serie")
            If Not vlobjDOMNodoXML Is Nothing Then
                vlstrSerie = vlobjDOMXML.selectSingleNode("Comprobante/@serie").Text
            End If
            
            'Obtiene FOLIO
            vlstrFolio = ""
            vgstrNumFolioCXP = ""
            Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("Comprobante/@folio")
            If Not vlobjDOMNodoXML Is Nothing Then
                vlstrFolio = vlobjDOMXML.selectSingleNode("Comprobante/@folio").Text
            End If
            
            'Obtiene FECHA
            vlstrFecha = ""
            Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("Comprobante/@fecha")
            If Not vlobjDOMNodoXML Is Nothing Then
                vlstrFecha = Left(vlobjDOMXML.selectSingleNode("Comprobante/@fecha").Text, 10)
            End If
        
            'Obtiene RFC
            vgstrRFCXMLCXP = ""
            Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("Comprobante/Emisor/@rfc")
            If Not vlobjDOMNodoXML Is Nothing Then
                vgstrRFCXMLCXP = vlobjDOMXML.selectSingleNode("Comprobante/Emisor/@rfc").Text
            End If
        
            'Obtiene TOTAL
            vgdblMontoXMLCXP = 0
            Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("Comprobante/@total")
            If Not vlobjDOMNodoXML Is Nothing Then
                vgdblMontoXMLCXP = CDbl(vlobjDOMXML.selectSingleNode("Comprobante/@total").Text)
            End If
                        
            'Obtiene TIPO DE CAMBIO
            vlstrTipoCambio = ""
            vlstrTipoCambioFinal = ""
            vgdblTipoCambioXMLCXP = 0
            Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("Comprobante/@TipoCambio")
            If Not vlobjDOMNodoXML Is Nothing Then
                vlstrTipoCambio = vlobjDOMXML.selectSingleNode("Comprobante/@TipoCambio").Text
                If Trim(vlstrTipoCambio) = "" Then
                    vgdblTipoCambioXMLCXP = 1
                Else
                    For vlintcontador = 1 To Len(vlstrTipoCambio)
                        If IsNumeric(Mid(vlstrTipoCambio, vlintcontador, 1)) Or Mid(vlstrTipoCambio, vlintcontador, 1) = "." Then
                            vlstrTipoCambioFinal = vlstrTipoCambioFinal & Mid(vlstrTipoCambio, vlintcontador, 1)
                        End If
                    Next

                    If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                        Do While InStr(1, vlstrTipoCambioFinal, "..") <> 0
                            vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, InStr(1, vlstrTipoCambioFinal, "..") - 1) & Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - InStr(1, vlstrTipoCambioFinal, ".."))
                        Loop
                    End If

                    If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                        Do While Mid(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal), 1) = "." Or Mid(vlstrTipoCambioFinal, 1, 1) = "."
                            If Mid(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal), 1) = "." Then
                                vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - 1)
                            End If
                            If Mid(vlstrTipoCambioFinal, 1, 1) = "." Then
                                vlstrTipoCambioFinal = Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - 1)
                            End If
                        Loop
                    End If

                    If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                        vlintUltimoPunto = 0
                        For vlintcontador = 1 To Len(vlstrTipoCambioFinal)
                            If Mid(vlstrTipoCambioFinal, vlintcontador, 1) = "." Then
                                vlintUltimoPunto = vlintcontador
                            End If
                        Next
                    End If

                    If Trim(vlstrTipoCambioFinal) <> "" And Trim(vlstrTipoCambioFinal) <> "." Then
                        For vlintcontador = 1 To vlintUltimoPunto - 1
                            If Mid(vlstrTipoCambioFinal, vlintcontador, 1) = "." Then
                                vlstrTipoCambioFinal = Left(vlstrTipoCambioFinal, vlintcontador - 1) & Right(vlstrTipoCambioFinal, Len(vlstrTipoCambioFinal) - vlintcontador)
                            End If
                        Next
                    End If

                    If Trim(vlstrTipoCambioFinal) = "" Or Trim(vlstrTipoCambioFinal) = "." Then
                        vgdblTipoCambioXMLCXP = 1
                    Else
                        vgdblTipoCambioXMLCXP = CDbl(vlstrTipoCambioFinal)
                        If vgdblTipoCambioXMLCXP = 0 Then vgdblTipoCambioXMLCXP = 1
                    End If
                End If
            Else
                vgdblTipoCambioXMLCXP = 1
            End If
            
            'Obtiene MONEDA
            vgstrMonedaXMLCXP = ""
            Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("Comprobante/@Moneda")
            If Not vlobjDOMNodoXML Is Nothing Then
                vgstrMonedaXMLCXP = vlobjDOMXML.selectSingleNode("Comprobante/@Moneda").Text
                If vgstrMonedaXMLCXP <> "MXN" And vgstrMonedaXMLCXP <> "USD" Then
                    If vgstrMonedaXMLCXP = "MNX" Or vgstrMonedaXMLCXP = "MXP" Then
                        vgstrMonedaXMLCXP = "MXN"
                    Else
                        If InStr(1, UCase(vgstrMonedaXMLCXP), "PESO") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "MN") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "M.N") <> 0 Then
                            vgstrMonedaXMLCXP = "MXN"
                        Else
                            If InStr(1, UCase(vgstrMonedaXMLCXP), "DOLAR") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "DÓLAR") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "USD") <> 0 Or InStr(1, UCase(vgstrMonedaXMLCXP), "U.S.D") <> 0 Then
                                vgstrMonedaXMLCXP = "USD"
                            Else
                                If vgdblTipoCambioXMLCXP > 1 Then
                                    vgstrMonedaXMLCXP = "USD"
                                Else
                                    vgstrMonedaXMLCXP = "MXN"
                                End If
                            End If
                        End If
                    End If
                End If
            Else
                vgstrMonedaXMLCXP = "MXN"
            End If
            
            'Obtiene el RFC del Receptor
            vgstrRFCReceptorXMLCXP = ""
            Set vlobjDOMNodoXML = vlobjDOMXML.selectSingleNode("Comprobante/Receptor/@rfc")
            If Not vlobjDOMNodoXML Is Nothing Then
                vgstrRFCReceptorXMLCXP = vlobjDOMXML.selectSingleNode("Comprobante/Receptor/@rfc").Text
            End If
            
        End If
    End If

    If vgintTipoXMLCXP = 0 Then
        'Tipo de archivo no válido.
        MsgBox SIHOMsg(716), vbOKOnly + vbExclamation, "Mensaje"
    Else
        If vlstrFecha = "" Or vgstrRFCXMLCXP = "" Then
            'Tipo de archivo no válido.
            MsgBox SIHOMsg(716), vbOKOnly + vbExclamation, "Mensaje"
        Else
            If Trim(vgstrUUIDXMLCXP) = "" And vlblnCDFI Then 'No encontró UUID
                vgdblMontoXMLCXP = 0
                vgintTipoXMLCXP = 0
                vgstrXMLCXP = ""
                vgstrRFCXMLCXP = ""
                vgstrMonedaXMLCXP = ""
                vgdblTipoCambioXMLCXP = 0
                vgstrSerieCXP = ""
                vgstrNumFolioCXP = ""
                vgstrNumFactExtCXP = ""
                vgstrTaxIDExtCXP = ""
                fstrObtieneInformacionXML = False
                '¡No se encontró el dato UUID en el XML seleccionado, verifique la información!
                MsgBox SIHOMsg(1295), vbOKOnly + vbExclamation, "Mensaje"
            Else
                'Verifica que el RFC de la empresa contable coincida con el RFC del receptor de la factura que se está adjuntando
                If UCase(Trim(Replace(Replace(Replace(vgstrRfCCH, "-", ""), "_", ""), " ", ""))) <> UCase(Trim(vgstrRFCReceptorXMLCXP)) Then
                    'El RFC del receptor del XML que se está adjuntando no coincide con el RFC de la empresa contable.
                    MsgBox SIHOMsg(1428), vbOKOnly + vbExclamation, "Mensaje"
                    vgstrXMLCXP = ""
                    vgintTipoXMLCXP = 0
                    vgstrUUIDXMLCXP = ""
                    vgdblMontoXMLCXP = 0
                    vgstrRFCXMLCXP = ""
                    vgstrMonedaXMLCXP = ""
                    vgdblTipoCambioXMLCXP = 0
                    vgstrSerieCXP = ""
                    vgstrNumFolioCXP = ""
                    vgstrNumFactExtCXP = ""
                    vgstrTaxIDExtCXP = ""
                    fstrObtieneInformacionXML = False
                    Exit Function
                End If
                
                vlblnCorrectoRFC = IIf(Trim(vgstrRFCXMLCXP) = Trim(vlStrRFCSIHO), True, False)
                vlblnCorrectoFecha = IIf(CDate(vlstrFecha) = vldtmFechaSIHO, True, False)
                vlblnCorrectoFolio = IIf(Trim(vlstrSerie) & Trim(vlstrFolio) = Trim(vlStrFolioSIHO), True, False)
                
                If vlblnCorrectoRFC And vlblnCorrectoFolio And vlblnCorrectoFecha Then
                    vgstrXMLCXP = vlobjDOMXML.xml
                    vgstrSerieCXP = Trim(Mid(Trim(vlstrSerie), 1, 10))
                    vgstrNumFolioCXP = vlstrFolio
                    fstrObtieneInformacionXML = True
                Else
                    vlstrMensaje = IIf(vlblnCorrectoRFC, "", "RFC = " & Trim(vgstrRFCXMLCXP))
                    vlstrMensaje = vlstrMensaje & IIf(vlblnCorrectoFecha, "", IIf(Trim(vlstrMensaje) = "", "", Chr(13)) & "Fecha del documento = " & Format((CDate(vlstrFecha)), "dd/mmm/yyyy"))
                    If Not vlblnCorrectoFolio Then
                        If Trim(vlstrSerie) & Trim(vlstrFolio) = "" Then
                            vlstrMensaje = vlstrMensaje & IIf(Trim(vlstrMensaje) = "", "", Chr(13)) & "Falta la serie y folio del documento"
                        Else
                            vlstrMensaje = vlstrMensaje & IIf(Trim(vlstrMensaje) = "", "", Chr(13)) & IIf(Trim(vlstrSerie) = "", "Falta la serie del documento", "Serie = " & Trim(vlstrSerie))
                            vlstrMensaje = vlstrMensaje & IIf(Trim(vlstrMensaje) = "", "", Chr(13)) & IIf(Trim(vlstrFolio) = "", "Falta el folio del documento", "Folio = " & Trim(vlstrFolio))
                        End If
                    End If
                
                    'La siguiente información del XML seleccionado falta o no coincide con el documento elegido. ¿Desea continuar?
                    If MsgBox(SIHOMsg(1296) & IIf(Trim(vlstrMensaje) = "", "", Chr(13)) & vlstrMensaje, vbExclamation + vbYesNo, "Mensaje") = vbYes Then
                        vgstrXMLCXP = vlobjDOMXML.xml
                        vgstrSerieCXP = Trim(Mid(Trim(vlstrSerie), 1, 10))
                        vgstrNumFolioCXP = vlstrFolio
                        fstrObtieneInformacionXML = True
                    Else
                        vgstrXMLCXP = ""
                        vgintTipoXMLCXP = 0
                        vgstrUUIDXMLCXP = ""
                        vgdblMontoXMLCXP = 0
                        vgstrRFCXMLCXP = ""
                        vgstrMonedaXMLCXP = ""
                        vgdblTipoCambioXMLCXP = 0
                        vgstrSerieCXP = ""
                        vgstrNumFolioCXP = ""
                        vgstrNumFactExtCXP = ""
                        vgstrTaxIDExtCXP = ""
                        fstrObtieneInformacionXML = False
                    End If
                End If
            End If
        End If
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fstrObtieneInformacionXML"))
End Function
Public Function fintNumCopiasImpresion(lngComprobante As Long) As Integer
Dim ObjRS As New ADODB.Recordset
Dim objSTR As String
On Error GoTo Error
    
    fintNumCopiasImpresion = 2
    
    objSTR = "select CHRTIPOFACTURA,INTCVEVENTAPUBLICO from pvfactura where intconsecutivo = " & lngComprobante
    Set ObjRS = frsRegresaRs(objSTR, adLockOptimistic)
    
    If ObjRS.RecordCount > 0 Then
       If ObjRS!intCveVentaPublico = 0 Then 'se excluye todo lo que venga de venta al público
            objSTR = "Select vchvalor from siparametro where INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable
            Select Case Trim(ObjRS!chrTipoFactura)
            Case "P" 'Paciente
                    objSTR = objSTR & " and vchnombre ='NUMCOPIASFACTURAPACIENTE'"
            Case "E" 'Empresa
                    objSTR = objSTR & " and vchnombre ='NUMCOPIASFACTURAEMPRESA'"
            Case "C" 'Cliente(Fatura Directa)
                    objSTR = objSTR & " and vchnombre ='NUMCOPIASFACTURADIRECTA'"
            End Select
            
            Set ObjRS = frsRegresaRs(objSTR, adLockOptimistic)
            If ObjRS.RecordCount > 0 Then
               fintNumCopiasImpresion = Val(ObjRS!VCHVALOR)
            End If
       End If
    End If
Exit Function
Error:
    fintNumCopiasImpresion = 2
End Function

Public Function GetDefaultPrinter() As Printer
    Dim objPrinter As Printer
    Dim DefPrinter As String, sLen As Long, iPrn As Printer, hResult As Long
    Set GetDefaultPrinter = Printer
    DefPrinter = Space$(255)
    sLen = 255
    hResult = GetDefaultPrinterA(ByVal DefPrinter, sLen)
    If hResult <> 0 Then DefPrinter = Left(DefPrinter, sLen - 1)
    If Printer.DeviceName = DefPrinter Then Exit Function
    SetPrinterAsDefault DefPrinter
'    For Each objPrinter In Printers
'        If objPrinter.DeviceName = DefPrinter Then
'            ' Default printer found !
'            Exit For
'        End If
'    Next
    ' If not found, return nothing
    If Printer.DeviceName <> DefPrinter Then
        Set objPrinter = Nothing
    Else
        Set objPrinter = Printer
    End If
    Set GetDefaultPrinter = objPrinter
End Function

Public Function fblnValidaDatosCFDCFDi(lngConsecutivo As Long, _
                                      strTipoComprobante As String, _
                                      blnCFDI As Boolean, _
                                      Optional IntAnoAprobacion As String = 0, _
                                      Optional strNumeroAprobacion As String = "", _
                                      Optional blnMostrarMensaje As Boolean = True) As Boolean
        Dim intCodeError As Integer
        Dim strError As String
        Dim objSTR As String
        Dim ObjRS As New ADODB.Recordset
        Dim ObjRs2 As New ADODB.Recordset
        
        fblnValidaDatosCFDCFDi = True
        intCodeError = 0
        
        
'        If vgstrVersionCFDI <> "3.2" Then
            objSTR = lngConsecutivo & "|" & strTipoComprobante & "|" & vgstrVersionCFDI
'            Set ObjRs = frsEjecuta_SP(ObjStr, "sp_SelDatosValidaCFDIVersion")
'            If Not ObjRs.EOF Then
'
'            End If
'            ObjRs.Close
            objSTR = ""
'        Else
            objSTR = lngConsecutivo & "|" & strTipoComprobante
            Set ObjRS = frsEjecuta_SP(objSTR, "Sp_SelDatosValidaCFD")
                    
            With ObjRS
                If .RecordCount > 0 Then
                   If vgstrVersionCFDI <> "3.2" Then
                        If IsNull(!fecha) Then intCodeError = 1
                        If IsNull(!Subtotal) And intCodeError = 0 Then intCodeError = 4
                        If IsNull(!Total) And intCodeError = 0 Then intCodeError = 5
                        If IsNull(!Folio) And intCodeError = 0 Then intCodeError = 6
                                    
                        If intCodeError = 0 Then
                           If IsNull(!RFCEMISOR) Then
                              intCodeError = 7
                           Else
                              If Len(!RFCEMISOR) < 12 Then
                                 intCodeError = 7
                              End If
                           End If
                        End If
                        
                        If IsNull(!NOMBREMISOR) And intCodeError = 0 Then intCodeError = 8
                                       
                        If intCodeError = 0 Then
                           If IsNull(!CPEmisor) Then
                              intCodeError = 13
                           Else
                              If Len(CStr(!CPEmisor)) <> 5 And Len(CStr(Trim(!CPEmisor))) <> 0 Then
                                 intCodeError = 13
                              End If
                           End If
                        End If
                        
                        If intCodeError = 0 Then
                           If IsNull(!RFCReceptor) Then
                              intCodeError = 14
                           Else
                              If Len(!RFCReceptor) > 13 Then
                                 intCodeError = 14
                              End If
                           End If
                        End If
                                       
                        If intCodeError = 0 Then
                           If Not IsNull(!CPReceptor) Then
                              If Len(CStr(!CPReceptor)) <> 5 And Len(CStr(Trim(!CPReceptor))) <> 0 Then intCodeError = 16
                           End If
                        End If
                        
                        If intCodeError = 0 Then
                           If Not IsNull(!CPEXPEDIDOEN) Then
                              If Len(CStr(!CPEXPEDIDOEN)) <> 5 And Len(CStr(Trim(!CPEXPEDIDOEN))) <> 0 Then intCodeError = 17
                           End If
                        End If
                        
                        If (IsNull(!REGIMENFISCAL) Or Trim(!REGIMENFISCAL) = "" Or Not IsNumeric(!REGIMENFISCAL)) And intCodeError = 0 Then intCodeError = 18
                        If intCodeError = 0 Then
                            objSTR = "select D.vchClave from GNCatalogoSAT C" & _
                            " inner join GNCatalogoSATDetalle D on D.intIdCatalogoSAT =  C.intIdCatalogoSAT" & _
                            " where C.vchNombreCatalogo = 'c_RegimenFiscal' and intIdRegistro = " & !REGIMENFISCAL
                            Set ObjRs2 = frsRegresaRs(objSTR, adLockReadOnly, adOpenForwardOnly)
                            If ObjRs2.EOF Then
                                intCodeError = 18
                            End If
                            ObjRs2.Close
                        End If
                        
                        If Not IsNull(!VERDIGITOS) Then
                           If !VERDIGITOS = 0 And intCodeError = 0 Then intCodeError = 21
                        End If
                        
                   Else
                        If IsNull(!fecha) Then intCodeError = 1
                        If IsNull(!Subtotal) And intCodeError = 0 Then intCodeError = 4
                        If IsNull(!Total) And intCodeError = 0 Then intCodeError = 5
                        If IsNull(!Folio) And intCodeError = 0 Then intCodeError = 6
                                    
                        If intCodeError = 0 Then
                           If IsNull(!RFCEMISOR) Then
                              intCodeError = 7
                           Else
                              If Len(!RFCEMISOR) < 12 Then
                                 intCodeError = 7
                              End If
                           End If
                        End If
                        
                        If IsNull(!NOMBREMISOR) And intCodeError = 0 Then intCodeError = 8
                        If IsNull(!CalleEmisor) And intCodeError = 0 Then intCodeError = 9
                        If IsNull(!Ciudademisor) And intCodeError = 0 Then intCodeError = 10
                        If IsNull(!EstadoEmisor) And intCodeError = 0 Then intCodeError = 11
                        If IsNull(!PaisEmisor) And intCodeError = 0 Then intCodeError = 12
                                       
                        If intCodeError = 0 Then
                           If IsNull(!CPEmisor) Then
                              intCodeError = 13
                           Else
                              If Len(CStr(!CPEmisor)) <> 5 And Len(CStr(Trim(!CPEmisor))) <> 0 Then
                                 intCodeError = 13
                              End If
                           End If
                        End If
                        
                        If intCodeError = 0 Then
                           If IsNull(!RFCReceptor) Then
                              intCodeError = 14
                           Else
                              If Len(!RFCReceptor) > 13 Then
                                 intCodeError = 14
                              End If
                           End If
                        End If
                                       
                        If IsNull(!PaisReceptor) And intCodeError = 0 Then intCodeError = 15
                                       
                        If intCodeError = 0 Then
                           If Not IsNull(!CPReceptor) Then
                              If Len(CStr(!CPReceptor)) <> 5 And Len(CStr(Trim(!CPReceptor))) <> 0 Then intCodeError = 16
                           End If
                        End If
                        
                        If intCodeError = 0 Then
                           If Not IsNull(!CPEXPEDIDOEN) Then
                              If Len(CStr(!CPEXPEDIDOEN)) <> 5 And Len(CStr(Trim(!CPEXPEDIDOEN))) <> 0 Then intCodeError = 17
                           End If
                        End If
                        
                        If (IsNull(!REGIMENFISCAL) Or Trim(!REGIMENFISCAL) = "") And intCodeError = 0 Then intCodeError = 18
                        If (IsNull(!METODOPAGO) Or Trim(!METODOPAGO) = "") And intCodeError = 0 Then intCodeError = 19
                        If (IsNull(!LUGAREXPEDICION) Or Trim(!LUGAREXPEDICION) = "" Or Trim(!LUGAREXPEDICION) = ",") And intCodeError = 0 Then intCodeError = 20
                        If Not IsNull(!VERDIGITOS) Then
                           If !VERDIGITOS = 0 And intCodeError = 0 Then intCodeError = 21
                        End If
                   End If
                Else
                   intCodeError = -1 'no hay información de la factura/nota
                End If
            End With
            ObjRS.Close
'        End If
        
        'si es CFD validamos el número y año de aprobación
        If blnCFDI = False Then
           If strNumeroAprobacion = "" And intCodeError = 0 Then intCodeError = 2
           If IntAnoAprobacion = 0 And intCodeError = 0 Then intCodeError = 3
        End If
        
       If intCodeError <> 0 Then
         Select Case intCodeError
                Case -1
                    strError = ""
                Case 1
                    strError = "Fecha emisión"
                Case 2
                    strError = "Número aprobación"
                Case 3
                    strError = "Año aprobación"
                Case 4
                    strError = "Subtotal"
                Case 5
                    strError = "Total"
                Case 6
                    strError = "Folio"
                Case 7
                    strError = "RFC del emisor"
                Case 8
                    strError = "Nombre del emisor"
                Case 9
                    strError = "Calle del domicilio fiscal del emisor"
                Case 10
                    strError = "Municipio del domicilio fiscal del emisor"
                Case 11
                    strError = "Estado del domicilio fiscal del emisor"
                Case 12
                    strError = "País del domicilio fiscal del emisor"
                Case 13
                    strError = "Código postal del domicilio fiscal del emisor"
                Case 14
                    strError = "RCF del receptor"
                Case 15
                    strError = "Pais del receptor"
                Case 16
                    strError = "Código postal del receptor"
                Case 17
                    strError = "Código postal de la sucursal"
                Case 18
                    strError = "Régimen fiscal"
                Case 19
                    strError = "Método de pago"
                Case 20
                    strError = "Lugar de expedición"
                Case 21
                    strError = "Cuenta o referencia de pago"
         End Select
         If blnMostrarMensaje Then
            strError = "Información incorrecta: " & strError
            MsgBox SIHOMsg(33) & vbNewLine & vbNewLine & IIf(strTipoComprobante = "FA", "La factura", "La nota") & " contiene información inválida: " & _
                                       vbNewLine & vbCrLf & "- " & strError & ".", vbCritical, "Mensaje"
         End If
         fblnValidaDatosCFDCFDi = False
       End If

End Function

Public Function fstrTmpPath() As String
    Dim sFolder As String ' Name of the folder
    Dim lRet As Long ' Return Value
    
    sFolder = String(MAX_PATH, 0)
    lRet = GetTempPath(MAX_PATH, sFolder)
    
    If lRet <> 0 Then
        fstrTmpPath = Left(sFolder, InStr(sFolder, _
        Chr(0)) - 1)
    Else
        fstrTmpPath = vbNullString
    End If
End Function

Public Function flngExportaCRByJava(cryRpt As CRAXDRT.Report, cryDestino As CRExportDestinationType, strRuta As String, blnShow As Boolean, strPags As String) As Long
    Dim lngPid As Long
    Dim lngHandle As Long
    Dim lngExitCode As Long
    Dim strFileNamne As String
    Dim strOpen As String
    
    If cryDestino = crEDTDiskFile Then
        If blnShow Then
            strOpen = "true"
        Else
            strOpen = "false"
        End If
    Else
        strOpen = "true"
    End If
 
    strFileNamne = strRuta
    With cryRpt
        .ExportOptions.DiskFileName = fstrTmpPath & cryRpt.ReportTitle
        .ExportOptions.DestinationType = crEDTDiskFile
        .ExportOptions.FormatType = crEFTCrystalReport
        .Export False
    End With
   
    lngPid = Shell("java -jar """ & App.Path & "\JCR_SiHO.jar"" jcr """ & fstrTmpPath & cryRpt.ReportTitle & """ """ & strFileNamne & """ PDF " & strOpen & IIf(strPags <> "", " " & strPags, ""), vbHide)
    DoEvents
    If lngPid <> 0 Then
        lngHandle = OpenProcess(SYNCHRONIZE Or PROCESS_QUERY_INFORMATION, 0, lngPid)
        If lngHandle <> 0 Then
            WaitForSingleObject lngHandle, INFINITE
            If GetExitCodeProcess(lngHandle, lngExitCode) <> 0 Then
                flngExportaCRByJava = lngExitCode
                CloseHandle lngHandle
            Else
                CloseHandle lngHandle
                Err.Raise &H8004AA00, "ShellSync", "Failed to retrieve exit code, error " & CStr(Err.LastDllError)
            End If
        Else
            Err.Raise &H8004AA01, "ShellSync", _
            "Failed to open child process"
        End If
    Else
        Err.Raise &H8004AA02, "ShellSync", _
        "Failed to Shell child process"
    End If
End Function

Public Sub pGeneraPDF(ByVal cryRpt As CRAXDRT.Report, strRutaPDF As String, Optional strPaginaIni As String, Optional strPaginaFin As String)
    On Error GoTo Errores

    Dim prt As Printer
    Dim strCurrentPrinter As String
    Dim fso As New FileSystemObject
    Dim lngTime As Long
    Dim dtmInitDate As Date
    Dim crCurrentOrientation As CRAXDRT.CRPaperOrientation
    Dim crCurrentPaper As CRAXDRT.CRPaperSize
    Dim strRutaTemporal As String
    Dim lngPid As Long
    Dim lngHandle As Long
    Dim lngExitCode As Long

    strRutaTemporal = fstrReplaceDobleBackSlash(fstrTmpPath & "\tmp_siho_pdf.pdf")

    If fso.FileExists(strRutaTemporal) Then
        fso.DeleteFile strRutaTemporal
    End If
    
    If fso.FileExists(strRutaPDF) Then
        fso.DeleteFile strRutaPDF
    End If
    
    'Obtener la impresora y orientación del papel actuales
    strCurrentPrinter = Printer.DeviceName
    crCurrentOrientation = cryRpt.PaperOrientation
    crCurrentPaper = cryRpt.PaperSize
    
    'Cambiar temporalmente la impresora a la de PDFCreator
    'Para que cambie la impresora correctamente, es necesario que se establezca la orientación del papel
    For Each prt In Printers
      If prt.DeviceName = "SIHO_PDF" Then
        Set Printer = prt
        Exit For
      End If
    Next
    cryRpt.SelectPrinter Printer.DriverName, Printer.DeviceName, Printer.port
    cryRpt.PaperOrientation = crCurrentOrientation
    cryRpt.PaperSize = crCurrentPaper
    
    'Imprime el reporte en la impresora
    If IsNumeric(strPaginaIni) And IsNumeric(strPaginaFin) Then
        cryRpt.PrintOutEx False, 1, False, CLng(strPaginaIni), CLng(strPaginaFin)
    Else
        cryRpt.PrintOutEx False
    End If
    
    'Devolver la impresora original, con la respectiva orientación del papel
    For Each prt In Printers
      If prt.DeviceName = strCurrentPrinter Then
        Set Printer = prt
        Exit For
      End If
    Next
    cryRpt.SelectPrinter Printer.DriverName, Printer.DeviceName, Printer.port
    cryRpt.PaperOrientation = crCurrentOrientation
    cryRpt.PaperSize = crCurrentPaper
    'Mover el archivo de la ruta temporal a la que corresponde
    dtmInitDate = fdtmServerFechaHora
    Do While Not fso.FileExists(strRutaTemporal) And (DateDiff("s", dtmInitDate, fdtmServerFechaHora) < 300)
        lngTime = lngTime + 1
        DoEvents
    Loop
    If fso.FileExists(strRutaTemporal) Then
        'Marca acceso denegado en algunas máquinas, por eso se cambió el fso.CopyFile/fso.MoveFile por un Shell
        'fso.CopyFile strRutaTemporal, strRutaPDF, True
        lngPid = Shell("cmd /c move /Y """ & strRutaTemporal & """ """ & strRutaPDF & """", vbHide)
        dtmInitDate = fdtmServerFechaHora
        Do While Not fso.FileExists(strRutaPDF) And (DateDiff("s", dtmInitDate, fdtmServerFechaHora) < 300)
            lngTime = lngTime + 1
            DoEvents
        Loop
    Else
        Err.Raise _
        Number:=-555, _
        Description:="Error al generar PDF", _
        Source:="pGeneraPDF"
    End If
    Exit Sub
Errores:
    Err.Raise Err
End Sub

Public Function fblnUsarPDFCreator() As Boolean
    Dim prt As Printer
    fblnUsarPDFCreator = False
    If vglngTerminalServerSessionId = 0 Then
        For Each prt In Printers
          If prt.DeviceName = "SIHO_PDF" Then
            fblnUsarPDFCreator = True
            Exit For
          End If
        Next
    End If
End Function

Public Sub pAbrirArchivo(strRutaArchivo As String)
    shellexecute 0&, "open", strRutaArchivo, "", "", vbNormalFocus
End Sub

Private Function fstrReplaceDobleBackSlash(strRuta) As String
    fstrReplaceDobleBackSlash = Replace(strRuta, "\\", "\")
End Function

Public Function fintTabuladorListaPrecio(lngCveLista As Long) As Long
    Dim lngCveTabulador As Long
    
    lngCveTabulador = 1
    frsEjecuta_SP CStr(lngCveLista), "fn_intCveTabulador", True, lngCveTabulador
    
    fintTabuladorListaPrecio = lngCveTabulador
    
End Function

Public Function frsCatalogoSAT(strNombreCatalogo As String) As Recordset
    Dim strSql As String
    strSql = "select GNCatalogoSATDetalle.intIdRegistro, GNCatalogoSATDetalle.vchClave || ' - ' || GNCatalogoSATDetalle.vchDescripcion" & _
    " from GNCatalogoSAT inner join GNCatalogoSATDetalle on GNCatalogoSAT.intIdCatalogoSAT = GNCatalogoSATDetalle.intIdCatalogoSAT" & _
    " where GNCatalogoSAT.vchNombreCatalogo = '" & strNombreCatalogo & "' and GNCatalogoSATDetalle.bitActivo = 1"

    
    If vgstrVersionCFDI = "3.3" Then
        strSql = strSql & " and GNCatalogoSATDetalle.VCHCLAVE <> 'S01' and GNCatalogoSATDetalle.VCHCLAVE <> 'CP01' and GNCatalogoSATDetalle.VCHCLAVE <> 'CN01'"
    Else
        strSql = strSql & " and GNCatalogoSATDetalle.VCHCLAVE <> 'P01'"
    End If
    
    strSql = strSql & " order by vchClave"
    Set frsCatalogoSAT = frsRegresaRs(strSql, adLockReadOnly)
End Function

Public Function fstrCatalogoSATCveDescById(lngId As Long, Optional intCampo As Integer = 0) As String
    Dim strSql As String
    Dim rs As ADODB.Recordset
    strSql = "select vchClave, vchDescripcion" & _
    " from GNCatalogoSATDetalle" & _
    " where GNCatalogoSATDetalle.intIdRegistro = " & lngId
    Set rs = frsRegresaRs(strSql, adLockReadOnly)
    If Not rs.EOF Then
        Select Case intCampo
            Case 0, 1
                fstrCatalogoSATCveDescById = rs.Fields(intCampo).Value
            Case Else
                fstrCatalogoSATCveDescById = rs.Fields(0).Value & " - " & rs.Fields(1).Value
        End Select
    Else
        fstrCatalogoSATCveDescById = ""
    End If
    rs.Close
End Function

Public Function flngCatalogoSATIdByNombreTipo(strNombre As String, lngCveConcepto As Long, strTipo As String, intDiferenciador As Integer) As Long
    Dim strSql As String
    Dim rs As ADODB.Recordset
    strSql = "select D.INTIDREGISTRO" & _
    " from GNCatalogoSAT C" & _
    " inner join GNCatalogoSATDetalle D on D.INTIDCATALOGOSAT = C.INTIDCATALOGOSAT" & _
    " inner join GNCatalogoSATRelacion R on R.INTIDREGISTRO = D.INTIDREGISTRO" & _
    " where C.VCHNOMBRECATALOGO = '" & strNombre & "'" & _
    " and R.INTCVECONCEPTO = " & lngCveConcepto & _
    " and R.CHRTIPOCONCEPTO = '" & strTipo & "'" & _
    " and R.intDiferenciador = " & intDiferenciador
    Set rs = frsRegresaRs(strSql, adLockReadOnly)
    If Not rs.EOF Then
        flngCatalogoSATIdByNombreTipo = rs.Fields(0).Value
    Else
        flngCatalogoSATIdByNombreTipo = 0
    End If
    rs.Close
End Function

Public Function fblnLicenciaCFDI33(vlblnMostrarMensaje As Boolean) As Boolean
    Dim strSql As String
    Dim strEncriptado As String
    Dim rsTemp As ADODB.Recordset
    
    fblnLicenciaCFDI33 = False
    
    If Now > DateSerial(2017, 11, 16) Then
        strSql = "SELECT TRIM(REPLACE(REPLACE(REPLACE(CNEMPRESACONTABLE.VCHRFC,'-',''),'_',''),' ','')) AS RFC, TRIM(SIPARAMETRO.VCHVALOR) AS VALOR " & _
            "FROM SIPARAMETRO,CNEMPRESACONTABLE WHERE " & _
            "CNEMPRESACONTABLE.TNYCLAVEEMPRESA = " & vgintClaveEmpresaContable & " AND SIPARAMETRO.VCHNOMBRE = 'VCHLICENCIACFDI3.3' AND SIPARAMETRO.INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable
        Set rsTemp = frsRegresaRs(strSql)
        If Not rsTemp.EOF Then
            strEncriptado = fstrEncrypt(rsTemp!RFC, "CFDINTERNET0410993.3")
            fblnLicenciaCFDI33 = IIf(rsTemp!Valor = strEncriptado, True, False)
        End If
    Else
        fblnLicenciaCFDI33 = True
    End If
    
    If fblnLicenciaCFDI33 = False And vlblnMostrarMensaje = True Then
        ' No se adquirió licencia para emitir CFDi en su versión 3.3
        MsgBox SIHOMsg(1087) & " en su versión 3.3.", vbCritical, "Mensaje"
    End If
End Function


Public Sub pBorraExamencaja()
   'Borra los registro existentes en el modulo de caja, que sean nuevos en el modulo de laboratorio y los que se borran definitivamente
   Dim strSql As String
   Dim strSQL1 As String
   Select Case intSelectExam       'Selecciona tipo de examen
                Case 1
                     'Examenes
                     strSql = "DELETE FROM PVDETALLELISTA PV WHERE PV.CHRTIPOCARGO = 'EX' AND PV.chrcvecargo = " & Trim(vgintClaveexamen)
                     Set rsExamencaja = frsRegresaRs(strSql)
                     
                     strSQL1 = "DELETE FROM PVCOSTOCARGOS PVC WHERE PVC.CHRTIPO = 'EX' AND PVC.INTCVECARGO = " & Trim(vgintClaveexamen)
                     Set rsExamencaja = frsRegresaRs(strSQL1)
                Case 2
                    'Grupo de Examenes
                    strSql = "DELETE FROM PVDETALLELISTA PV WHERE PV.CHRTIPOCARGO = 'GE' AND PV.chrcvecargo = " & Trim(vgintClaveexamen)
                    Set rsExamencaja = frsRegresaRs(strSql)
                    
                     strSQL1 = "DELETE FROM PVCOSTOCARGOS PVC WHERE PVC.CHRTIPO = 'GE' AND PVC.INTCVECARGO = " & Trim(vgintClaveexamen)
                     Set rsExamencaja = frsRegresaRs(strSQL1)
   End Select
   vgintClaveexamen = 0
End Sub

Public Function fblnChequeraActiva(vlintNumeroBanco As Integer) As Boolean
'-------------------------------------------------------------------------------------
' Determina si los folios de la chequera aún son válidos
'-------------------------------------------------------------------------------------
    Dim rsChequeraActiva As New ADODB.Recordset
    Dim vlstrSentencia As String
    
    fblnChequeraActiva = False
    vlstrSentencia = "select count(*) from cpFolioCheque where tnyNumeroBanco=" + str(vlintNumeroBanco) + " and bitEstatusChequera=1"
    Set rsChequeraActiva = frsRegresaRs(vlstrSentencia)
    If rsChequeraActiva.RecordCount <> 0 Then
        If rsChequeraActiva.Fields(0) <> 0 Then
            fblnChequeraActiva = True
        End If
    End If
End Function

Public Function flngFolioCheque(vlintNumeroBanco As Integer) As Double
'-------------------------------------------------------------------------------------
' Toma el folio actual de la chequera y lo aumenta si el nuevo folio actual
' es mayor al folio final desactiva la chequera
'-------------------------------------------------------------------------------------
 On Error GoTo NotificaError
    Dim vlstrSentencia As String
    Dim rsDatosChequera As New ADODB.Recordset
    Dim lngContador As Double
    Dim lngFolioActivo As Long
    
    flngFolioCheque = 0
    vlstrSentencia = "select intFolioActual,intFolioFinal,SmiNumeroRegistro from CpFolioCheque where tnyNumeroBanco=" + str(vlintNumeroBanco) + " and bitEstatusChequera=1"
    Set rsDatosChequera = frsRegresaRs(vlstrSentencia)
    If rsDatosChequera.RecordCount <> 0 Then
        vlstrSentencia = ""
        If (rsDatosChequera!intFolioActual + 1) > rsDatosChequera!intFolioFinal Then
            vlstrSentencia = "update CpFolioCheque set intFolioActual = " & CStr(rsDatosChequera!intFolioActual + 1) & ", bitEstatusChequera = 0 Where smiNumeroRegistro = " + str(rsDatosChequera!smiNumeroRegistro)
            'tenemos el folio final, vemos si se puede utilizar
             lngFolioActivo = 1
             vgstrParametrosSP = CStr(vlintNumeroBanco) & "|" & CStr(rsDatosChequera!intFolioActual) & "|2"
             frsEjecuta_SP vgstrParametrosSP, "sp_CpValidaFolio", True, lngFolioActivo
             If lngFolioActivo = 0 Then flngFolioCheque = rsDatosChequera!intFolioActual
        Else
            For lngContador = rsDatosChequera!intFolioActual To rsDatosChequera!intFolioFinal
                'Verifica que el folio se pueda usar
                lngFolioActivo = 1
                vgstrParametrosSP = CStr(vlintNumeroBanco) & "|" & CStr(lngContador) & "|2"
                frsEjecuta_SP vgstrParametrosSP, "sp_CpValidaFolio", True, lngFolioActivo
                If lngFolioActivo = 0 Then
                    vlstrSentencia = "Update CpFolioCheque Set intFolioActual = " & CStr(lngContador + 1) & " Where smiNumeroRegistro = " & str(rsDatosChequera!smiNumeroRegistro)
                    flngFolioCheque = lngContador
                    Exit For
                End If
            Next lngContador
        End If
        ' si por alguna razon la chequera esta activa y no tiene folios entonces la desactivamos
        
        If vlstrSentencia = "" Then
           If flngFolioCheque = 0 Then
              vlstrSentencia = "update CpFolioCheque set bitEstatusChequera = 0 Where smiNumeroRegistro = " + str(rsDatosChequera!smiNumeroRegistro)
              pEjecutaSentencia vlstrSentencia
           End If
        Else
              pEjecutaSentencia vlstrSentencia
        End If
    End If
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":flngFolioCheque"))
End Function

Public Function fstrValorPorDefecto(vlngLogin As Long, vlintProceso As Integer) As String
  'Funcion para saber por medio del login y el proceso cual será el valor por defecto en el proceso
  
  Dim SQL As String
  Dim rs As New ADODB.Recordset
    
  SQL = "SELECT VCHVALORPORDEFECTO"
  SQL = SQL & "   FROM GNVALORPORDEFECTO"
  SQL = SQL & "   where intnumerologin = " & vlngLogin
  SQL = SQL & "   and intproceso = " & vlintProceso
  Set rs = frsRegresaRs(SQL)
  If rs.RecordCount > 0 Then
    fstrValorPorDefecto = rs!VCHVALORPORDEFECTO
  Else
    fstrValorPorDefecto = "-1"
  End If
  rs.Close
  
End Function

Public Sub pActualizaValorPorDefecto(vlngLogin As Long, vlintProceso As Integer, vstrValor As String)
    Dim SQL As String
   
    If vlngLogin > 0 Then
        SQL = "delete from GNVALORPORDEFECTO where intnumerologin = " & vlngLogin & _
              " and intproceso = " & vlintProceso
        pEjecutaSentencia SQL
        SQL = "insert into GNVALORPORDEFECTO (intnumerologin, intproceso, VCHVALORPORDEFECTO) values(" & IIf(vlngLogin > 0, vlngLogin, "null") & "," & vlintProceso & ",'" & vstrValor & "')"
        pEjecutaSentencia SQL
    End If
End Sub

Public Function fstrPruebaCancelacionNE(strUUId As String) As String
    Dim strRespuesta As String
    Dim strMensaje As String
    Dim strSentencia As String
    Dim rsRespuestaWS As New ADODB.Recordset
    Dim intMensaje As Integer
    
    strSentencia = "Select idmensaje From pruebacancelacionne Where uuid = '" & strUUId & "'"
    Set rsRespuestaWS = frsRegresaRs(strSentencia)
    If rsRespuestaWS.RecordCount > 0 Then
        Select Case IIf(IsNull(rsRespuestaWS!idmensaje), 999, rsRespuestaWS!idmensaje)
            Case 101
                strMensaje = "101 - Comprobante No Cancelable por que contiene el complemento de pagos."
                intMensaje = 101
            Case 102
                strMensaje = "102  Comprobante No Cancelable por que contiene documentos relacionados."
                intMensaje = 102
            Case 103
                strMensaje = "103  El CFDI ha sido Cancelado Previamente por Aceptación del Receptor."
                intMensaje = 103
            Case 104
                strMensaje = "104  El CFDI no se puede Cancelar por que fue Rechazado Previamente."
                intMensaje = 104
            Case 105
                strMensaje = "105  El CFDI no se puede Cancelar por que tiene Estatus de ""En espera de Aceptación"""
                intMensaje = 105
            Case 106
                strMensaje = "106  El CFDI no se puede Cancelar por que tiene Estatus de ""En Proceso""."
                intMensaje = 106
            Case 107
                strMensaje = "107  El CFDI ha sido Cancelado por Plazo Vencido."
                intMensaje = 107
            Case 201
                strMensaje = "201 - Comprobante Cancelado sin Aceptación."
                intMensaje = 201
            Case 2011
                strMensaje = "201 - Comprobante En Proceso de ser Cancelado."
                intMensaje = 201
            Case 202
                strMensaje = "202 - Comprobante previamente cancelado."
                intMensaje = 202
            Case 203
                strMensaje = "203 - UUID no corresponde con el emisor."
                intMensaje = 203
            Case 205
                strMensaje = "205 - Comprobante no encontrado."
                intMensaje = 205
            Case 301
                strMensaje = "301 - XML mal formado."
                intMensaje = 301
            Case 302
                strMensaje = "302  Sello mal formado o Invalido."
                intMensaje = 302
            Case 303
                strMensaje = "303  Sello no corresponde con el Emisor."
                intMensaje = 303
            Case 304
                strMensaje = "304 - Certificado Revocado o Caduco"
                intMensaje = 304
            Case 305
                strMensaje = "305  Fecha de Cancelación no está dentro de la vigencia del CSD del Emisor."
                intMensaje = 305
            Case 306
                strMensaje = "306 - Certificado no es de tipo CSD."
                intMensaje = 306
            Case 308
                strMensaje = "308 - Certificado revocado o caduco."
                intMensaje = 308
            Case 96
                strMensaje = "96  - Usuario o contraseña incorrecta."
                intMensaje = 96
            Case 97
                strMensaje = "97  No hay créditos disponibles."
                intMensaje = 97
        End Select
        strRespuesta = "<Cancelacion xmlns:xsd=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" RfcEmisor=""MAG041126GT8"" Fecha=""2018-08-28T12:55:36"" xmlns=""http://cancelacfd.sat.gob.mx""><Folios>" & _
                       "<UUID>" & Trim(strUUId) & " </UUID>" & _
                       "<UUIDEstatus>" & intMensaje & "</UUIDEstatus>" & _
                       "<UUIDdescripcion>" & strMensaje & " </UUIDdescripcion>" & _
                       "<UUIDfecha>2018-08-28T12:55:36 </UUIDfecha></Folios><Signature>no:signature</Signature></Cancelacion>"
        fstrPruebaCancelacionNE = strRespuesta
    Else
        fstrPruebaCancelacionNE = ""
    End If
    
End Function

Public Function fblnFacturaCancelable(vlstrFolio As String) As Boolean
    Dim vlstrSentencia As String                'Sirve pa TODOS los RS's
    Dim rsFacturasPaquete As New ADODB.Recordset
    Dim vlrsTemp As New ADODB.Recordset
    Dim rsChecaCredito As New ADODB.Recordset
    Dim rsHonoFacutraProv As New ADODB.Recordset
    Dim rsFacturaHono As New ADODB.Recordset
    
    Dim vllngConsecutivoFactura As Long
    Dim vlStrTipoPaciente As String
    Dim vllngCuentaPaciente As Long
    Dim vlstrFacturaPacienteEmpresa As String
    Dim vlstrtipofactura As String
    Dim vlblnValidarFacturaEmpresa As Boolean
    Dim vlblnSePuedeCancelar As Boolean
    Dim vlstrNotasAutomaticas As String
    Dim lintCveEmpresaPac As Long
    Dim vllngCveCarta As Long

    vlstrFolio = Trim(vlstrFolio)
    vlstrSentencia = "SELECT INTCONSECUTIVO " & _
                     "     , CHRTIPOPACIENTE " & _
                     "     , INTMOVPACIENTE  " & _
                     "     , CHRTIPOFACTURA " & _
                     "     , intCveVentaPublico " & _
                     "     , intCveCarta " & _
                     "  FROM PVFACTURA " & _
                     " WHERE CHRFOLIOFACTURA  = '" & vlstrFolio & "'"
    Set vlrsTemp = frsRegresaRs(vlstrSentencia)
    If vlrsTemp.RecordCount > 0 Then
        vllngConsecutivoFactura = vlrsTemp!intConsecutivo
        vlStrTipoPaciente = vlrsTemp!CHRTIPOPACIENTE
        vllngCuentaPaciente = vlrsTemp!INTMOVPACIENTE
        vlstrFacturaPacienteEmpresa = vlrsTemp!chrTipoFactura
        vlstrtipofactura = IIf(vlrsTemp!intCveVentaPublico = 0, "N", IIf(vlrsTemp!intCveVentaPublico = -1, "T", "D"))
        vllngCveCarta = IIf(IsNull(vlrsTemp!intCveCarta), 0, vlrsTemp!intCveCarta)
    End If
    vlrsTemp.Close
     
    '|  Por defecto la función regresa "False" a menos que llegue hasta el final
    fblnFacturaCancelable = False
    
    '|--------------------------------------------------------------------------------------------
    '|  Valida que no tenga créditos incluídos en un paquete de cobranza.
    '|--------------------------------------------------------------------------------------------
    vlstrSentencia = "SELECT * " & _
                     "  FROM CCMOVIMIENTOCREDITO " & _
                     "       INNER JOIN CCDETALLEPAQUETECOBRANZA ON CCDETALLEPAQUETECOBRANZA.INTNUMCREDITO = CCMOVIMIENTOCREDITO.INTNUMMOVIMIENTO " & _
                     " WHERE CHRFOLIOREFERENCIA  = '" & vlstrFolio & "'" & _
                     "   AND CCMOVIMIENTOCREDITO.BITCANCELADO = 0 AND CCMOVIMIENTOCREDITO.CHRTIPOREFERENCIA = 'FA'"

    Set rsFacturasPaquete = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
    If rsFacturasPaquete.RecordCount > 0 Then
        '|  No se puede cancelar el documento, los créditos fueron incluídos en un paquete de cobranza.
        MsgBox SIHOMsg(718), vbOKOnly + vbExclamation, "Mensaje"
        Exit Function
    End If
    
    '|-----------------------------------------------------------------
    '|  Identifica si se validarán los datos de la empresa
    '|-----------------------------------------------------------------
    vgstrParametrosSP = vllngCuentaPaciente & "|" & str(vgintClaveEmpresaContable)
    'Internos ó Externos
    Set vlrsTemp = IIf(vlStrTipoPaciente = "I", frsEjecuta_SP(vgstrParametrosSP, "SP_PVSELINTERNOFACTURA"), frsEjecuta_SP(vgstrParametrosSP, "SP_PVSELEXTERNOFACTURA"))
    If vlrsTemp.RecordCount > 0 Then
        If vlrsTemp!bitUtilizaConvenio = 1 And vlrsTemp!bitAseguradora = 1 Then
            vlblnValidarFacturaEmpresa = IIf(vlstrFacturaPacienteEmpresa = "P", True, False)
            lintCveEmpresaPac = IIf(IsNull(vlrsTemp!cveEmpresa), 0, vlrsTemp!cveEmpresa)
        End If
    End If
    vlrsTemp.Close
        
    '|-----------------------------------------------------------------
    '|  Valida los datos de la empresa
    '|-----------------------------------------------------------------
    If vlblnValidarFacturaEmpresa = 4 Then
        'Si la factura está en PvFacturaParcialEmpresa, no se puede cancelar
        'porque significa que ya se descontó en una factura de la empresa
        vlstrSentencia = "SELECT * FROM PvFacturaParcialEmpresa WHERE intFacturaParcial = " & vllngConsecutivoFactura
        Set vlrsTemp = frsRegresaRs(vlstrSentencia)
        If vlrsTemp.RecordCount = 8555 Then
            '|  Para poder cancelar la factura del paciente, se debe cancelar primero la factura de la empresa
            MsgBox SIHOMsg(983), vbExclamation, "Mensaje"
            Exit Function
        Else
            '|  Si todos los cargos (no excluídos) de la cuenta están facturados, no se puede facturar
            '|  porque significa que ya se facturó todo a la empresa
            vlstrSentencia = "SELECT COUNT(*) cargos " & _
                             "  FROM PvCargo " & _
                             " WHERE bitExcluido = 0 " & _
                             "   AND chrTipoPaciente = '" & vlStrTipoPaciente & "'" & _
                             "   AND intMovPaciente = " & vllngCuentaPaciente & " and intCveCarta = " & vllngCveCarta
            Set vlrsTemp = frsRegresaRs(vlstrSentencia)
            If vlrsTemp!Cargos > 0 Then
                vlstrSentencia = "SELECT * " & _
                                 "  FROM PvCargo " & _
                                 " WHERE bitExcluido = 0 " & _
                                 "   AND chrTipoPaciente = '" & vlStrTipoPaciente & "'" & _
                                 "   AND intMovPaciente = " & vllngCuentaPaciente & _
                                 "   AND chrFolioFactura Is Null and intCveCarta = " & vllngCveCarta
                Set vlrsTemp = frsRegresaRs(vlstrSentencia)
                If vlrsTemp.EOF Then
                    'Si la configuracion del control, no tiene que se calcula en base a los cargos seleccionados, se puede cancelar
                    Set vlrsTemp = frsEjecuta_SP(str(vgintClaveEmpresaContable) & "|" & vllngCuentaPaciente & "|" & vlStrTipoPaciente & "|" & lintCveEmpresaPac & "|" & vllngCveCarta, "SP_PVSELCONTROLASEGURADORAPAC")
                    If Not vlrsTemp.EOF Then
                        If Not IsNull(vlrsTemp!BITCALCULARENBASEACARGOS) Then
                            If vlrsTemp!BITCALCULARENBASEACARGOS = 1 Then
                                '|  Para poder cancelar la factura del paciente, se debe cancelar primero la factura de la empresa
                                MsgBox SIHOMsg(983), vbExclamation, "Mensaje"
                                Exit Function
                            End If
                        End If
                    End If
                End If
            End If
        End If
        vlrsTemp.Close
    End If
        
    '|-------------------------------------------------------------------------
    '|  Validación de las facturas parciales
    '|-------------------------------------------------------------------------
    vlstrSentencia = "SELECT PvFacturasParciales.INTFACTURABASE " & _
                     "  FROM PvFacturasParciales " & _
                     " WHERE PvFacturasParciales.INTFACTURAPARCIAL = " & vllngConsecutivoFactura
    Set vlrsTemp = frsRegresaRs(vlstrSentencia)

    'Si aun no se ha facturado la base de la factura parcial o es una factura base
    If IsNull(vlrsTemp!INTFACTURABASE) Or vlrsTemp.RecordCount = 0 Then
        vlblnSePuedeCancelar = True
    End If
    vlrsTemp.Close
    
    If vlblnSePuedeCancelar Then
         vlstrSentencia = "SELECT CPHONORARIOCONTRARECIBO.INTNUMEROCXP FROM CPHONORARIOCONTRARECIBO " & _
                                    "INNER JOIN CPCUENTAPAGARMEDICO ON CPCUENTAPAGARMEDICO.INTNUMCUENTAPAGAR = CPHONORARIOCONTRARECIBO.INTCONSECUTIVOHONORARIO " & _
                                    "WHERE CPCUENTAPAGARMEDICO.INTNUMCUENTAPAGAR IN " & _
                                    "(SELECT PVFACTURAHONORARIOMEDAUTOMATIC.INTNUMCUENTAPAGAR FROM PVFACTURAHONORARIOMEDAUTOMATIC WHERE PVFACTURAHONORARIOMEDAUTOMATIC.CHRFOLIOFACTURA = '" & vlstrFolio & "')"
        Set rsHonoFacutraProv = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
        If rsHonoFacutraProv.RecordCount > 0 Then
            'Set rsHonoFacutraProv = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
            vlstrSentencia = "SELECT CPCUENTAPAGAR.VCHNUMEROFACTURA, COPROVEEDOR.VCHNOMBRE FROM CPCUENTAPAGAR INNER JOIN COPROVEEDOR ON CPCUENTAPAGAR.INTCVEPROVEEDOR = COPROVEEDOR.INTCVEPROVEEDOR WHERE INTNUMEROCXP = " & rsHonoFacutraProv!INTNUMEROCXP
            Set rsFacturaHono = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
            fblnFacturaCancelable = False
            'No se puede cancelar la factura porque contiene un honorario médico que fue registrado a una factura de proveedor.
            MsgBox SIHOMsg(1594) & vbCrLf & vbCrLf & "Proveedor:" & vbCrLf & rsFacturaHono!vchNombre & vbCrLf & vbCrLf & "Factura:" & vbCrLf & rsFacturaHono!VCHNUMEROFACTURA, vbCritical, "Mensaje"
            Exit Function
        End If
    End If
        
    If vlblnSePuedeCancelar Then
        '----------------------------------------------------------------------------'
        ' Checo que no tenga notas de crédito automáticas relacionadas a la factura  '
        '----------------------------------------------------------------------------'
        vlstrSentencia = "  Select CcNota.CHRFOLIONOTA, CcNota.DTMFECHA " & _
                         "    From CcNota " & _
                         "         Inner Join CcNotafactura On (CcNota.INTCONSECUTIVO = CcNotafactura.intConsecutivo) " & _
                         "   Where CcNotafactura.chrFolioFactura = '" & Trim(vlstrFolio) & "' " & _
                         "     And chrTipoFolio = 'FA' " & _
                         "     And BITAUTOMATICA = 1 " & _
                         "     And chrEstatus <> 'C'"
        Set rsChecaCredito = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
        vlstrNotasAutomaticas = ""
        If rsChecaCredito.RecordCount > 0 Then
            While Not rsChecaCredito.EOF
                vlstrNotasAutomaticas = vlstrNotasAutomaticas & ", " & Trim(rsChecaCredito!chrFolioNota) & " [" & Format(rsChecaCredito!dtmfecha, "dd/mm/yyyy") & "]"
                rsChecaCredito.MoveNext
            Wend
            vlstrNotasAutomaticas = Mid(vlstrNotasAutomaticas, 3, Len(vlstrNotasAutomaticas))
            '|  No se puede cancelar el documento el crédito tiene pagos registrados.
            MsgBox "Comprobante no cancelable porque contiene elementos relacionados." & vbCrLf & "Folio(s): " & Trim(vlstrNotasAutomaticas), vbCritical, "Mensaje"
            Exit Function
        End If
        rsChecaCredito.Close
    End If
        
    If vlblnSePuedeCancelar Then
        '------------------------------------------------------------------------'
        ' Checo que esa factura no tenga pagos registrados en Crédito y cobranza '
        '------------------------------------------------------------------------'
        vlstrSentencia = " SELECT COUNT(intNumMovimiento) " & _
                         "   FROM CcMovimientoCredito " & _
                         "  WHERE chrFolioReferencia = '" & Trim(vlstrFolio) & "'" & _
                         "    AND chrTipoReferencia = 'FA' " & _
                         "    AND mnyCantidadPagada > 0 "
        Set rsChecaCredito = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
        If rsChecaCredito.Fields(0) > 0 Then
            '|  No se puede cancelar el documento el crédito tiene pagos registrados.
            MsgBox SIHOMsg(368), vbCritical, "Mensaje"
            Exit Function
        End If
        rsChecaCredito.Close
    Else
        'Para poder cancelar una factura parcial, antes se tiene que cancelar la factura base
        MsgBox SIHOMsg(634), vbOKOnly + vbInformation, "Mensaje"
    End If
       
    '|  Pasó todas las validaciones por lo tanto se puede cancelar
    fblnFacturaCancelable = True
        
End Function


Public Sub pCancelaCFDiFacturaSiHO(vlstrFolio As String, vlstrEstadoFactura As String, vllngPersonaGraba As Long, ldblHonorariosFacturados As Double, vlstrNombreForma As String, Optional vlblnMuestraMensajes As Boolean)

    '******************************************************************************************************
    'CUALQUIER CAMBIO EN ESTE PROCEDIMIENTO DEBE TAMBIEN AFECTAR A PCANCELARFACTURA EN EL MODPROCEDIMIENTOS
    '******************************************************************************************************
    '-------------------------------'
    ' Sólo cancelación de Pacientes '
    '-------------------------------'
    Dim rsNotaCreditoComprobante As New ADODB.Recordset
    Dim rsDC As New ADODB.Recordset             'Es el detalle corte pero como consulta
    Dim rsChecaCredito As New ADODB.Recordset   'RS para saber si la factura fue a crédito y ya tiene pagos
    Dim rsPvDetalleCorte As New ADODB.Recordset 'Aqui añado los registros del detalle del corte
    Dim vlrsTemp As New ADODB.Recordset         'RS Temporal para lo que sea
    Dim rsCorteTiKets As New ADODB.Recordset    'RS para guardar los tikets que se estan reactivando despues de cancelar la factura
    Dim rsChequeTransCta As New ADODB.Recordset
    Dim rsPagosFactura As New ADODB.Recordset   'Pagos y salidas de dinero que contempla la factura
    
    Dim vllngCompNota As Long
    
    Dim vlstrSentencia As String                'Sirve pa TODOS los RS's
    Dim vllngNumeroCorte As Long                'Trae el numero de corte actual
    Dim vlchrInternoExterno As String
    Dim vllngMovimientoPac As Long
    
    Dim vlblnCorteValido As Boolean
    Dim vllngNumCorteFactura As Long            'Es el número de corte en el que se registró la factura.
    Dim vllngCorteGrabando As Long
    Dim vlblnSePuedeCancelar As Boolean
    
    'Varibles para la cancelación de paquetes
    Dim vllngCvePaqueteAnterior As Long
    Dim vllngCvePaquete As Long
    Dim vldblPrecioPaquete As Double
    Dim vldblIVAPaquete As Double
    Dim vlrsPaquete As New ADODB.Recordset
    Dim vlblnMayorIVAaCredito As Boolean    'Sirve para saber si se va a ir el mayor IVA posible a Crédito
    Dim vldblIVA As Double                  'Solo para cálculos de IVA en los Cargos (CA, OD y OC)
    Dim vldblTotalIVA As Double             'Solo para cálculos de totales de IVA en los Cargos (CA, OD y OC)
    Dim vldblIVACredito As Double           'Solo para cálculos de IVA a crédito en los Cargos (CA, OD y OC)
    Dim vldblTotalIVACredito As Double      'Solo para cálculos de totales de IVA a crédito en los Cargos (CA, OD y OC)
    Dim vldblIVAGeneral As Double           'Iva declarado en los paámetros del módulo
    Dim vlintErrorAlBorrarCargo As Long
    Dim vllngMensaje As Long                'Mensaje que se recibe al momento de validar el corte
    Dim rs As New ADODB.Recordset           'Usos varios
    Dim blnFacturaAutomatica As Boolean     'Indica si la factura se generó automáticamente en una venta al público
    Dim strFolioTicketAut As String         'Folio del ticket que originó la factura automática
    Dim rsTickets As ADODB.Recordset
    Dim rsMovimientosT As ADODB.Recordset
    Dim rsCortePoliza As ADODB.Recordset
    Dim rsCredito As ADODB.Recordset
    Dim blnInsertoMovimientos As Boolean
    Dim lngContador As Long
    Dim lngMovimientoCredito As Long
    Dim vllngCorteUsado As Long
    Dim vldblTipoCambioDeCo As Double
    Dim strParametros As String
    Dim vlintTotalTickets As Integer
    Dim vlblnbandera As Boolean
    Dim vlstrFolioFactura As String
    Dim rsRefacturada As New ADODB.Recordset
    Dim vllngConsecutivoRefacturada As Long
    Dim strSentencia As String
    Dim vlngSigReg As Long
    Dim vlblnFactAutomatica As Boolean
    Dim vlintFacturacionConsolidada As Integer
    Dim rsAplAnt As ADODB.Recordset
    Dim lngAplAnt As Long
    
    Dim vllngConsecutivoFactura As Long
    Dim vlStrTipoPaciente As String
    Dim vllngCuentaPaciente As Long
    Dim vlstrFacturaPacienteEmpresa As String
    Dim vlstrtipofactura As String
    Dim rsCantidadNota As New ADODB.Recordset
    Dim vldblCantidadNota As Double
    Dim vlblnCancelacionContable As Boolean
    Dim vlblncontrolaseguradora As Boolean
    Dim vllngCveEmpresaConvenio As Long
    Dim vlstrRazonSocial As String
    Dim RsbitCancelaCFDiNOSAT As New ADODB.Recordset
    Dim vllngCveCarta As Long
   
    
    blnFacturaAutomatica = False
    strFolioTicketAut = ""
    blnInsertoMovimientos = False
    vlblnSePuedeCancelar = False
    vlblnFactAutomatica = False
    
    vlstrFolio = Trim(vlstrFolio)
        
    If vlstrEstadoFactura = "NP" Then
        ' se carga parametro para saber si en caso de un error se puede permitir la cancelación del documento en el SIHO para después cancelar en SAT
        strSentencia = "Select vchvalor from SiParametro where VCHNOMBRE = 'BITCANCELACFDINOSAT' and INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable
        Set RsbitCancelaCFDiNOSAT = frsRegresaRs(strSentencia, adLockOptimistic)
        If RsbitCancelaCFDiNOSAT.RecordCount > 0 Then
           vlblnCancelacionContable = True
        Else
           vlblnCancelacionContable = False
        End If
    Else
        '|  Pendiente de cancelar ante el SAT
        If vlstrEstadoFactura = "PC" Then
            vlblnCancelacionContable = False
        Else '| PA = Pendiente de cancelar ante el SAT, NP = No pendiente de cancelar
            vlblnCancelacionContable = True
        End If
    End If
        
    vlstrSentencia = "SELECT INTCONSECUTIVO " & _
                     "     , CHRTIPOPACIENTE " & _
                     "     , INTMOVPACIENTE  " & _
                     "     , CHRTIPOFACTURA " & _
                     "     , intCveVentaPublico " & _
                     "     , chrNombre  " & _
                     "     , intCveCarta  " & _
                     "  FROM PVFACTURA " & _
                     " WHERE CHRFOLIOFACTURA  = '" & vlstrFolio & "'"
    Set vlrsTemp = frsRegresaRs(vlstrSentencia)
    If vlrsTemp.RecordCount > 0 Then
        vllngConsecutivoFactura = vlrsTemp!intConsecutivo
        vlStrTipoPaciente = vlrsTemp!CHRTIPOPACIENTE
        vllngCuentaPaciente = vlrsTemp!INTMOVPACIENTE
        vlstrFacturaPacienteEmpresa = vlrsTemp!chrTipoFactura
        vlstrtipofactura = IIf(vlrsTemp!intCveVentaPublico = 0, "N", IIf(vlrsTemp!intCveVentaPublico = -1, "T", "D"))
        vlstrRazonSocial = vlrsTemp!CHRNOMBRE
        vllngCveCarta = IIf(IsNull(vlrsTemp!intCveCarta), 0, vlrsTemp!intCveCarta)
    End If
    vlrsTemp.Close

    vlblncontrolaseguradora = False
    vgstrParametrosSP = vllngCuentaPaciente & "|" & str(vgintClaveEmpresaContable)
    'Internos ó Externos
    Set vlrsTemp = IIf(vlStrTipoPaciente = "I", frsEjecuta_SP(vgstrParametrosSP, "SP_PVSELINTERNOFACTURA"), frsEjecuta_SP(vgstrParametrosSP, "SP_PVSELEXTERNOFACTURA"))
    If vlrsTemp.RecordCount > 0 Then
        If vlrsTemp!bitUtilizaConvenio = 1 And vlrsTemp!bitAseguradora = 1 Then
            vlblncontrolaseguradora = True
            vllngCveEmpresaConvenio = vlrsTemp!cveEmpresa
        End If
    End If
    vlrsTemp.Close
            
            
    Set vlrsTemp = frsEjecuta_SP(Trim(vlstrFolio), "Sp_PvSelFacturaAutomatica")
    If vlrsTemp.RecordCount > 0 Then
        blnFacturaAutomatica = True
        strFolioTicketAut = vlrsTemp!INTCVEVENTA  'Trim(vlrsTemp!chrFolioTicket)
    End If
    vlrsTemp.Close
    
    If Not fblnValidaCuentaPuenteBanco(vgintClaveEmpresaContable) Then Exit Sub
    If Not fblnValidaCuentaPuenteIngresos(vgintClaveEmpresaContable) Then Exit Sub

    
    '---------------------------------------------------
    ' Cancelación ante la SAT se sacó de la transacción
    '---------------------------------------------------
    Set rsAplAnt = frsRegresaRs("select * from PVAplicacionAnticipo where chrFolioFactura = '" & Trim(vlstrFolio) & "'", adLockReadOnly, adOpenForwardOnly)
    If Not rsAplAnt.EOF Then
        lngAplAnt = rsAplAnt!INTCOMPROBANTE
    Else
        lngAplAnt = 0
    End If
    rsAplAnt.Close
    
    If Not fblnCancelaCFDi(lngAplAnt, "AA") Then
       If vlstrMensajeErrorCancelacionCFDi <> "" Then MsgBox "COMPROBANTE DE EGRESO:" & vbCrLf & vbCrLf & vlstrMensajeErrorCancelacionCFDi, vbOKOnly + vbCritical, "Mensaje"
       Exit Sub
    End If
    pMensajeCanelacionCFDi lngAplAnt, "AA"
    
''''''****************************************************************************
''''''*****  COMENTADO TEMPORALMENTE POR EL NUEVO ESQUEMA DE CANCELACIÓN   *******
''''''****************************************************************************
''''''    'Cancela el comprobante de la nota de crédito relacionada con la factura
''''''    vllngCompNota = 0
''''''    Set rsNotaCreditoComprobante = frsRegresaRs("SELECT INTCOMPROBANTE FROM GNCOMPROBANTEFISCALDIGITAL WHERE TRIM(VCHSERIECOMPROBANTE) || TRIM(VCHFOLIOCOMPROBANTE) IN (SELECT TRIM(CHRFOLIONOTA) FROM CCNOTA WHERE BITAUTOMATICA = 1 AND TRIM(VCHFACTURAIMPRESION) = '" & Trim(vlstrFolio) & "')")
''''''    If rsNotaCreditoComprobante.RecordCount <> 0 Then
''''''        Do While Not rsNotaCreditoComprobante.EOF
''''''            If rsNotaCreditoComprobante!INTCOMPROBANTE <> 0 Then
''''''                vllngCompNota = rsNotaCreditoComprobante!INTCOMPROBANTE
''''''
''''''                If Not fblnCancelaCFDi(vllngCompNota, "CR") Then
''''''                   If vlstrMensajeErrorCancelacionCFDi <> "" Then MsgBox vlstrMensajeErrorCancelacionCFDi, vbOKOnly + vbCritical, "Mensaje"
''''''                   Exit Sub
''''''                End If
''''''                pMensajeCanelacionCFDi vllngCompNota, "CR"
''''''
''''''                If vllngCompNota <> 0 Then
''''''                    frsEjecuta_SP vllngCompNota & "|CR" & "|" & fstrFechaSQL(fdtmServerFecha, fdtmServerHora), "SP_GNUPDCANCELACOMPROBANTEFIS"
''''''                End If
''''''            End If
''''''
''''''            rsNotaCreditoComprobante.MoveNext
''''''        Loop
''''''    End If
    
    '|  Si pudo cancelar la nota automática, cancela la factura
    vlstrMensajeErrorCancelacionCFDi = ""
    If Not fblnCancelaCFDi(vllngConsecutivoFactura, "FA") Then
       If vlstrMensajeErrorCancelacionCFDi <> "" Then MsgBox vlstrMensajeErrorCancelacionCFDi, vbOKOnly + vlintTipoMensajeErrorCancelacionCFDi, "Mensaje"
       Exit Sub
    End If
            
    '|----------------------------------------------------------------------
    '|   Indica se realizará la cancelación contable o no
    '|----------------------------------------------------------------------
    If vlblnCancelacionContable Then
        '-----------------------'
        ' Inicio de Transacción '
        '-----------------------'
        EntornoSIHO.ConeccionSIHO.BeginTrans
        
        '|  Pone la fecha actual como fecha de cancelación en GnComprobanteFiscalDigital
        If lngAplAnt > 0 Then
            frsEjecuta_SP lngAplAnt & "|AA" & "|" & fstrFechaSQL(fdtmServerFecha, fdtmServerHora) & "|'" & vgMotivoCancelacion & "'", "SP_GNUPDCANCELACOMPROBANTEFIS"
        End If
            frsEjecuta_SP vllngConsecutivoFactura & "|FA" & "|" & fstrFechaSQL(fdtmServerFecha, fdtmServerHora) & "|'" & vgMotivoCancelacion & "'", "SP_GNUPDCANCELACOMPROBANTEFIS"

        '-----------------------------------'
        ' Obtener el numero de corte actual '
        '-----------------------------------'
        vllngMensaje = flngCorteValido(vgintNumeroDepartamento, vglngNumeroEmpleado, "P")
        If vllngMensaje <> 0 Then
            MsgBox SIHOMsg(str(vllngMensaje)), vbOKOnly + vbInformation, "Mensaje" 'Que el corte debe ser cerrado por cambio de día, Que no existe corte abierto
            EntornoSIHO.ConeccionSIHO.RollbackTrans
            pEjecutaSentencia " delete from pvpendientescancelarsat where INTCOMPROBANTE =" & vllngConsecutivoFactura & "and CHRTIPOCOMPROBANTE = 'FA'"
            Exit Sub
        End If
         vllngNumeroCorte = flngNumeroCorte(vgintNumeroDepartamento, vglngNumeroEmpleado, "P")
'        vllngCorteGrabando = 1
'        frsEjecuta_SP vllngNumeroCorte & "|Grabando", "Sp_PvUpdEstatusCorte", True, vllngCorteGrabando
         pAgregarMovArregloCorte 0, 0, "", "", 0, 0, False, "", 0, 0, "", 0, 0, "", ""

        '-------------------------------------------------------------------------------------------------------------------'
        ' Borrar la cuenta por pagar del médico y cancela la póliza generada                                                '
        '-------------------------------------------------------------------------------------------------------------------'
        If fblnSePuedeCancelaHonorarioMedico(Trim(vlstrFolio)) Then
            vgstrParametrosSP = Trim(vlstrFolio)
            frsEjecuta_SP vgstrParametrosSP, "Sp_CCDelHonorarioMedicoContado", True
        Else
            EntornoSIHO.ConeccionSIHO.RollbackTrans
            pEjecutaSentencia " delete from pvpendientescancelarsat where INTCOMPROBANTE =" & vllngConsecutivoFactura & "and CHRTIPOCOMPROBANTE = 'FA'"
            Exit Sub
        End If

        '------------------------------------------------------------------------------------------------------------------------'
        ' Obtener la forma en que se facturó, FFS = Separada con factura al paciente, RFS = Consolidada con recibo al paciente
        '------------------------------------------------------------------------------------------------------------------------'
        vlintFacturacionConsolidada = 0
        vlstrSentencia = "Select CHRFORMAFACTURACION " & _
                         "  From pvControlAseguradora " & _
                         " Where pvControlAseguradora.INTMOVPACIENTE = " & vllngCuentaPaciente & _
                         "   And pvControlAseguradora.CHRTIPOPACIENTE = '" & vlStrTipoPaciente & "'"
        Set vlrsTemp = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)           'RS de consulta
        If vlrsTemp.RecordCount > 0 Then
            vlintFacturacionConsolidada = IIf(vlrsTemp!CHRFORMAFACTURACION = "RFS", 1, 0)
        End If
    
    'If vllngCorteGrabando = 2 Then               '(2)
        vllngNumCorteFactura = frsRegresaRs("SELECT intNumCorte FROM PvFactura WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "'").Fields(0)
        '------------------------------------------------------------'
        ' Generar registros al reves en PvDetalleCorte para cancelar '
        '------------------------------------------------------------'
        vlstrSentencia = "SELECT * " & _
                         "  FROM PvDetalleCorte " & _
                         " WHERE chrFolioDocumento = '" & Trim(vlstrFolio) & "'" & _
                         " AND chrTipoDocumento = 'FA'"
        Set rsDC = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)           'RS de consulta
        Set rsPvDetalleCorte = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic) 'RS tipo Tabla
        If rsDC.RecordCount > 0 Then
            With rsPvDetalleCorte
                Do While Not rsDC.EOF
'                        .AddNew
'                        !INTNUMCORTE = vllngNumeroCorte
'                        !DTMFECHAHORA = fdtmServerFecha + fdtmServerHora
'                        !CHRFOLIODOCUMENTO = rsDC!CHRFOLIODOCUMENTO
'                        !CHRTIPODOCUMENTO = rsDC!CHRTIPODOCUMENTO
'                        !intFormaPago = rsDC!intFormaPago
'                        !MNYCANTIDADPAGADA = rsDC!MNYCANTIDADPAGADA * -1  'Cantidad Negativa
'                        !mnytipocambio = rsDC!mnytipocambio
'                        !intfoliocheque = rsDC!intfoliocheque
'                        !intnumcortedocumento = rsDC!intnumcortedocumento
'                        .Update
                     'vllngPersonaGraba,
                    pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, rsDC!chrFolioDocumento, rsDC!chrTipoDocumento, 0, (rsDC!mnyCantidadPagada * -1), _
                    False, (fdtmServerFecha + fdtmServerHora), rsDC!intFormaPago, rsDC!mnytipocambio, rsDC!intfoliocheque, rsDC!intNumCorteDocumento, _
                    1, "", ""
                    
                    rsDC.MoveNext
                Loop
            End With
        End If

        vlstrSentencia = "SELECT DISTINCT chrFolioDocumento, chrTipoDocumento, intFormaPago, " & _
                        "        mnyCantidadPagada, mnyTipoCambio, intFolioCheque, intNumCorteDocumento " & _
                        "   FROM PvDetalleCorte " & _
                        "  WHERE chrFolioDocumento IN (SELECT chrFolioRecibo " & _
                                                       " FROM PvPago " & _
                                                      " WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "' /*AND nvl(bitIncluidoenFactura, 0) <> 1*/ )" & _
                        " AND mnyCantidadPagada > 0 " & _
                        " AND chrTipoDocumento = 'RE' "
        If vlstrFacturaPacienteEmpresa = "P" Then  ' Sólo las facturas de pacientes tienen salidas de Efectivo
            vlstrSentencia = vlstrSentencia & " UNION " & _
                                              " SELECT DISTINCT chrFolioDocumento, chrTipoDocumento, intFormaPago, " & _
                                              "        mnyCantidadPagada, mnyTipoCambio, intFolioCheque, intNumCorteDocumento " & _
                                              "   FROM PvDetalleCorte " & _
                                              "  WHERE chrFolioDocumento IN (SELECT chrFolioRecibo " & _
                                                                            "  FROM PvSalidaDinero " & _
                                                                            " WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "' /*AND nvl(bitIncluidoenFactura, 0) <> 1*/ )" & _
                                               "   AND mnyCantidadPagada > 0 " & _
                                               "   AND chrTipoDocumento = 'SD' "
        End If
        Set rsDC = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly) 'RS de consulta
        vldblTotalIVACredito = 0
        If rsDC.RecordCount > 0 Then
            With rsPvDetalleCorte
                Do While Not rsDC.EOF
                    'Aqui se obtiene el total del Iva a crédito para poder hacer
                    Set vlrsTemp = frsRegresaRs("SELECT PvFormaPago.chrTipo FROM PvFormaPago WHERE PvFormaPago.intFormaPago = " & !intFormaPago, adLockOptimistic, adOpenForwardOnly)
                    If vlrsTemp!chrTipo = "C" Then vldblTotalIVACredito = vldblTotalIVACredito + rsDC!mnyCantidadPagada
'                        .AddNew
'                        !INTNUMCORTE = vllngNumeroCorte
'                        !DTMFECHAHORA = fdtmServerFecha + fdtmServerHora
'                        !CHRFOLIODOCUMENTO = rsDC!CHRFOLIODOCUMENTO
'                        !CHRTIPODOCUMENTO = rsDC!CHRTIPODOCUMENTO
'                        !intFormaPago = rsDC!intFormaPago
'                        !MNYCANTIDADPAGADA = rsDC!MNYCANTIDADPAGADA
'                        !mnytipocambio = rsDC!mnytipocambio
'                        !intfoliocheque = rsDC!intfoliocheque
'                        !intnumcortedocumento = rsDC!intnumcortedocumento
'                        .Update

                    pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, rsDC!chrFolioDocumento, rsDC!chrTipoDocumento, 0, rsDC!mnyCantidadPagada, _
                    False, (fdtmServerFecha + fdtmServerHora), rsDC!intFormaPago, rsDC!mnytipocambio, rsDC!intfoliocheque, rsDC!intNumCorteDocumento, _
                    1, "", ""
                    
                    rsDC.MoveNext
                Loop
            End With
        End If

        '------------------------------------------------------------------------------------------------------'
        ' Registrar en el corte movimientos, solo para Facturas de Tickets, para que se quede la venta intacta '
        '------------------------------------------------------------------------------------------------------'
        If vlstrtipofactura = "T" Then 'Sólo se reactivan las ventas de las facturas de tikets
            vlstrSentencia = "SELECT DISTINCT chrFolioDocumento, " & _
                             " chrTipoDocumento, intFormaPago, mnyCantidadPagada, " & _
                             " mnyTipoCambio, intFolioCheque, intNumCorteDocumento " & _
                             " FROM PvDetalleCorte " & _
                             " WHERE mnyCantidadPagada > 0 " & _
                             " AND chrTipoDocumento = 'TI' " & _
                             " AND chrFolioDocumento IN (SELECT chrFolioTicket FROM PvVentaPublico WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "')"
            Set rsCorteTiKets = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
            If rsCorteTiKets.RecordCount > 0 Then
                'Guardar en el Corte
                With rsPvDetalleCorte
                    Do While Not rsCorteTiKets.EOF
'                            .AddNew
'                            !INTNUMCORTE = vllngNumeroCorte
'                            !DTMFECHAHORA = fdtmServerFecha + fdtmServerHora
'                            !CHRFOLIODOCUMENTO = rsCorteTiKets!CHRFOLIODOCUMENTO
'                            !CHRTIPODOCUMENTO = "TI"
'                            !intFormaPago = rsCorteTiKets!intFormaPago
'                            !MNYCANTIDADPAGADA = rsCorteTiKets!MNYCANTIDADPAGADA
'                            !mnytipocambio = rsCorteTiKets!mnytipocambio
'                            !intfoliocheque = rsCorteTiKets!intfoliocheque
'                            !intnumcortedocumento = rsCorteTiKets!intnumcortedocumento
'                            .Update
                                                            
                        vlstrSentencia = "SELECT PVCQTR.* " & _
                                         "  FROM PVCORTECHEQUETRANSCTA PVCQTR " & _
                                         "       INNER JOIN PVDETALLECORTE PVDC ON PVDC.INTCONSECUTIVO = PVCQTR.INTCONSECUTIVODETCORTE " & _
                                         " WHERE TRIM(PVDC.CHRFOLIODOCUMENTO) = '" & Trim(rsCorteTiKets!chrFolioDocumento) & "' " & _
                                         "   AND TRIM(PVDC.CHRTIPODOCUMENTO) = '" & Trim(rsCorteTiKets!chrTipoDocumento) & "' " & _
                                         "   AND PVDC.INTFORMAPAGO = " & rsCorteTiKets!intFormaPago & _
                                         "   AND PVDC.MNYCANTIDADPAGADA = " & rsCorteTiKets!mnyCantidadPagada & _
                                         "   AND PVDC.MNYTIPOCAMBIO = " & rsCorteTiKets!mnytipocambio & _
                                         "   AND PVDC.INTFOLIOCHEQUE = " & rsCorteTiKets!intfoliocheque & _
                                         "   AND PVDC.intNumCorteDocumento = " & rsCorteTiKets!intNumCorteDocumento & _
                                         " ORDER BY PVCQTR.INTCONSECUTIVODETCORTE"
                        Set rsChequeTransCta = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
                        If rsChequeTransCta.RecordCount > 0 Then
                            pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, rsCorteTiKets!chrFolioDocumento, "TI", 0, rsCorteTiKets!mnyCantidadPagada, _
                            False, (fdtmServerFecha + fdtmServerHora), rsCorteTiKets!intFormaPago, rsCorteTiKets!mnytipocambio, rsCorteTiKets!intfoliocheque, _
                            rsCorteTiKets!intNumCorteDocumento, 1, "", "", False, rsChequeTransCta!CHRRFC, IIf(IsNull(rsChequeTransCta!CHRCLAVEBANCOSAT), "", rsChequeTransCta!CHRCLAVEBANCOSAT), IIf(IsNull(rsChequeTransCta!VCHBANCOORIGENEXTRANJERO), "", rsChequeTransCta!VCHBANCOORIGENEXTRANJERO), IIf(IsNull(rsChequeTransCta!VCHCUENTABANCARIA), "", rsChequeTransCta!VCHCUENTABANCARIA), IIf(IsNull(rsChequeTransCta!dtmfecha), fdtmServerFecha, rsChequeTransCta!dtmfecha)
                        Else
                            pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, rsCorteTiKets!chrFolioDocumento, "TI", 0, rsCorteTiKets!mnyCantidadPagada, _
                            False, (fdtmServerFecha + fdtmServerHora), rsCorteTiKets!intFormaPago, rsCorteTiKets!mnytipocambio, rsCorteTiKets!intfoliocheque, _
                            rsCorteTiKets!intNumCorteDocumento, 1, "", ""
                        End If

                        rsCorteTiKets.MoveNext
                    Loop
                End With
            Else
            'Si no encuentra nada es que fué un ticket que generó factura automática
                'Selecciona los tickets de la factura
                vlstrSentencia = "SELECT chrFolioTicket " & _
                                 "  FROM PvVentaPublico " & _
                                 " WHERE chrTipoRecivo = 'T' " & _
                                 "   AND Trim(chrFolioFactura) = '" & Trim(vlstrFolio) & "'"
                Set rsTickets = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
                vlintTotalTickets = rsTickets.RecordCount
                If rsTickets.RecordCount > 0 Then
                    vlstrSentencia = "SELECT * " & _
                                     "  FROM PvDetallecorte " & _
                                     " WHERE chrFolioDocumento = '" & Trim(vlstrFolio) & "'" & _
                                     "   AND chrTipoDocumento = 'FA'" & _
                                     "   AND mnyCantidadPagada > 0"
                    Set rsDC = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
                    Set rsPvDetalleCorte = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
                    If rsDC.RecordCount > 0 Then
                        With rsPvDetalleCorte
                            Do While Not rsDC.EOF
'                                    .AddNew
'                                    !INTNUMCORTE = vllngNumeroCorte
'                                    !DTMFECHAHORA = rsDC!DTMFECHAHORA
'                                    !CHRFOLIODOCUMENTO = Trim(rsTickets!chrfolioticket)
'                                    !CHRTIPODOCUMENTO = "TI"
'                                    !intFormaPago = rsDC!intFormaPago
'                                    !MNYCANTIDADPAGADA = rsDC!MNYCANTIDADPAGADA
'                                    !mnytipocambio = rsDC!mnytipocambio
'                                    !intfoliocheque = rsDC!intfoliocheque
'                                    !intnumcortedocumento = rsDC!intnumcortedocumento
'                                    .Update
                                pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(rsTickets!chrFolioTicket), "TI", 0, rsDC!mnyCantidadPagada, _
                                False, rsDC!dtmFechahora, rsDC!intFormaPago, rsDC!mnytipocambio, rsDC!intfoliocheque, rsDC!intNumCorteDocumento, _
                                1, "", ""
                                rsDC.MoveNext
                            Loop
                        End With
                        vlblnFactAutomatica = True
                    End If
                End If
                rsTickets.Close
            End If
            rsCorteTiKets.Close
        End If

        ' Cancelación de la factura
        vlstrSentencia = "SELECT chrestatus FROM PvFactura WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "'"
        Set vlrsTemp = frsRegresaRs(vlstrSentencia)
        If vlrsTemp.RecordCount > 0 Then
            If vlrsTemp!chrEstatus = "C" Then
                MsgBox SIHOMsg(1228), vbExclamation, "Mensaje"   'No se puede cancelar esta factura, el estado cambió. Consulte de nuevo.
                EntornoSIHO.ConeccionSIHO.RollbackTrans
                pEjecutaSentencia " delete from pvpendientescancelarsat where INTCOMPROBANTE =" & vllngConsecutivoFactura & "and CHRTIPOCOMPROBANTE = 'FA'"
                Exit Sub
            End If
        End If
        
        vlstrSentencia = "UPDATE PvFactura SET chrEstatus = 'C' WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "'"
        pEjecutaSentencia (vlstrSentencia)

        '----------------------------------'
        ' Actualiza el estatus de la carta '
        '----------------------------------'
        vlstrSentencia = "UPDATE PvCartaControlSeguro SET chrEstatus = 'A'" & _
                         " WHERE intNumCuenta = " & vllngCuentaPaciente & " AND intCveCarta = " & vllngCveCarta
        pEjecutaSentencia (vlstrSentencia)

        ' Eliminación de la factura de facturas parciales
        vlstrSentencia = " DELETE FROM PvFacturasParciales WHERE PvFacturasParciales.INTFACTURAPARCIAL = " & vllngConsecutivoFactura
        pEjecutaSentencia vlstrSentencia

        '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        ' Actualiza las facturas parciales con el número de factura base '
        '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        vlstrSentencia = "UPDATE PvFacturasParciales SET PvFacturasParciales.INTFACTURABASE = NULL "
        vlstrSentencia = vlstrSentencia & " WHERE PvFacturasParciales.INTFACTURABASE = " & vllngConsecutivoFactura
        pEjecutaSentencia vlstrSentencia
        
        '---------------------------------------------------------'
        ' Quita las facturas parciales de PvFacturaParcialEmpresa '
        '---------------------------------------------------------'
        vlstrSentencia = "DELETE FROM PvFacturaParcialEmpresa WHERE PvFacturaParcialEmpresa.INTFACTURAEMPRESA = " & CStr(vllngConsecutivoFactura)
        pEjecutaSentencia vlstrSentencia

        '---------------------------------'
        ' Guardo en documentos cancelados '
        '---------------------------------'
        vlstrSentencia = "SELECT chrFolioDocumento FROM PvDocumentoCancelado WHERE chrFolioDocumento = '" & Trim(vlstrFolio) & "' and trim(chrtipodocumento) = 'FA' and smiDepartamento = " & Trim(str(vgintNumeroDepartamento))
        Set vlrsTemp = frsRegresaRs(vlstrSentencia)
        If vlrsTemp.RecordCount > 0 Then
            '|  No se puede cancelar esta factura, el estado cambió. Consulte de nuevo.
            MsgBox SIHOMsg(1228), vbExclamation, "Mensaje"
            EntornoSIHO.ConeccionSIHO.RollbackTrans
            pEjecutaSentencia " delete from pvpendientescancelarsat where INTCOMPROBANTE =" & vllngConsecutivoFactura & "and CHRTIPOCOMPROBANTE = 'FA'"
            Exit Sub
        End If
        
        vlstrSentencia = "INSERT INTO PVDocumentoCancelado VALUES('" & Trim(vlstrFolio) & "','FA'," & _
                         Trim(str(vgintNumeroDepartamento)) & "," & Trim(str(vllngPersonaGraba)) & ",getdate())"
        pEjecutaSentencia (vlstrSentencia)
        
        '----------------------------------------------------------------------------'
        ' Si es factura automática, se guarda el ticket en los documentos cancelados '
        '----------------------------------------------------------------------------'
        If blnFacturaAutomatica Then
            vlstrSentencia = "INSERT INTO PvDocumentoCancelado VALUES('" & Trim(strFolioTicketAut) & "','TI'," & _
                             Trim(str(vgintNumeroDepartamento)) & "," & Trim(str(vllngPersonaGraba)) & ",getdate())"
            pEjecutaSentencia (vlstrSentencia)
        End If
        
        '-------------------------------------------------------------'
        ' Inserta los movimientos del(los) Ticket(s) en PvCortePoliza '
        '-------------------------------------------------------------'
        If vlstrtipofactura = "T" Then
            'Solo cuando son Facturas(no automáticas, ni directas) del POS
            'Selecciona los tickets de la factura
            vlstrSentencia = "SELECT chrFolioTicket, intCveVenta, intNumCorte FROM PvVentaPublico WHERE chrTipoRecivo = 'T' AND Trim(chrFolioFactura) = '" & Trim(vlstrFolio) & "'"
            Set rsTickets = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
            vlintTotalTickets = rsTickets.RecordCount
            If rsTickets.RecordCount > 0 Then
                rsTickets.MoveFirst
                Do While Not rsTickets.EOF
                    blnInsertoMovimientos = False
                    vgstrParametrosSP = Trim(rsTickets!chrFolioTicket) & "|" & "TI" & "|" & Trim(rsTickets!intNumCorte)
                    Set rsMovimientosT = frsEjecuta_SP(vgstrParametrosSP, "sp_PvSelPolizaDocto")
                    Do While Not rsMovimientosT.EOF
                        pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(rsMovimientosT!chrFolioDocumento), "TI", rsMovimientosT!intNumCuenta, _
                        rsMovimientosT!MNYCantidad, IIf(rsMovimientosT!bitcargo = 1, True, False), "", 0, 0, "", 0, 2, "", ""
                        rsMovimientosT.MoveNext
                        blnInsertoMovimientos = True
                    Loop
                                        
                    'Revive el crédito del ticket
                    vlstrSentencia = " UPDATE CcMovimientoCredito " & _
                                     "    SET bitCancelado = 0," & _
                                     "        dtmFechaCancelacion = Null " & _
                                     "  WHERE chrFolioReferencia = '" & Trim(rsTickets!chrFolioTicket) & "'" & _
                                     "    AND chrTipoReferencia = 'TI' " & _
                                     "    AND mnyCantidadPagada = 0 "
                    pEjecutaSentencia (vlstrSentencia)
                    
                    'Se reactiva el ticket, borrando el registro en pvDcocumentoCancelado
                    vlstrSentencia = " DELETE pvDocumentoCancelado " & _
                                     "  WHERE trim(chrFolioDocumento) = '" & Trim(rsTickets!INTCVEVENTA) & "'" & _
                                     "    AND chrTipoDocumento = 'TI' " & _
                                     "    AND smiDepartamento = " & Trim(str(vgintNumeroDepartamento))
                    pEjecutaSentencia (vlstrSentencia)
                    
                    'Reactivar las formas de pago del ticket en la tabla intermedia -'
                    If intBitCuentaPuenteBanco = 0 Then pActivarTicket rsTickets!INTCVEVENTA, rsTickets!intNumCorte, vllngNumeroCorte, vllngPersonaGraba, vlstrNombreForma
                
                             
                    'Si no insertó nada Quiere decir que el ticket no tenía movimientos porque fué factura automática
                    'Se insertan los movimientos de la factura, con los datos del cliente
                    If Not blnInsertoMovimientos Then
                        vlstrSentencia = "Select Case " & _
                                               "     When " & intBitCuentaPuenteBanco & " = 1  then " & _
                                               "         Case " & _
                                               "             When " & _
                                               "                 fn_pvCuentaRelacionadaConBanco (trim(chrfoliodocumento), intnumcuenta, mnycantidad, trim(chrtipodocumento)) = 1 Then " & lngCuentaPuenteBanco & _
                                               "             Else " & _
                                               "                 INTNUMCUENTA " & _
                                               "         End " & _
                                               "     Else INTNUMCUENTA " & _
                                               " End intnumcuenta " & _
                                              ", mnyCantidad, bitcargo,INTCONSECUTIVO " & _
                                           "From pvcortepoliza " & _
                                          "Where trim(chrfoliodocumento) = '" & Trim(rsTickets!chrFolioTicket) & "' and chrtipomovimiento = 'TIK'" & _
                                           " And trim(chrtipodocumento) = 'TI' " & _
                                       "ORDER BY INTCONSECUTIVO"
                        Set rsMovimientosT = frsRegresaRs(vlstrSentencia)
                           
                        'vlngSigReg = 0
                        Do While Not rsMovimientosT.EOF
                        '    If vlngSigReg = 0 Then
                        '       vlngSigReg = rsMovimientosT!INTCONSECUTIVO
                            pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(rsTickets!chrFolioTicket), "TI", rsMovimientosT!intNumCuenta, _
                                rsMovimientosT!MNYCantidad, IIf(rsMovimientosT!bitcargo = 1, True, False), "", 0, 0, "", 0, 2, "", ""
                          '    Else
                          '        If (vlngSigReg + 1) = rsMovimientosT!INTCONSECUTIVO Then
                          '           vlngSigReg = rsMovimientosT!INTCONSECUTIVO
                          '           pAgregarMovArregloCorte vllngNumeroCorte, Trim(rsTickets!CHRFOLIOTICKET), "TI", rsMovimientosT!intnumcuenta, _
                          '           rsMovimientosT!mnycantidad, IIf(rsMovimientosT!bitcargo = 1, True, False), "", 0, 0, "", 0, 2, "", ""
                          '        Else
                          '           Exit Do
                          '        End If
                          '     End If
                            rsMovimientosT.MoveNext
                        Loop
                        rsMovimientosT.Close
                        'Inserta el movimiento del ticket
                        'Usa los datos de la factura
'                                 vlstrSentencia = "SELECT * FROM CcMovimientoCredito " & _
'                                                    " WHERE Trim(chrFolioReferencia) = '" & Trim(txtFolio.Text) & "'" & _
'                                                    " AND chrTipoReferencia = 'FA' " & _
'                                                    " AND mnyCantidadPagada = 0 "
'                                  Set rsCredito = frsRegresaRs(vlstrSentencia)
'                                  If rsCredito.RecordCount > 0 Then
'                                      vgstrParametrosSP = fstrFechaSQL(Format(rsCredito!dtmFechaMovimiento, "dd/mm/yyyy")) & "|" & _
'                                                    CStr(rsCredito!INTNUMCLIENTE) & "|" & _
'                                                    CStr(rsCredito!intNumCuentaContable) & "|" & _
'                                                    Trim(rsTickets!chrFolioTicket) & _
'                                                    "|TI|" & _
'                                                    CStr(rsCredito!mnyCantidadCredito) & "|" & _
'                                                    CStr(rsCredito!SMIDEPARTAMENTO) & "|" & _
'                                                    CStr(rsCredito!intCveEmpleado) & _
'                                                    "| |0|" & _
'                                                    CStr(rsCredito!MNYSUBTOTAL) & "|" & _
'                                                    CStr(rsCredito!MNYIVA)
'                                      lngMovimientoCredito = 1
'                                      frsEjecuta_SP vgstrParametrosSP, "SP_GNINSCREDITO", True, lngMovimientoCredito
'                                  End If
'                                  rsCredito.Close
                    End If
                    rsTickets.MoveNext
                Loop
            End If
        End If
        
'                '-----------------------------------------------------------'
'                ' Quitar numero de factura del registro de Venta al Público '
'                '-----------------------------------------------------------'
'                'Si es factura automática el bitCancelado queda en 1 como ya estaba
'                vlstrSentencia = "UPDATE PvVentaPublico SET bitCancelado = " & IIf(blnFacturaAutomatica, "1", "0") & " , chrFolioFactura = null WHERE chrFolioFactura = '" & Trim(txtFolio.Text) & "'"
'                pEjecutaSentencia vlstrSentencia
        
        
        'Regresa cantidad de la nota(s)
        strParametros = vlstrFolio & "|" & CStr(vgintClaveEmpresaContable) & "|" & vlStrTipoPaciente & "|" & vllngCuentaPaciente
        Set rsCantidadNota = frsEjecuta_SP(strParametros, "SP_PVSELNOTADECREDITO")
        If rsCantidadNota.RecordCount > 0 Then
            vldblCantidadNota = rsCantidadNota!cantidad
        End If
        
        If vlstrFacturaPacienteEmpresa = "P" And vldblCantidadNota > 0 Then
            '-------------------------------------------'
            ' Activar las notas de crédito del paciente '
            '-------------------------------------------'
            vlstrSentencia = "UPDATE CcNota " & _
                             "   SET chrEstatus = 'A' " & _
                             " WHERE intMovPaciente = " & vllngCuentaPaciente & _
                             "   AND chrTipoPaciente = '" & vlStrTipoPaciente & "'" & _
                             "   AND chrNotaDirigida = 'P' And bitAutomatica = 0 And chrEstatus = 'P' " & _
                             "   AND Trim(vchFacturaImpresion) = '" & Trim(vlstrFolio) & "'"
            pEjecutaSentencia (vlstrSentencia)
           
            If vlblncontrolaseguradora Then
''''''****************************************************************************
''''''*****  COMENTADO TEMPORALMENTE POR EL NUEVO ESQUEMA DE CANCELACIÓN   *******
''''''****************************************************************************
''''''                '-------------------------------------------'
''''''                ' Cancelar las notas de crédito automáticas '
''''''                '-------------------------------------------'
''''''                vlstrSentencia = "UPDATE CcNota SET chrEstatus = 'C', intPersonaBorra = " & CStr(vllngPersonaGraba) & _
''''''                                " WHERE intMovPaciente = " & vllngCuentaPaciente & _
''''''                                " AND chrTipoPaciente = '" & vlStrTipoPaciente & "'" & _
''''''                                " AND chrNotaDirigida = 'P' AND bitAutomatica = 1 " & _
''''''                                " AND Trim(vchFacturaImpresion) = '" & Trim(vlstrFolio) & "'"
''''''                pEjecutaSentencia vlstrSentencia
                
                'Dejar el excedente por honorarios en 0
                vlstrSentencia = "UPDATE PvControlaseguradora " & _
                                 "   SET mnyExcedenteHonorarioEx = 0, mnyExcedenteHonorarioDe = 0, mnyExcedenteHonorarioCo = 0, mnyExcedenteHonorarioCa = 0, mnyExcedenteHonorarioCp = 0 " & _
                                 " WHERE intMovPaciente = " & vllngCuentaPaciente & _
                                 " AND chrTipoPaciente = '" & vlStrTipoPaciente & "'"
                pEjecutaSentencia vlstrSentencia
            End If
        End If
        
        '-----------------------------------------------'
        ' Borrar los movimientos de CCMovimientoCredito '
        '-----------------------------------------------'
        vlstrSentencia = " UPDATE CcMovimientoCredito SET bitCancelado = 1, " & _
                         " dtmFechaCancelacion = " & fstrFechaSQL(fdtmServerFecha) & _
                         " WHERE chrFolioReferencia = '" & Trim(vlstrFolio) & "'" & _
                         " AND chrTipoReferencia = 'FA' " & _
                         " AND mnyCantidadPagada = 0 "
        pEjecutaSentencia (vlstrSentencia)

        '---------------------------------------------------------------'
        ' Actualiza la fecha de facturación en caso de que sea un grupo '
        '---------------------------------------------------------------'
        '| If Not OptTipoPaciente(0).Value And Not OptTipoPaciente(1).Value And vllngCuentaPaciente <> "0" Then
        If vlStrTipoPaciente = "G" And vllngCuentaPaciente <> "0" Then
            vlstrSentencia = "UPDATE PvFacturacionConsolidada SET chrFolioFactura = Null WHERE INTCVEGRUPO = " & vllngCuentaPaciente
            pEjecutaSentencia vlstrSentencia
        End If

        '-----------------------------------------------------------'
        ' Quitar el estatus de "Facturada" a la cuenta del paciente '
        '-----------------------------------------------------------'
        '|If Not OptTipoPaciente(2).Value And Not OptTipoPaciente(3).Value Then
        If vlStrTipoPaciente = "I" Or vlStrTipoPaciente = "E" Then
            'Factura de una cuenta:
            vgstrParametrosSP = vllngCuentaPaciente & "|" & vlStrTipoPaciente & "|" & "0"
            frsEjecuta_SP vgstrParametrosSP, "SP_PVUPDCUENTAFACTURADA"
        Else
            If vlStrTipoPaciente = "G" Then
                'Factura de un grupo
                Set rs = frsEjecuta_SP(CStr(vllngCuentaPaciente), "SP_PVSELCUENTAGRUPO")
                Do While Not rs.EOF
                    vgstrParametrosSP = rs!INTMOVPACIENTE & "|" & rs!CHRTIPOPACIENTE & "|" & "0"
                    frsEjecuta_SP vgstrParametrosSP, "SP_PVUPDCUENTAFACTURADA"
                    rs.MoveNext
                Loop
            End If
        End If
        
        '---------------------------------------------------------'
        ' Quitar o actualizar el folio del control de aseguradora '
        ' Y actualiza mnyHonorariosFacturadosPac                  '
        '---------------------------------------------------------'
        
        If vlstrFacturaPacienteEmpresa = "P" And vlblncontrolaseguradora Then
            'Busca si hay otra factura de paciente por concepto de seguro que no sea parcial y actualiza el Control
            'Si no borra el folio del control y de PvFacturaPacienteConcepto
            'Deja en 0 los exedentes por honorarios
            vgstrParametrosSP = vllngCuentaPaciente & "|" & _
                                vlStrTipoPaciente & "|" & _
                                CStr(vgintClaveEmpresaContable) & "|" & _
                                CStr(vllngConsecutivoFactura) & "|" & _
                                CStr(vllngCveEmpresaConvenio) & "|" & _
                                Trim(vlstrFolio) & "|" & _
                                str(ldblHonorariosFacturados)
            frsEjecuta_SP vgstrParametrosSP, "Sp_PvUpdFacturaBaseOld"
            
        ElseIf vlstrFacturaPacienteEmpresa = "E" And vlblncontrolaseguradora Then
            vgstrParametrosSP = vllngCuentaPaciente & "|" & _
                                vlStrTipoPaciente & "|" & _
                                CStr(vllngCveEmpresaConvenio)
            frsEjecuta_SP vgstrParametrosSP, "Sp_PvUpdFacturaEmpresaOld"
        End If
        
        rsPvDetalleCorte.Close
        rsDC.Close

        'Quita el folio de la factura del paciente de los cargos
        'If vgstrFacturaPacienteEmpresa = "P" And lblnCalcularEnBaseACargos Then
        If vlstrFacturaPacienteEmpresa = "P" Then
            vlstrSentencia = "UPDATE PvCargo SET chrFolioFacturaPaciente = Null, intPaquetesPaciente = 0 WHERE INTMOVPACIENTE = " & vllngCuentaPaciente & " And CHRTIPOPACIENTE = '" & vlStrTipoPaciente & "' And chrFolioFacturaPaciente = '" & RTrim(vlstrFolio) & "'"
            pEjecutaSentencia vlstrSentencia
        End If
    
        pDesAplicarDescuentoPuntos vlstrFolio, vlblncontrolaseguradora, vllngCuentaPaciente

        '-----------------------------------------------------------------'
        ' Quito el numero de factura del cargo, para que los pueda borrar '
        '-----------------------------------------------------------------'
        vlstrSentencia = "SELECT IntNumCargo, intFolioDocumento, chrTipoDocumento " & _
                         "  FROM PvCargo " & _
                         " WHERE PvCargo.CHRFOLIOFACTURA = '" & RTrim(vlstrFolio) & "'"
        Set vlrsTemp = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenStatic)
        
        vlstrSentencia = "UPDATE PvCargo " & _
                         "   SET chrFolioFactura = Null, smiCveConceptoEmpresa = Null " & _
                         " WHERE chrFolioFactura = '" & RTrim(vlstrFolio) & "'"
        pEjecutaSentencia vlstrSentencia
    
        While Not vlrsTemp.EOF
            If Trim(vlrsTemp!chrTipoDocumento) = "T" Then
                If vlstrtipofactura = "D" Then 'Sólo se Borran las facturas del POS que no tienen tickets y las automáticas
                    vlintErrorAlBorrarCargo = 1
                    Dim rsVentaAlmacen As New ADODB.Recordset
                    Dim vlintAlmacenVenta As Integer
                    Dim intMemoria As Integer
                    
                    intMemoria = vgintNumeroDepartamento
                    vlstrSentencia = "SELECT smiCveDepartamento FROM NoDepartamento WHERE NoDepartamento.chrClasificacion = 'A' AND smiCveDepartamento = " & vgintNumeroDepartamento
                    Set rsVentaAlmacen = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
                    If Not rsVentaAlmacen.RecordCount = 0 Then
                        With rsVentaAlmacen
                            vgintNumeroDepartamento = !smicvedepartamento
                        End With
                    Else
                        vlstrSentencia = "SELECT intNumAlmacen FROM PvAlmacenes WHERE intNumDepartamento = " & vgintNumeroDepartamento
                        Set rsVentaAlmacen = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
                        With rsVentaAlmacen
                            vgintNumeroDepartamento = !intnumalmacen
                        End With
                    End If
                            
                    vgstrParametrosSP = vlrsTemp!IntNumCargo & "|" & "EVP" & "|" & vllngPersonaGraba & "|" & vgintNumeroDepartamento & "|" & "T" & "|" & vlrsTemp!intFolioDocumento & "|" & 0 & "|" & "" & "|" & 2
                    frsEjecuta_SP vgstrParametrosSP, "SP_PVUPDBORRACARGO", False, vlintErrorAlBorrarCargo
    
                    vgintNumeroDepartamento = intMemoria
                End If
            End If
            vlrsTemp.MoveNext
        Wend
    
        vlstrSentencia = "DELETE FROM PvCargoExcedente WHERE chrFolioFactura = '" & RTrim(vlstrFolio) & "'"
        pEjecutaSentencia vlstrSentencia
        
        vlstrFolioFactura = Trim(vlstrFolio)
        '------------------------------------------------------------------------------------'
        ' Genera todos los movimientos de la factura en la poliza con el siguiente criterio: '
        '   » Si el Corte en el que se realizó la factura y el corte actual son IGUALES      '
        '       - Si es un Cargo. Cantidad = Cantidad * -1 y Tipo Movimiento = Cargo         '
        '       - Si es un Abono. Cantidad = Cantidad * -1 y Tipo Movimiento = Abono         '
        '   » Si el Corte en el que se realizó la factura y el corte actual son DIFERENTES   '
        '       - Si es un Cargo. Cantidad = Cantidad y Tipo Movimiento = Abono              '
        '       - Si es un Abono. Cantidad = Cantidad y Tipo Movimiento = Cargo              '
        '------------------------------------------------------------------------------------'
        If ((vlstrtipofactura = "D" And vlintTotalTickets = 0)) _
              Or (vlstrtipofactura = "T" And vlblnFactAutomatica = True) _
              Or (intBitCuentaPuenteIngresos = 1 And vlstrtipofactura = "T" And vlintTotalTickets > 0) Then
            '    (vgstrTipoFactura = "D" And vlintTotalTickets = 0)                                             » Factura venta al público automática, No refacturada o Factura venta al público sin ticket
            '    (vgstrTipoFactura = "T" And vlblnFactAutomatica = True)                                        » Factura venta al público automática, refacturada
            '    (intBitCuentaPuenteIngresos = 1 And vgstrTipoFactura = "T" And vlintTotalTickets > 0) Then     » Factura venta al público con tickets (no automática)
              
            'Agregado por caso 10442
            'si la factura es de venta al publico y no tiene tickets,
            'factura de venta al público automática o si es una factura a empresa,
            'se debe cancelar la factura con los movimientos originales,
            'por lo cual busca el folio de factura en la tabla pvRefacturacion por si fue refacturada
            'para buscar las formas de pago de la factura cancelada por la cual fue refacturada
            'ESTA SECCIÓN DE CÓDIGO NO ES NECESARIO INCLUIRLA EN EL PROCEDIMIENTO PCANCELARFACTURA DEL MODPROCEDIMIENTO
            vlblnbandera = False
            vlstrFolioFactura = Trim(vlstrFolio)
            vllngConsecutivoRefacturada = 0
            Do While vlblnbandera = False
                vlstrSentencia = "Select pvRefacturacion.chrfoliofacturacancelada, pvfactura.intconsecutivo " & _
                                 "  From pvRefacturacion,pvfactura " & _
                                 " Where trim(chrfoliofacturaactivada) = '" & vlstrFolioFactura & "'" & _
                                   " and trim(pvRefacturacion.chrfoliofacturacancelada) = trim(pvfactura.chrfoliofactura)"
                Set rsRefacturada = frsRegresaRs(vlstrSentencia, adLockReadOnly, adOpenForwardOnly)
                If rsRefacturada.RecordCount > 0 Then
                    vlstrFolioFactura = Trim(rsRefacturada!chrfoliofacturacancelada)
                    vllngConsecutivoRefacturada = rsRefacturada!intConsecutivo
                Else
                    vlblnbandera = True
                End If
            Loop
        
            If (vlstrtipofactura = "T" And vlintTotalTickets > 0 And vlblnFactAutomatica = False) Then
                'Si el BitCuentaPuenteIngresos = 1 y la factura contiene tickets y no es automática
                pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(vlstrFolio), IIf(vllngConsecutivoRefacturada = 0, "", "FAT"), 0, 0, False, "", 0, 0, "", 0, 6, "", ""
            Else
                'sp_PvUpdCancelaDoctoCorte
                pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(vlstrFolioFactura) & "," & Trim(vlstrFolio), "FAF", 0, 0, _
                False, "", 0, 0, "", -1, 3, "", ""
            End If
        Else
            'vgstrParametrosSP = CStr(vllngNumeroCorte) & "|" & Trim(txtFolio.Text)
            'frsEjecuta_SP vgstrParametrosSP, "Sp_PvInsPolizaCancelaFactura"
            pAgregarMovArregloCorte vllngNumeroCorte, vllngPersonaGraba, Trim(vlstrFolio), "", 0, 0, False, "", 0, 0, "", 0, 6, "", ""
        End If
           
        vlrsTemp.Close
               
        '-------------------------
        ' Agregado para caso 8758
        ' Si el BitCuentaPuenteBanco está activo y la factura es a paciente registra movimientos a cuenta puente que sustituye cuentas de bancos
        If intBitCuentaPuenteBanco = 1 And vlstrFacturaPacienteEmpresa = "P" And vlstrtipofactura <> "D" And vlstrtipofactura <> "T" Then
            'agregado para que no continue cuando no existan folios para pagos
            If Not fblnRegistraPagoCuentasBanco(vllngNumeroCorte, True, 0, vllngPersonaGraba, vllngConsecutivoFactura, vlstrFolioFactura, vllngCuentaPaciente, vlStrTipoPaciente, vlstrRazonSocial, vlstrNombreForma) Then
               pEjecutaSentencia " delete from pvpendientescancelarsat where INTCOMPROBANTE =" & vllngConsecutivoFactura & "and CHRTIPOCOMPROBANTE = 'FA'"
               Exit Sub
            End If
        End If
    
        'agregamos los movimientos al corte
                
        vllngCorteUsado = fRegistrarMovArregloCorte(vllngNumeroCorte)
                    
        If vllngCorteUsado = 0 Then
           EntornoSIHO.ConeccionSIHO.RollbackTrans
           'No se pudieron agregar los movimientos de la operación al corte, intente de nuevo.
           MsgBox SIHOMsg(1320), vbExclamation, "Mensaje"
           pEjecutaSentencia " delete from pvpendientescancelarsat where INTCOMPROBANTE =" & vllngConsecutivoFactura & "and CHRTIPOCOMPROBANTE = 'FA'"
           Exit Sub
        End If
            
        If vllngCorteUsado <> vllngNumeroCorte Then
            vllngNumeroCorte = vllngCorteUsado
        End If
           
        '-----------------------------------------------------------'
        ' Quitar numero de factura del registro de Venta al Público '
        '-----------------------------------------------------------'
        'Si es factura automática el bitCancelado queda en 1 como ya estaba
        vlstrSentencia = "UPDATE PvVentaPublico SET bitCancelado = " & IIf(blnFacturaAutomatica, "1", "0") & " , chrFolioFactura = null WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "'"
        pEjecutaSentencia vlstrSentencia

        '---------------------------------------------------------------------------'
        ' Quitar el cancelado de PAGOS (BitCancelado) y Quitar el numero de factura '
        '---------------------------------------------------------------------------'
        vlstrSentencia = "UPDATE PvPago SET chrFolioFactura = NULL, bitCancelado = 0 " & _
                         " WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "'"
        pEjecutaSentencia (vlstrSentencia)
        
        '----------------------------------------------------------------------------------'
        ' Quitar el cancelado de DEVOLUCIONES (BitCancelado) y Quitar el numero de factura '
        '----------------------------------------------------------------------------------'
        vlstrSentencia = "UPDATE PvSalidaDinero SET chrFolioFactura = NULL, bitCancelado = 0 " & _
                         " WHERE chrFolioFactura = '" & Trim(vlstrFolio) & "'"
        pEjecutaSentencia (vlstrSentencia)

        '--------------------------------------'
        ' Actualiza PVPAQUETEPACIENTEFACTURADO '
        '--------------------------------------'
        strParametros = vllngCuentaPaciente & "|" & vlStrTipoPaciente & "|" & Trim(vlstrFolio)
        frsEjecuta_SP strParametros, "SP_PVUPDPAQUETESFACTURADOS"
                        
        '----------------------------------------------'
        ' Se cancela el movimiento de la forma de pago '
        '----------------------------------------------'
        ' Si el BitCuentaPuenteBanco está activo y la factura es de venta al público sin tickets o
        ' factura a empresa, si se cancela el movimiento
        If intBitCuentaPuenteBanco = 0 _
            Or (intBitCuentaPuenteBanco = 1 And vlstrtipofactura = "N" And vlstrFacturaPacienteEmpresa = "E") _
            Or (intBitCuentaPuenteBanco = 1 And vlstrtipofactura = "D") _
            Or (intBitCuentaPuenteBanco = 1 And vlstrtipofactura = "T" And vlintTotalTickets > 0 And vlblnFactAutomatica = True) Then
            
            If (intBitCuentaPuenteBanco = 1 And vlstrtipofactura = "D" And vlintTotalTickets = 0 And vllngConsecutivoRefacturada <> 0) _
                Or (intBitCuentaPuenteBanco = 1 And vlstrtipofactura = "N" And vlstrFacturaPacienteEmpresa = "E" And vllngConsecutivoRefacturada <> 0) _
                Or (intBitCuentaPuenteBanco = 1 And vlstrtipofactura = "T" And vlintTotalTickets > 0 And vlblnFactAutomatica = True And vllngConsecutivoRefacturada <> 0) Then
                pCancelaMovimiento vllngConsecutivoRefacturada, vlstrFolioFactura, -1, vllngNumeroCorte, vllngPersonaGraba, vlstrNombreForma
            Else
                pCancelaMovimiento vllngConsecutivoFactura, vlstrFolio, vllngNumCorteFactura, vllngNumeroCorte, vllngPersonaGraba, vlstrNombreForma
            End If
        End If
           
        Call pGuardarLogTransaccion(vlstrNombreForma, EnmGrabar, vllngPersonaGraba, "CANCELACION DE FACTURA", vlstrFolio)
        
        '-------------------------------'
        ' Darle COMMIT a la TRANSACTION '
        '-------------------------------'
        EntornoSIHO.ConeccionSIHO.CommitTrans
        
        ''''''''''''''''''''''''''''''''''''''''
        'mensaje de confirmación de cancelacion'
        ''''''''''''''''''''''''''''''''''''''''
        If vlblnMuestraMensajes Then pMensajeCanelacionCFDi vllngConsecutivoFactura, "FA"
        'Actualiza PDF al cancelar facturas
        If Not fblnGeneraComprobanteDigital(vllngConsecutivoFactura, "FA", 1, 0, "", False, True, -1) Then
            On Error Resume Next
        End If
'/******************************************************************************
'        Else
'            'Para poder cancelar una factura parcial, antes se tiene que cancelar la factura base
'            MsgBox SIHOMsg(634), vbOKOnly + vbInformation, "Mensaje"
'        End If
'******************************************************************************/
    End If
End Sub

Private Function fblnSePuedeCancelaHonorarioMedico(strFolioFactura As String) As Boolean
On Error GoTo NotificaError

    Dim strSentencia As String
    Dim vgstrParametrosSP As String
    Dim rs As New ADODB.Recordset
    Dim vstrFolioFactura As String
    Dim vlngMoviemientoPaciente As String
    Dim rsHonorarioEnPaqueteCobranza As New ADODB.Recordset
    Dim rsHonorarioBorrar As New ADODB.Recordset
    
    Dim vlblnHayCheques As Boolean
    Dim vlblnHayTransferencias As Boolean
    Dim vlblnHayAutorizaciones As Boolean
    Dim vlblnHayPagos As Boolean
    Dim vlStrMedCheques As String
    Dim vlStrMedTransferencias As String
    Dim vlStrMedAutorizaciones As String
    Dim vlStrMedPagos As String
    
    fblnSePuedeCancelaHonorarioMedico = False
     
    strSentencia = "select CpCuentaPagarMedico.intConsecutivo intCveHonorario, " & _
                   " TRIM(HoMedico.vchApellidoPaterno) || ' ' || TRIM(HoMedico.vchApellidoMaterno) || ' ' || TRIM(HoMedico.vchNombre) medico " & _
                   "  from CpCuentaPagarMedico " & _
                   " inner join homedico on homedico.intcvemedico = CpCuentaPagarMedico.intcvemedico " & _
                   " where CpCuentaPagarMedico.INTNUMCUENTAPAGAR IN (Select intNumCuentapagar " & _
                   "                                                   From PVFACTURAHONORARIOMEDAUTOMATIC " & _
                   "                                                  Where PVFACTURAHONORARIOMEDAUTOMATIC.CHRFOLIOFACTURA = '" & strFolioFactura & "') " & _
                   "UNION " & _
                   "SELECT PVHONORARIOFACTURADO.INTCONSECUTIVO intCveHonorario, " & _
                   "TRIM(HoMedico.vchApellidoPaterno) || ' ' || TRIM(HoMedico.vchApellidoMaterno) || ' ' || TRIM(HoMedico.vchNombre) medico " & _
                   "From PVHONORARIOFACTURADO " & _
                   "INNER JOIN PVHONORARIO ON  PVHONORARIOFACTURADO.INTCONSECUTIVO = PVHONORARIO.INTCONSECUTIVO " & _
                   "inner join homedico on homedico.intcvemedico = PVHONORARIO.intcvemedico " & _
                   "Where trim(PVHONORARIOFACTURADO.chrfoliofactura) = '" & Trim(strFolioFactura) & "'"
    Set rs = frsRegresaRs(strSentencia, adLockReadOnly, adOpenForwardOnly)
    Do While Not rs.EOF
        vgstrParametrosSP = rs!intCveHonorario
        Set rsHonorarioEnPaqueteCobranza = frsEjecuta_SP(vgstrParametrosSP, "SP_CCHONORARIOSENPAQCOBRANZA")
        
        'Se verifica que el honorario no se encuentre en un paquete de cobranza
        If rsHonorarioEnPaqueteCobranza.RecordCount <> 0 Then
            MsgBox Left$(SIHOMsg(706), 34) & vbCrLf & "está dentro del paquete de cobranza " & rsHonorarioEnPaqueteCobranza!numero, vbOKOnly + vbInformation, "Mensaje"
        End If
    
        vgstrParametrosSP = rs!intCveHonorario
        Set rsHonorarioBorrar = frsEjecuta_SP(vgstrParametrosSP & "|0", "SP_CCSELCUENTAPAGARHONORARIO")
        
        vlblnHayCheques = False
        vlblnHayTransferencias = False
        vlblnHayAutorizaciones = False
        vlblnHayPagos = False
        vlStrMedCheques = ""
        vlStrMedTransferencias = ""
        vlStrMedAutorizaciones = ""
        vlStrMedPagos = ""
        
        rsHonorarioBorrar.MoveFirst
        Do While Not rsHonorarioBorrar.EOF
            If rsHonorarioBorrar!Cheques <> 0 Then
                vlblnHayCheques = True
                If vlStrMedCheques = "" Then
                    vlStrMedCheques = rs!Medico
                Else
                    vlStrMedCheques = IIf(InStr(1, vlStrMedCheques, rs!Medico), vlStrMedCheques, vlStrMedCheques & Chr(13) & rs!Medico)
                End If
            End If
            If rsHonorarioBorrar!Transferencias <> 0 Then
                vlblnHayTransferencias = True
                If vlStrMedTransferencias = "" Then
                    vlStrMedTransferencias = rs!Medico
                Else
                    vlStrMedTransferencias = IIf(InStr(1, vlStrMedTransferencias, rs!Medico), vlStrMedTransferencias, vlStrMedTransferencias & Chr(13) & rs!Medico)
                End If
            End If
            If rsHonorarioBorrar!autorizaciones <> 0 Then
                vlblnHayAutorizaciones = True
                If vlStrMedAutorizaciones = "" Then
                    vlStrMedAutorizaciones = rs!Medico
                Else
                    vlStrMedAutorizaciones = IIf(InStr(1, vlStrMedAutorizaciones, rs!Medico), vlStrMedAutorizaciones, vlStrMedAutorizaciones & Chr(13) & rs!Medico)
                End If
            End If
            If rsHonorarioBorrar!pagos <> 0 Then
                vlblnHayPagos = True
                If vlStrMedPagos = "" Then
                    vlStrMedPagos = rs!Medico
                Else
                    vlStrMedPagos = IIf(InStr(1, vlStrMedPagos, rs!Medico), vlStrMedPagos, vlStrMedPagos & Chr(13) & rs!Medico)
                End If
            End If
            rsHonorarioBorrar.MoveNext
        Loop
        rs.MoveNext
        
        If vlblnHayCheques = True Or vlblnHayTransferencias = True Or vlblnHayAutorizaciones = True Or vlblnHayPagos = True Then
            If vlblnHayAutorizaciones = True Then
                'No se puede cancelar el honorario, ya se autorizó para pago.
                MsgBox SIHOMsg(707) & Chr(13) & vlStrMedAutorizaciones, vbOKOnly + vbInformation, "Mensaje"
            End If
            If vlblnHayCheques = True Then
                 'No se puede cancelar el honorario, ya se emitió cheque para el médico.
                MsgBox SIHOMsg(706) & Chr(13) & vlStrMedCheques, vbOKOnly + vbInformation, "Mensaje"
            End If
            If vlblnHayTransferencias = True Then
                'No se puede cancelar el honorario, ya se emitió transferencia para el médico.
                MsgBox SIHOMsg(1477) & Chr(13) & vlStrMedTransferencias, vbOKOnly + vbInformation, "Mensaje"
            End If
            If vlblnHayPagos = True Then
                'No se puede cancelar el documento  el crédito tiene pagos registrados.
                MsgBox SIHOMsg(368) & Chr(13) & vlStrMedPagos, vbOKOnly + vbInformation, "Mensaje"
            End If
            
            Exit Function
        End If
    Loop
    fblnSePuedeCancelaHonorarioMedico = True
    
Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnSePuedeCancelaHonorarioMedico"))
End Function


'// (CR) Modificado para caso 7442: Inserta los movimientos de un ticket que se había facturado, pero se cancela la factura \\'
Private Sub pActivarTicket(vllngNumTicket As Long, vllngCorteTicket As Long, vllngCorteActual As Long, vllngPersonaGraba As Long, frmNombreForma As String)
On Error GoTo NotificaError

    Dim rs As ADODB.Recordset
    Dim lstrSentencia As String, lstrFecha As String
    
    lstrSentencia = "SELECT MB.intFormaPago, MB.chrTipoMovimiento, MB.mnyCantidad, MB.mnyTipoCambio," & _
                    " FP.chrTipo, ISNULL(B.tnyNumeroBanco, MB.intCveBanco) AS IdBanco " & _
                    " FROM PvMovimientoBancoForma MB " & _
                    " INNER JOIN PvFormaPago FP ON MB.intFormaPago = FP.intFormaPago " & _
                    " LEFT  JOIN CpBanco B ON B.intNumeroCuenta = FP.intCuentaContable " & _
                    " WHERE TRIM(MB.chrTipoDocumento) = 'TI' AND MB.intNumDocumento = " & vllngNumTicket & _
                    " AND MB.intNumCorte = " & vllngCorteTicket & _
                    " AND ((mb.mnycantidad > 0 AND mb.chrtipomovimiento not in ('CBA', 'CCB'))" & _
                        " OR (mb.mnycantidad < 0 AND mb.chrtipomovimiento = 'CBA')) " & _
                    "group by  mb.intformapago, mb.chrtipomovimiento, mb.mnycantidad, mb.mnytipocambio , fp.chrtipo, IsNull(b.tnynumerobanco, mb.intcvebanco)"
    Set rs = frsRegresaRs(lstrSentencia)
    If Not rs.EOF Then
        rs.MoveFirst
        Do While Not rs.EOF
            If rs!chrTipo <> "C" Then
                lstrFecha = fstrFechaSQL(fdtmServerFecha, fdtmServerHora) '- Fecha y hora del movimiento -'

                '- Guardar información en tabla intermedia -'
                vgstrParametrosSP = vllngCorteActual & "|" & lstrFecha & "|" & rs!intFormaPago & "|" & rs!IdBanco & "|" & rs!MNYCantidad & "|" & _
                                    IIf(rs!mnytipocambio = 0, 1, 0) & "|" & rs!mnytipocambio & "|" & rs!chrTipoMovimiento & "|" & "TI" & "|" & vllngNumTicket & "|" & _
                                    vllngPersonaGraba & "|" & vgintNumeroDepartamento & "|" & lstrFecha & "|" & "1" & "|" & cgstrModulo
                frsEjecuta_SP vgstrParametrosSP, "Sp_PvInsMovimientoBancoForma"
            End If
            rs.MoveNext
        Loop
    End If
    rs.Close
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pActivarTicket"))
End Sub


Private Function fblnRegistraPagoCuentasBanco(vllngCorte As Long, vlblnPesos As Boolean, vldblTipoCambio As Double, vllngPersonaGraba As Long, vllngConsecutivoFactura As Long, vlstrFolioFactura As String, vllngCuentaPaciente As Long, vlStrTipoPaciente As String, vlstrRazonSocial As String, vlstrNombreForma As String) As Boolean
    Dim vllngFoliosFaltantes As Long
    Dim alstrParametrosSalida() As String
    Dim strFolio As String
    Dim strSerie As String
    Dim strNumeroAprobacion As String
    Dim strAnoAprobacion As String
    Dim vlstrFolioDocumento As String
    Dim strSql As String
    Dim rs As New ADODB.Recordset
    Dim vlblnValidarDesglosarIVA As Boolean
    Dim vllngConceptoPago As Long
    Dim vldblSumaaBancos As Double
    Dim lngNumPagoSalida  As Long
    Dim ObjRS As New ADODB.Recordset
    Dim dblCantidadConcepto As Double
    Dim dblCantidadIVA As Double
    Dim vllngNumeroCuenta As Long
    Dim rsPvDetalleCorte As New ADODB.Recordset
    Dim rsDCP As New ADODB.Recordset
    Dim rsPolizaenPuente As New ADODB.Recordset
    Dim rsPagoenPuente As New ADODB.Recordset
    Dim vlblnRefacturada As Boolean
    Dim rsRefacturada As New ADODB.Recordset
    Dim vllngConsecutivoFacturaOrig As Long
    Dim vlstrFolioFacturaOrig As String
    Dim vlstrNombreEmpresaContable As String
    Dim rsTemp As New ADODB.Recordset
    
    fblnRegistraPagoCuentasBanco = True
    vlstrFolioFacturaOrig = ""
    vllngConsecutivoFacturaOrig = 0
    
    'Busca los importes que se registraron con formas de pago ligadas a bancos para obtener el total de ellos
    'para generar un pago automático
    Set rsDCP = frsEjecuta_SP(vllngConsecutivoFactura & "|" & vlstrFolioFactura, "sp_pvFormaPagoRelacionadaBanco")
    
    If rsDCP.RecordCount > 0 Then
        rsDCP.MoveFirst
        vlstrFolioFacturaOrig = vlstrFolioFactura
        vllngConsecutivoFacturaOrig = vllngConsecutivoFactura
        vldblSumaaBancos = 0
        Do While Not rsDCP.EOF
            vldblSumaaBancos = vldblSumaaBancos + rsDCP!cantidadPago
            rsDCP.MoveNext
        Loop
    Else
        'Si no hay movimientos de cuentas relacionadas con bancos, busca si hay movimientos en cuenta puente por refacturación
        'para generar pago por ese monto
        strSql = "select * from pvcortepoliza " & _
                 " where trim (pvcortepoliza.chrfoliodocumento) = '" & vlstrFolioFactura & "'" & _
                 " and pvcortepoliza.intnumcuenta = " & lngCuentaPuenteBanco & _
                 " and pvcortepoliza.bitcargo = 1 and pvcortepoliza.chrtipodocumento = 'FA'"
        
        'Busca si hay pagos automáticos generados en otras cancelaciones para restarlo
        'y registrar un pago solo por lo que no se ha generado un pago
        Set rsPolizaenPuente = frsRegresaRs(strSql, adLockReadOnly, adOpenForwardOnly)
        If rsPolizaenPuente.RecordCount > 0 Then
            rsPolizaenPuente.MoveFirst
            vldblSumaaBancos = 0
            Do While Not rsPolizaenPuente.EOF
                vldblSumaaBancos = vldblSumaaBancos + rsPolizaenPuente!MNYCantidad
                rsPolizaenPuente.MoveNext
            Loop
            strSql = "select nvl(sum(pvpago.mnycantidad), 0) pagos from pvpago " & _
                      "where trim(pvpago.chrfoliofactura) = '" & vlstrFolioFactura & "'"
            Set rsPagoenPuente = frsRegresaRs(strSql, adLockReadOnly, adOpenForwardOnly)
            If rsPagoenPuente.RecordCount > 0 Then
                vldblSumaaBancos = vldblSumaaBancos - rsPagoenPuente!pagos
            End If
            
            If vldblSumaaBancos <= 0 Then
                Exit Function ' No hay movimientos de la factura que hayan afectado a bancos
            Else
                'Si hay montos por los que no se ha generado un pago, busca el folio de factura en la tabla pvRefacturacion
                'para buscar las formas de pago de la factura cancelada por la cual fue refacturada
                vlblnRefacturada = False
                vldblSumaaBancos = 0
                Do While vlblnRefacturada = False
                    strSql = "select pvRefacturacion.chrfoliofacturacancelada, pvfactura.intconsecutivo " & _
                             "from pvRefacturacion,pvfactura where trim(chrfoliofacturaactivada) = '" & vlstrFolioFactura & "'" & _
                             " and trim(pvRefacturacion.chrfoliofacturacancelada) = trim(pvfactura.chrfoliofactura)"
                    Set rsRefacturada = frsRegresaRs(strSql, adLockReadOnly, adOpenForwardOnly)
                    If rsRefacturada.RecordCount > 0 Then
                        Set rsPolizaenPuente = frsEjecuta_SP(rsRefacturada!intConsecutivo & "|" & Trim(rsRefacturada!chrfoliofacturacancelada), "sp_pvFormaPagoRelacionadaBanco")
                        If rsPolizaenPuente.RecordCount > 0 Then
                            rsPolizaenPuente.MoveFirst
                            vlstrFolioFacturaOrig = Trim(rsRefacturada!chrfoliofacturacancelada)
                            vllngConsecutivoFacturaOrig = rsRefacturada!intConsecutivo
                            vldblSumaaBancos = 0
                            Do While Not rsPolizaenPuente.EOF
                                vldblSumaaBancos = vldblSumaaBancos + rsPolizaenPuente!cantidadPago
                                rsPolizaenPuente.MoveNext
                            Loop
                            If vldblSumaaBancos <= 0 Then
                                Exit Function ' No hay movimientos de la factura que hayan afectado a bancos
                            End If
                            vlblnRefacturada = True
                        Else
                            vlstrFolioFactura = Trim(rsRefacturada!chrfoliofacturacancelada)
                        End If
                    Else
                        vlblnRefacturada = True
                    End If
                Loop
                If vldblSumaaBancos <= 0 Then
                    Exit Function ' No hay movimientos de la factura que hayan afectado a bancos
                End If
            End If
        Else
            Exit Function ' No hay movimientos de la factura que hayan afectado a bancos
        End If
    End If
    
    '-----------------------'
    '   Control de FOLIOS   '
    '-----------------------'
    vllngFoliosFaltantes = 0
    
    pCargaArreglo alstrParametrosSalida, vllngFoliosFaltantes & "|" & adInteger & "|" & strFolio & "|" & ADODB.adBSTR & "|" & strSerie & "|" & ADODB.adBSTR & "|" & strNumeroAprobacion & "|" & ADODB.adBSTR & "|" & strAnoAprobacion & "|" & ADODB.adBSTR
    frsEjecuta_SP "RE" & "|" & vgintNumeroDepartamento & "|1", "Sp_GnFolios", , , alstrParametrosSalida
    pObtieneValores alstrParametrosSalida, vllngFoliosFaltantes, strFolio, strSerie, strNumeroAprobacion, strAnoAprobacion
       
    '|  Si la serie está vacía el SP regresa un espacio en blanco por eso se debe de hacer el TRIM
    strSerie = Trim(strSerie)
    vlstrFolioDocumento = strSerie & strFolio
    
    If Trim(vlstrFolioDocumento) = "0" Then
        EntornoSIHO.ConeccionSIHO.RollbackTrans
        'No existen folios activos para este documento.
        MsgBox Replace(SIHOMsg(291), "este documento", "pagos"), vbCritical, "Mensaje"
        fblnRegistraPagoCuentasBanco = False 'para que haga rollback al momento de salir de esta función por que no hay folios.
        Exit Function
    End If
    
    'Para validar si el parametro "Desglosar IVA en pagos" está activo
    strSql = "select pvconceptopago.intnumconcepto, pvconceptopago.bitdesglosaiva, pvconceptopagoempresa.intnumerocuenta" & _
              " From pvconceptopago, pvconceptopagoempresa Where pvconceptopago.bitpagocancelafactura = 1 " & _
              "  and pvconceptopago.intnumconcepto = pvconceptopagoempresa.intnumconcepto and pvconceptopagoempresa.intcveempresa = " & vgintClaveEmpresaContable
   
    Set rs = frsRegresaRs(strSql, adLockReadOnly, adOpenForwardOnly)
    If rs.RecordCount = 0 Then
        EntornoSIHO.ConeccionSIHO.RollbackTrans
        'No existe configuración para el concepto de pago automático por cancelación para la empresa
        strSql = "select * from CnEmpresaContable where tnyClaveEmpresa=" & str(vgintClaveEmpresaContable)
        Set rsTemp = frsRegresaRs(strSql)
        If rsTemp.RecordCount <> 0 Then
            vlstrNombreEmpresaContable = Trim(rsTemp!vchNombreCorto)
        End If
        rsTemp.Close
        
        MsgBox "No se ha registrado la cuenta contable para el concepto de pago que se generará automáticamente al cancelar y/o re facturar, para la empresa " & vlstrNombreEmpresaContable & ".", vbCritical, "Mensaje"
        fblnRegistraPagoCuentasBanco = False
        Exit Function
    End If

    vlblnValidarDesglosarIVA = IIf(rs!bitdesglosaiva = 0, False, True)
    vllngConceptoPago = rs!intNumConcepto
    vllngNumeroCuenta = rs!intNumeroCuenta
        
    vgstrParametrosSP = vlstrFolioDocumento & "|" & _
                        vllngCuentaPaciente & "|" & _
                        vlStrTipoPaciente & "|" & _
                        fstrFechaSQL(fdtmServerFecha, , True) & "|" & _
                        vlstrRazonSocial & "|" & _
                        Format(vldblSumaaBancos, "############.00") & "|" & _
                        IIf(vlblnPesos, 1, 0) & "|" & _
                        CStr(IIf(vlblnPesos, 0, vldblTipoCambio)) & "|" & _
                        CStr(vgintNumeroDepartamento) & "|" & _
                        CStr(vllngPersonaGraba) & "|" & _
                        CStr(vllngCorte) & "|" & _
                        vllngConceptoPago & "|" & _
                        "Pago automático por cancelación de factura " & vlstrFolioFactura & "|" & _
                        "PA" & "|" & _
                        IIf(vlblnValidarDesglosarIVA, 1, 0)
                        
    lngNumPagoSalida = 1
    frsEjecuta_SP vgstrParametrosSP, "SP_PVINSPAGO", True, lngNumPagoSalida, , , True
    
    If lngNumPagoSalida = 1 Then ' validamos si se tiene 1 por que trono o por si inserto el registro 1
        Set ObjRS = frsRegresaRs("Select max(intnumpago) from pvpago", adLockOptimistic)
            If ObjRS.RecordCount = 0 Then
               lngNumPagoSalida = -1
            Else
               If ObjRS.Fields(0) <> 1 Then lngNumPagoSalida = -1
            End If
    End If
    
    If lngNumPagoSalida > -1 Then ' que continue con el proceso si se inserto el pago o la salida de dinero.
        
        '----------------------------------------------------------------------------------------'
        ' Se registran los tipos de movimientos de la póliza relacionados con el pago automático '
        '----------------------------------------------------------------------------------------'
        If vllngConsecutivoFacturaOrig <> 0 Then
            frsEjecuta_SP lngNumPagoSalida & "|" & vlstrFolioDocumento & "|" & vllngConsecutivoFacturaOrig & "|" & vlstrFolioFacturaOrig, "SP_PVINSPAGOCORTEPOLIZA"
            'frsEjecuta_SP vllngConsecutivoFacturaOrig & "|" & vlstrFolioFacturaOrig, "SP_PVINSPAGOCORTEPOLIZA"
        End If
        
        '---------------------------------------------------------'
        ' Si es entrada de dinero abono a la cuenta del concepto  '
        '---------------------------------------------------------'
        
        ' Para validar si el parametro "Desglosar IVA en pagos" está activo '
        If vlblnValidarDesglosarIVA Then
            '********** >>SI<< desglosar IVA **********'
            dblCantidadConcepto = Val(Format(vldblSumaaBancos, "############.00"))
            dblCantidadIVA = dblCantidadConcepto - dblCantidadConcepto / (1 + (vgdblCantidadIvaGeneral / 100))
            dblCantidadConcepto = dblCantidadConcepto - dblCantidadIVA
   
            'pAgregarMovArregloCorte vllngCorte, vlstrFolioDocumento, "RE", vllngNumeroCuenta, _
            'IIf(vlblnPesos, dblCantidadConcepto, dblCantidadConcepto * vldblTipoCambio), 0, "", 0, 0, "", 0, 2, "", "", , , , , , , "PAA"

            'pAgregarMovArregloCorte vllngCorte, vlstrFolioDocumento, "RE", glngCtaIVACobrado, _
            'IIf(vlblnPesos, dblCantidadIVA, dblCantidadIVA * vldblTipoCambio), 0, "", 0, 0, "", 0, 2, "", "", , , , , , , "PAA"
                          
        Else
            '********** >>NO<< desglosar IVA **********'
            dblCantidadConcepto = Val(Format(vldblSumaaBancos, "############.00"))
            dblCantidadIVA = 0
            dblCantidadConcepto = dblCantidadConcepto - dblCantidadIVA
            
            'pAgregarMovArregloCorte vllngCorte, vlstrFolioDocumento, "RE", vllngNumeroCuenta, _
            'IIf(vlblnPesos, dblCantidadConcepto, dblCantidadConcepto * vldblTipoCambio), 0, "", 0, 0, "", 0, 2, "", "", , , , , , , "PAA"
        
        End If
                      
        'pAgregarMovArregloCorte vllngCorte, vlstrFolioDocumento, "RE", lngCuentaPuenteBanco, _
        'IIf(vlblnPesos, (dblCantidadConcepto + dblCantidadIVA), (dblCantidadConcepto + dblCantidadIVA) * vldblTipoCambio), 1, "", 0, 0, "", 0, 2, "", ""
                      

        '--------------------------------------------------------------------------------'
        '   Guarda movimientos en el corte (PvDetalleCorte)   '
        '--------------------------------------------------------------------------------'
            
        If rsDCP.RecordCount > 0 Then
            rsDCP.MoveFirst
            Do While Not rsDCP.EOF
                pAgregarMovArregloCorte vllngCorte, vllngPersonaGraba, vlstrFolioDocumento, "RE", 0, (rsDCP!mnyCantidadPagada), _
                False, (fdtmServerFecha + fdtmServerHora), rsDCP!intFormaPago, rsDCP!mnytipocambio, rsDCP!intfoliocheque, rsDCP!intNumCorteDocumento, _
                1, "", ""
                
                rsDCP.MoveNext
            Loop
        Else
            If rsPolizaenPuente.RecordCount > 0 Then
                rsPolizaenPuente.MoveFirst
                Do While Not rsPolizaenPuente.EOF
                    pAgregarMovArregloCorte vllngCorte, vllngPersonaGraba, vlstrFolioDocumento, "RE", 0, (rsPolizaenPuente!mnyCantidadPagada), _
                    False, (fdtmServerFecha + fdtmServerHora), rsPolizaenPuente!intFormaPago, rsPolizaenPuente!mnytipocambio, rsPolizaenPuente!intfoliocheque, rsPolizaenPuente!intNumCorteDocumento, _
                    1, "", ""
                    
                    rsPolizaenPuente.MoveNext
                Loop
            End If
        End If
    
    End If

Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":fblnRegistraPagoCuentasBanco"))
End Function
Public Sub pCancelaMovimientoRef(vllngNumFactura As Long, vlstrFolio As String, vllngCorteFactura As Long, vllngCorteActual As Long, vllngPersonaGraba As Long, Optional vlblnRefacturar As Boolean, Optional vllngNuevaFactura As Long = 0)
On Error GoTo NotificaError

    Dim rs As ADODB.Recordset
    Dim lstrSentencia As String, lstrTipoDoc As String, lstrFecha As String
    Dim ldblCantidad As Double
    
    lstrSentencia = "SELECT MB.intFormaPago, MB.chrTipoMovimiento, MB.mnyCantidad, MB.mnyTipoCambio," & _
                    " FP.chrTipo, ISNULL(B.tnyNumeroBanco, MB.intCveBanco) AS IdBanco, mb.chrtipomovimiento " & _
                    " FROM PvMovimientoBancoForma MB " & _
                    " INNER JOIN PvFormaPago FP ON MB.intFormaPago = FP.intFormaPago " & _
                    " LEFT  JOIN CpBanco B ON B.intNumeroCuenta = FP.intCuentaContable " & _
                    " WHERE TRIM(MB.chrTipoDocumento) = 'FA' AND MB.intNumDocumento = " & vllngNumFactura & _
                    " AND (MB.intNumCorte = " & vllngCorteFactura & " OR " & vllngCorteFactura & " = -1) " & _
                    " AND ((mb.mnycantidad > 0 AND mb.chrtipomovimiento <> 'CBA') " & _
                           " OR (mb.mnycantidad < 0 AND mb.chrtipomovimiento = 'CBA')) "
                           
    Set rs = frsRegresaRs(lstrSentencia)
    If Not rs.EOF Then
        rs.MoveFirst
        Do While Not rs.EOF
            If rs!chrTipo <> "C" Then
                lstrFecha = fstrFechaSQL(fdtmServerFecha, fdtmServerHora) '- Fecha y hora del movimiento -'
                
                '- Revisar tipo de movimiento para determinar la cancelación -'
                If rs!chrTipoMovimiento = "CBA" Then
                    lstrTipoDoc = "CCB"                 'Comisión bancaria
                Else
                    Select Case rs!chrTipoMovimiento
                        '- Movimientos de facturación -'
                        Case "EFF": lstrTipoDoc = "CEF"   'Efectivo en factura
                        Case "TAF": lstrTipoDoc = "CJF"   'Tarjeta de crédito en factura
                        Case "TPF": lstrTipoDoc = "CTF"   'Transferencia bancaria en factura
                        Case "CHF": lstrTipoDoc = "CQF"   'Cheque en factura
                        '- Movimientos de venta al público -'
                        Case "EFV": lstrTipoDoc = "CFV"   'Efectivo en venta al público
                        Case "TAV": lstrTipoDoc = "CJV"   'Tarjeta de crédito en venta al público
                        Case "TPV": lstrTipoDoc = "CTV"   'Transferencia bancaria en venta al público
                        Case "CQV": lstrTipoDoc = "CCV"   'Cheque en venta al público
                        '- Movimientos de facturación directa -'
                        Case "EFC": lstrTipoDoc = "CEC"   'Efectivo en factura de cliente
                        Case "TAC": lstrTipoDoc = "CJC"   'Tarjeta de crédito en factura de cliente
                        Case "TCL": lstrTipoDoc = "CTC"   'Transferencia bancaria en factura de cliente
                        Case "CHC": lstrTipoDoc = "CQC"   'Cheque en factura de cliente
                    End Select
                End If
                
                ldblCantidad = rs!MNYCantidad * (-1) 'Cantidad negativa para que se tome como abono
    
                '- Guardar información en tabla intermedia -'
                vgstrParametrosSP = vllngCorteActual & "|" & lstrFecha & "|" & rs!intFormaPago & "|" & rs!IdBanco & "|" & ldblCantidad & "|" & _
                                    IIf(rs!mnytipocambio = 0, 1, 0) & "|" & rs!mnytipocambio & "|" & lstrTipoDoc & "|" & "FA" & "|" & vllngNumFactura & "|" & _
                                    vllngPersonaGraba & "|" & vgintNumeroDepartamento & "|" & lstrFecha & "|" & "1" & "|" & cgstrModulo
                frsEjecuta_SP vgstrParametrosSP, "Sp_PvInsMovimientoBancoForma"
            
                If vlblnRefacturar Then
                '- Guardar información en tabla intermedia para las formas de pago de la nueva factura -'
                    If rs!chrTipoMovimiento = "CBA" Then
                        lstrTipoDoc = "CBA"                 'Comisión bancaria
                    Else
                        Select Case rs!chrTipo
                            Case "E": lstrTipoDoc = "EFF"
                            Case "T": lstrTipoDoc = "TAF"
                            Case "B": lstrTipoDoc = "TPF"
                            Case "H": lstrTipoDoc = "CHF"
                        End Select
                    End If
                    
                    vgstrParametrosSP = vllngCorteActual & "|" & lstrFecha & "|" & rs!intFormaPago & "|" & rs!IdBanco & "|" & rs!MNYCantidad & "|" & _
                                        IIf(rs!mnytipocambio = 0, 1, 0) & "|" & rs!mnytipocambio & "|" & lstrTipoDoc & "|" & "FA" & "|" & vllngNuevaFactura & "|" & _
                                        vllngPersonaGraba & "|" & vgintNumeroDepartamento & "|" & lstrFecha & "|" & "1" & "|" & cgstrModulo
                    frsEjecuta_SP vgstrParametrosSP, "Sp_PvInsMovimientoBancoForma"

                End If
            End If
            rs.MoveNext
        Loop
    End If
    rs.Close
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pCancelaMovimiento"))
End Sub



'- (CR) Agregado para caso 6894 - '
'- Registra el movimiento de cancelación en el libro de bancos, si es que se pagó con transferencia -'
'// (CR) Modificado para caso 7442: Guarda movimientos en tabla intermedia para formas de pago ligadas a una cuenta de banco \\'
Public Sub pCancelaMovimiento(vllngNumFactura As Long, vlstrFolio As String, vllngCorteFactura As Long, vllngCorteActual As Long, vllngPersonaGraba As Long, vlstrNombreForma As String, Optional vlblnRefacturar As Boolean = False, Optional vllngNuevaFactura As Long = 0)
On Error GoTo NotificaError

    Dim rs As ADODB.Recordset
    Dim lstrSentencia As String, lstrTipoDoc As String, lstrFecha As String
    Dim ldblCantidad As Double
    
    lstrSentencia = "SELECT MB.intFormaPago, MB.chrTipoMovimiento, MB.mnyCantidad, MB.mnyTipoCambio," & _
                    " FP.chrTipo, ISNULL(B.tnyNumeroBanco, MB.intCveBanco) AS IdBanco, mb.chrtipomovimiento " & _
                    " FROM PvMovimientoBancoForma MB " & _
                    " INNER JOIN PvFormaPago FP ON MB.intFormaPago = FP.intFormaPago " & _
                    " LEFT  JOIN CpBanco B ON B.intNumeroCuenta = FP.intCuentaContable " & _
                    " WHERE TRIM(MB.chrTipoDocumento) = 'FA' AND MB.intNumDocumento = " & vllngNumFactura & _
                    " AND (MB.intNumCorte = " & vllngCorteFactura & " OR " & vllngCorteFactura & " = -1) " & _
                    " AND ((mb.mnycantidad > 0 AND mb.chrtipomovimiento <> 'CBA') " & _
                           " OR (mb.mnycantidad < 0 AND mb.chrtipomovimiento = 'CBA')) "
                           
    Set rs = frsRegresaRs(lstrSentencia)
    If Not rs.EOF Then
        rs.MoveFirst
        Do While Not rs.EOF
            If rs!chrTipo <> "C" Then
                lstrFecha = fstrFechaSQL(fdtmServerFecha, fdtmServerHora) '- Fecha y hora del movimiento -'
                
                '- Revisar tipo de movimiento para determinar la cancelación -'
                If rs!chrTipoMovimiento = "CBA" Then
                    lstrTipoDoc = "CCB"                 'Comisión bancaria
                Else
                    Select Case rs!chrTipoMovimiento
                        '- Movimientos de facturación -'
                        Case "EFF": lstrTipoDoc = "CEF"   'Efectivo en factura
                        Case "TAF": lstrTipoDoc = "CJF"   'Tarjeta de crédito en factura
                        Case "TPF": lstrTipoDoc = "CTF"   'Transferencia bancaria en factura
                        Case "CHF": lstrTipoDoc = "CQF"   'Cheque en factura
                        '- Movimientos de venta al público -'
                        Case "EFV": lstrTipoDoc = "CFV"   'Efectivo en venta al público
                        Case "TAV": lstrTipoDoc = "CJV"   'Tarjeta de crédito en venta al público
                        Case "TPV": lstrTipoDoc = "CTV"   'Transferencia bancaria en venta al público
                        Case "CQV": lstrTipoDoc = "CCV"   'Cheque en venta al público
                        '- Movimientos de facturación directa -'
                        Case "EFC": lstrTipoDoc = "CEC"   'Efectivo en factura de cliente
                        Case "TAC": lstrTipoDoc = "CJC"   'Tarjeta de crédito en factura de cliente
                        Case "TCL": lstrTipoDoc = "CTC"   'Transferencia bancaria en factura de cliente
                        Case "CHC": lstrTipoDoc = "CQC"   'Cheque en factura de cliente
                    End Select
                End If
                
                ldblCantidad = rs!MNYCantidad * (-1) 'Cantidad negativa para que se tome como abono
    
                '- Guardar información en tabla intermedia -'
                vgstrParametrosSP = vllngCorteActual & "|" & lstrFecha & "|" & rs!intFormaPago & "|" & rs!IdBanco & "|" & ldblCantidad & "|" & _
                                    IIf(rs!mnytipocambio = 0, 1, 0) & "|" & rs!mnytipocambio & "|" & lstrTipoDoc & "|" & "FA" & "|" & vllngNumFactura & "|" & _
                                    vllngPersonaGraba & "|" & vgintNumeroDepartamento & "|" & lstrFecha & "|" & "1" & "|" & cgstrModulo
                frsEjecuta_SP vgstrParametrosSP, "Sp_PvInsMovimientoBancoForma"
            
                If vlblnRefacturar Then
                '- Guardar información en tabla intermedia para las formas de pago de la nueva factura -'
                    If rs!chrTipoMovimiento = "CBA" Then
                        lstrTipoDoc = "CBA"                 'Comisión bancaria
                    Else
                        Select Case rs!chrTipo
                            Case "E": lstrTipoDoc = "EFF"
                            Case "T": lstrTipoDoc = "TAF"
                            Case "B": lstrTipoDoc = "TPF"
                            Case "H": lstrTipoDoc = "CHF"
                        End Select
                    End If
                    
                    vgstrParametrosSP = vllngCorteActual & "|" & lstrFecha & "|" & rs!intFormaPago & "|" & rs!IdBanco & "|" & rs!MNYCantidad & "|" & _
                                        IIf(rs!mnytipocambio = 0, 1, 0) & "|" & rs!mnytipocambio & "|" & lstrTipoDoc & "|" & "FA" & "|" & vllngNuevaFactura & "|" & _
                                        vllngPersonaGraba & "|" & vgintNumeroDepartamento & "|" & lstrFecha & "|" & "1" & "|" & cgstrModulo
                    frsEjecuta_SP vgstrParametrosSP, "Sp_PvInsMovimientoBancoForma"

                End If
            End If
            rs.MoveNext
        Loop
    End If
    rs.Close
    
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pCancelaMovimiento"))
End Sub


Public Function IsArrayInitialized(arr) As Boolean
  Dim rv As Long

  On Error Resume Next
  rv = UBound(arr)
  IsArrayInitialized = (Err.Number = 0)

End Function

Public Function fblnNotaAutomatica(vlstrFolio As String) As Boolean
    Dim vlstrSentencia As String
    Dim rsNota As New ADODB.Recordset
    
    fblnNotaAutomatica = False
    vlstrSentencia = "select bitAutomatica from ccnota where ccnota.chrFolioNota = '" & vlstrFolio & "'"
    Set rsNota = frsRegresaRs(vlstrSentencia)
    
    If rsNota.RecordCount > 0 Then
        fblnNotaAutomatica = IIf(IsNull(rsNota!bitAutomatica), False, IIf(rsNota!bitAutomatica = 0, False, True))
    End If
    
End Function

Public Function flbnIngresosNF() As Boolean
    Dim rsParametro As New Recordset
    Dim strSentencia As String
    Dim blnUsaIngresosNF As Boolean
    Dim intDeptoConsultaIngresosNF As Integer
    
    flbnIngresosNF = False
    blnUsaIngresosNF = False
    '|  Obtiene el parámetro que identifica si se utiliza la funcionalidad de ingresos NF
    strSentencia = "Select VCHVALOR from SIPARAMETRO where (INTCVEEMPRESACONTABLE is null OR INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable & ") AND VCHNOMBRE = 'BITCONTROLARINGRESOSNF'"
    Set rsParametro = frsRegresaRs(strSentencia)
    If rsParametro.RecordCount > 0 Then
        blnUsaIngresosNF = IIf(rsParametro!VCHVALOR = "1", True, False)
    End If
    
    If blnUsaIngresosNF Then
        strSentencia = "Select VCHVALOR from SIPARAMETRO where (INTCVEEMPRESACONTABLE is null OR INTCVEEMPRESACONTABLE = " & vgintClaveEmpresaContable & ") AND VCHNOMBRE = 'INTDEPARTAMENTOCONSULTANF'"
        Set rsParametro = frsRegresaRs(strSentencia)
        If rsParametro.RecordCount > 0 Then
            intDeptoConsultaIngresosNF = CInt(rsParametro!VCHVALOR)
            If intDeptoConsultaIngresosNF = vgintNumeroDepartamento Then
                flbnIngresosNF = True
            End If
        End If
    End If
End Function

Public Function fstrCurrPrinter()
    On Error GoTo Errs
    fstrCurrPrinter = Printer.DeviceName
    Exit Function
Errs:
   fstrCurrPrinter = ""
End Function

Public Sub pSetPrinter(strNombreImpresora As String)
    Dim vPrinter As Printer
    If strNombreImpresora <> "" Then
        For Each vPrinter In Printers
            If UCase(Trim(vPrinter.DeviceName)) = UCase(Trim(strNombreImpresora)) Then
                Set Printer = vPrinter
                Exit For
            End If
        Next
    End If
End Sub

Public Sub pSetReportPrinterSettings(rptReport As CRAXDRT.Report)
    On Error Resume Next
    rptReport.SelectPrinter Printer.DriverName, Printer.DeviceName, Printer.port
    rptReport.PaperOrientation = crDefaultPaperOrientation
End Sub

Public Sub pGuardarLogTransaccion(vlstrForma As String, vlintOperacion As TipoOperacion, vlintIDEmpleado As Long, vlstrNombreCampo As String, vlstrValorCampo As String, Optional vlstrEmpleadoOMedico As String = "")
   On Error GoTo NotificaError
   'Procedimiento que guarda las transacciones realizadas por el usuario tales como :
   'Altas, Bajas, Cambios, etc. para cada uno de los modulos, pantallas, etc.; con
   'el proposito de realizar una auditroia por parte del departamento de sistemas a los
   'usuarios y verificar cualquier anomalia
   'Autor: Marco Ronquillo
   'Fecha de creacion: 09-12-2003
   'Fecha de ultima modificacion:
   
   Dim rsGenerarLog As New ADODB.Recordset
   Dim vlstrsql As String
   
   vlstrsql = "SELECT vchGenerarLog FROM SiLogPermitidos" & _
              " WHERE intOperacion=" + str(vlintOperacion)
      
   Set rsGenerarLog = frsRegresaRs(vlstrsql)
   
   vlstrEmpleadoOMedico = IIf(vlstrEmpleadoOMedico = "", "", vlstrEmpleadoOMedico)
   
   If rsGenerarLog.RecordCount <> 0 Then
    If rsGenerarLog.RecordCount <> 0 And rsGenerarLog!vchGenerarLog = "S" Then
       vlstrsql = "INSERT INTO SiLogAccesos (intNumeroModulo, vchNombreForma, intOperacion, vchNombrecampo, vchValorCampo, intIDLogin, intIDEmpleado, dtmFechaHora, vchTipoDeTrabajador) VALUES ('" & vgintNumeroModulo & "', '" & UCase(vlstrForma) & "', '" & vlintOperacion & "', '" & UCase(vlstrNombreCampo) & "', '" & vlstrValorCampo & "', '" & vglngNumeroLogin & "', '" & vlintIDEmpleado & "', GetDate(), '" & vlstrEmpleadoOMedico & "')"
'       MsgBox vlstrsql, "Mensaje"
       EntornoSIHO.ConeccionSIHO.Execute vlstrsql
    End If
   End If
   
       rsGenerarLog.Close
   
Exit Sub
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & " :modProcedimientos " & ":pGuardarLogTransaccion"))
End Sub

Public Function pMotivoCancelacion(CboMotivo As ComboBox, Optional blnFolioUUID As Boolean, Optional CboFolioUUID As ComboBox, Optional intNumCliente As Integer, Optional dtmFechahora As Date) As Boolean
    Dim vlstrSentencia As String
    Dim vlrsCF As New ADODB.Recordset
    Dim vlintIndex As Integer
    Dim vlstrFolioUUID As String
    
    Dim rsTipoMotivo As New ADODB.Recordset
    Dim rsMotivo As New ADODB.Recordset
    Dim rsFolio As New ADODB.Recordset
       
    pMotivoCancelacion = False
       
    vlstrSentencia = ""
    
    If CboMotivo.ListIndex = -1 Then
        CboMotivo.Clear
        
        vlstrSentencia = ""
        
        If Not blnFolioUUID Then
            vlstrSentencia = "Select CHRCVEMOTIVO, trim(CHRCVEMOTIVO) || ' - ' || trim(VCHDESCRIPCION) descripcion,INTID from GNMOTIVOSCANCELACIONSAT where CHRCVEMOTIVO <> '01'"
        Else
            vlstrSentencia = "Select CHRCVEMOTIVO, trim(CHRCVEMOTIVO) || ' - ' || trim(VCHDESCRIPCION) descripcion,INTID from GNMOTIVOSCANCELACIONSAT"
            
            vlstrFolioUUID = "Select CFD.INTCOMPROBANTE AS COMPROBANTE, TRIM(F.CHRFOLIOFACTURA) || ' | ' || trim(CFD.VCHUUID)FOLIOUUID, F.DTMFECHAHORA " & _
                             "From PvFactura F " & _
                             "Inner Join GnComprobanteFiscalDigital CFD On F.INTCONSECUTIVO = CFD.INTCOMPROBANTE And CFD.CHRTIPOCOMPROBANTE = 'FA' " & _
                             "WHERE F.CHRTIPOFACTURA = 'C' And F.INTNUMCLIENTE =" & intNumCliente & _
                             " AND F.DTMFECHAHORA >" & fstrFechaSQL(Format(str(dtmFechahora), "dd/mm/yyyy"), Format(str(dtmFechahora), "hh:mm:ss")) & _
                             " And F.CHRESTATUS <> 'C' " & _
                             " AND CFD.VCHUUID IS NOT NULL "
            Set rsFolio = frsRegresaRs(vlstrFolioUUID, adLockOptimistic, adOpenDynamic)
            
            If rsFolio.RecordCount > 0 Then
                pLlenarCboRs CboFolioUUID, rsFolio, 0, 1
            End If

        End If
        
        Set rsMotivo = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
        
        If rsMotivo.RecordCount > 0 Then
           pLlenarCboRs CboMotivo, rsMotivo, 0, 1
        End If

        CboMotivo.ListIndex = 0 'se inicializa el combo en vacio
        
        vlstrSentencia = "Select VCHVALOR from siparametro where  VCHNOMBRE = '" & "VCHMOTIVOCANCELACIONCFDISAT" & "'"
        Set rsTipoMotivo = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
        If rsTipoMotivo.RecordCount = 0 Then
            MsgBox "No esta configurado el motivo de cancelacion por default", vbOKOnly + vbInformation, "Mensaje"
            Exit Function
        Else
            If IsNull(rsTipoMotivo!VCHVALOR) Then
                MsgBox "No esta configurado el motivo de cancelacion por default", vbOKOnly + vbInformation, "Mensaje"
                Exit Function
            End If
        End If

         If Not IsNull(rsTipoMotivo!VCHVALOR) Then
            CboMotivo.ListIndex = fintLocalizaCbo(CboMotivo, rsTipoMotivo!VCHVALOR) ' se le asigna el valor configurado
         End If
        pMotivoCancelacion = True

    End If
End Function
Public Function fblObtieneCveCatalogo(vlblnTipoCatalogo As Boolean, vlstrxCaptionBoton As String, vlintNumeroModulo As Integer, vlstrxModulo As String) As Integer
'Funcion que obtiene clave del catalogo o numero de opcion (según sea el caso) para validar permisos
'Nota 1: La tabla SICATALOGO se utiliza en la forma "frmMantoTresCampos" para usar los permisos
'Nota 2: Hay que tomar en cuenta que los caption de los botones deben de coincidir con la descripción de los permisos en la tabla de OPCIONES
    On Error GoTo NotificaError
    Dim rsCveCatalogo As New ADODB.Recordset
    Dim vlstrsql As String
    
        If vlblnTipoCatalogo Then
'            vlstrsql = "SELECT INTCVECATALOGO FROM SICATALOGOMODULO WHERE SMINUMEROMODULO = " & vlintNumeroModulo & " AND A.CHRDESCRIPCION = '" & vlstrxCaptionBoton & "'"
            vlstrsql = "select A.INTCVECATALOGO from SiCatalogo A inner join SiCatalogoModulo B on A.intCveCatalogo = B.intCveCatalogo where B.chrModulo = '" & Trim(vlstrxModulo) & "' and A.CHRDESCRIPCION = '" & vlstrxCaptionBoton & "'"
        Else
            vlstrsql = "SELECT INTNUMEROOPCION FROM OPCION WHERE SMINUMEROMODULO = " & vlintNumeroModulo & " AND VCHDESCRIPCION LIKE '%" & vlstrxCaptionBoton & "'"
        End If
    
        Set rsCveCatalogo = frsRegresaRs(vlstrsql)
        If rsCveCatalogo.RecordCount <> 0 Then
            fblObtieneCveCatalogo = rsCveCatalogo(0)
        Else
            fblObtieneCveCatalogo = 0
        End If
        rsCveCatalogo.Close
        Set rsCveCatalogo = Nothing
 Exit Function
NotificaError:
    Call pRegistraError(Err.Number, Err.Description, cgstrModulo, (vgstrNombreForm & ":fblObtieneCveCatalogo"))
End Function

Public Function pGrabaCartaGeneralAseguradora(lngnumCuenta As Long, intEmpresa As Integer) As Long
    Dim rsCarta As ADODB.Recordset
    Dim vllngCveCarta As Long
    Dim vlstrSentencia As String
    Dim rsCartaDefaultFacturada As ADODB.Recordset
    Dim vlblnCartaDefaultFacturada As Boolean
    Dim rsTotalCartasGeneral As ADODB.Recordset
    Dim vlintTotalCartasGeneral As Integer
    
    'Si a la cuenta del paciente ya se le ha facturado la carta default, ya no se crea otra cuenta default
'    vlstrSentencia = "select * from PVCARTACONTROLSEGURO where intNumCuenta = " & lngnumCuenta & " and bitDefault = 1 and chrEstatus = 'F'"
'    Set rsCartaDefaultFacturada = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
'    If rsCartaDefaultFacturada.RecordCount > 0 Then Exit Function
        
    vlblnCartaDefaultFacturada = False
    vlstrSentencia = "select * from PVCARTACONTROLSEGURO where intNumCuenta = " & lngnumCuenta & " and bitDefault = 1 and chrEstatus = 'F'"
    Set rsCartaDefaultFacturada = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    If rsCartaDefaultFacturada.RecordCount > 0 Then vlblnCartaDefaultFacturada = True
        
    vlstrSentencia = "select count(*) totalCartas from PVCARTACONTROLSEGURO where intNumCuenta = " & lngnumCuenta & " AND chrEstatus = 'F' AND InStr(pvcartacontrolseguro.vchdescripcion, 'CARTA DE AUTORIZACIÓN GENERAL') > 0"
    Set rsTotalCartasGeneral = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
    If rsTotalCartasGeneral.RecordCount > 0 Then vlintTotalCartasGeneral = rsTotalCartasGeneral!totalCartas
        
    vlstrSentencia = "select * from PVCARTACONTROLSEGURO where intcveCarta=-1"
    Set rsCarta = frsRegresaRs(vlstrSentencia, adLockOptimistic, adOpenDynamic)
                                          
    With rsCarta
        .AddNew
        !VCHDESCRIPCION = "CARTA DE AUTORIZACIÓN GENERAL" & IIf(vlintTotalCartasGeneral >= 1, " " & str(vlintTotalCartasGeneral + 1), "")
        !intNumCuenta = lngnumCuenta
        !intcveempresa = intEmpresa
        !BITDEFAULT = IIf(vlblnCartaDefaultFacturada, 0, 1)
        .Update
        
        vllngCveCarta = flngObtieneIdentity(UCase("SEQ_PVCARTACONTROLSEGURO"), !intCveCarta)
    End With
    pGrabaCartaGeneralAseguradora = vllngCveCarta
    
    pEjecutaSentencia ("UPDATE PvCargo set intcvecarta = " & vllngCveCarta & " where intmovpaciente = " & lngnumCuenta & " and chrfoliofactura is null and intcvecarta is null")

End Function

Public Sub pSetDefaultSystemPrinter()
    Dim DefPrinter As String, sLen As Long, iPrn As Printer, hResult As Long
    If vglngTerminalServerSessionId > 0 Then
        DefPrinter = Space$(255)
        sLen = 255
        hResult = GetDefaultPrinterA(ByVal DefPrinter, sLen)
        If hResult <> 0 Then DefPrinter = Left(DefPrinter, sLen - 1)
        If Printer.DeviceName = DefPrinter Then Exit Sub
        SetPrinterAsDefault DefPrinter
    End If
End Sub

Private Function SetPrinterAsDefault(ByVal DeviceName As String) As Boolean
    Dim Buffer As String
    Dim R As Long
    Dim sPrinterDevName As String
    Dim DriverName As String
    Dim PrinterPort As String
    Dim DeviceLine As String
    Dim l As Long
    Dim iDriver As Integer
    Dim iPort As Integer
    '
    ' Set up for changing the default.
    Buffer = Space(8192)
    R = GetProfileString("windows", "Device", vbNullString, Buffer, Len(Buffer))
    If R <> 0 Then
        ' Remove the wasted space
        Buffer = Mid(Buffer, 1, R)
        ' Store the current default printer before we change it
        sPrinterDevName = Mid(Buffer, 1, InStr(Buffer, ",") - 1)
        ' m_sPrevPrinterDriver = Mid(Buffer, InStr(Buffer, ",") + 1, InStrRev(Buffer, ",") - InStr(Buffer, ",") - 1)
        ' m_sPrevPrinterPort = Mid(Buffer, InStrRev(Buffer, ",") + 1)
    End If
    '
    ' If its not currently set as the default then set it...
    If sPrinterDevName <> DeviceName Then
        Buffer = Space(1024)
        R = GetProfileString("PrinterPorts", DeviceName, vbNullString, Buffer, Len(Buffer))
        '
        ' Parse the driver name and port name out of the buffer
        DriverName = vbNullString
        PrinterPort = vbNullString

        ' The driver name is first in the string terminated by a comma
        iDriver = InStr(Buffer, ",")
        If iDriver > 0 Then
            ' Strip out the driver name
            DriverName = Left(Buffer, iDriver - 1)
            ' The port name is the second entry after the driver name separated by commas.
            iPort = InStr(iDriver + 1, Buffer, ",")
            If iPort > 0 Then
                'Strip out the port name
                PrinterPort = Mid(Buffer, iDriver + 1, iPort - iDriver - 1)
            End If
        End If
        '
        If DriverName <> vbNullString And PrinterPort <> vbNullString Then
            DeviceLine = DeviceName & "," & DriverName & "," & PrinterPort
            ' Store the new printer information in the [WINDOWS] section of the WIN.INI file for the DEVICE= item
            R = WriteProfileString("windows", "Device", DeviceLine)
            If R Then
                'Cause all applications to reload the INI file:
                l = SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0, "windows")
                SetPrinterAsDefault = True
            Else
                SetPrinterAsDefault = False
            End If
        Else
            SetPrinterAsDefault = False
        End If
    Else
        SetPrinterAsDefault = True
    End If
End Function

Private Function TerminalServerSessionId() As String
    'Purpose   :    Returns a terminal server session ID
    'Inputs    :    N/A
    'Outputs   :    Returns "0" if not a terminal server, else returns
    '               the terminal server session ID.
    Dim lRetVal As Long, lCount As Long, lThisProcess As Long, lThisProcessId  As Long
    Dim lpBuffer As Long, lp As Long, udtProcessInfo As WTS_PROCESS_INFO
    Const WTS_CURRENT_SERVER_HANDLE = 0&
    
    On Error GoTo ErrNotTerminalServer
    'Set Default Value
    TerminalServerSessionId = "0"
    If Environ("SESSIONNAME") = "Console" Then Exit Function
    lThisProcessId = GetCurrentProcessId
    lRetVal = WTSEnumerateProcesses(WTS_CURRENT_SERVER_HANDLE, 0&, 1, lpBuffer, lCount)
    If lRetVal Then
        'Successful
        lp = lpBuffer
        For lThisProcess = 1 To lCount
            CopyMemory udtProcessInfo, ByVal lp, LenB(udtProcessInfo)
            If lThisProcessId = udtProcessInfo.ProcessId Then
                TerminalServerSessionId = CStr(udtProcessInfo.SessionID)
                Exit For
            End If
            lp = lp + LenB(udtProcessInfo)
        Next
        'Free memory buffer
        WTSFreeMemory lpBuffer
    End If
    
    Exit Function
    
ErrNotTerminalServer:
    'The machine is not a Terminal Server
    On Error GoTo 0
End Function

Public Function fstrLimpiarNombreImpresoraRDP(strNombreImpresora As String) As String
    Dim intPos As Integer
    intPos = InStr(strNombreImpresora, " (redirected ")
    If intPos > 0 Then
        fstrLimpiarNombreImpresoraRDP = Trim(Mid(strNombreImpresora, 1, intPos)) & IIf(Environ("SESSIONNAME") = "Console", "", " (redirected " & vglngTerminalServerSessionId & ")")
    Else
        fstrLimpiarNombreImpresoraRDP = strNombreImpresora
    End If
End Function

Public Function fblnAsignaImpresoraReportePorNombre(strNombreImpresora As String, ByRef rptReporte As CRAXDRT.Report) As Boolean
    'Asigna la impresora configurada al reporte
    
    Dim prtImpresora As Printer
    Dim currPaperSize As CRAXDRT.CRPaperSize
    Dim currPaperOrientation As CRAXDRT.CRPaperOrientation
    Dim currPrinterName As String
    
    fblnAsignaImpresoraReportePorNombre = False
    currPrinterName = Printer.DeviceName
    currPaperSize = rptReporte.PaperSize
    currPaperOrientation = rptReporte.PaperOrientation
    
    If SetPrinterAsDefault(fstrLimpiarNombreImpresoraRDP(strNombreImpresora)) Then
        rptReporte.SelectPrinter Printer.DriverName, Printer.DeviceName, Printer.port
        On Error Resume Next
        rptReporte.PaperSize = currPaperSize
        rptReporte.PaperOrientation = currPaperOrientation
        On Error GoTo 0
        If SetPrinterAsDefault(currPrinterName) Then
            fblnAsignaImpresoraReportePorNombre = True
        End If
    End If
    
End Function

Public Function fblnAsignaImpresoraReporte(intCveDepto As Integer, strTipoDocto As String, ByRef rptReporte As CRAXDRT.Report) As Boolean
    'Asigna la impresora configurada al reporte
    
    Dim rs As New ADODB.Recordset
    
    fblnAsignaImpresoraReporte = False
    vgstrParametrosSP = str(intCveDepto) & "|" & strTipoDocto
    Set rs = frsEjecuta_SP(vgstrParametrosSP, "sp_GnSelImpresoraDepto")
    If rs.RecordCount <> 0 Then
        If fblnAsignaImpresoraReportePorNombre(Trim(rs!chrNombreImpresora), rptReporte) Then
            fblnAsignaImpresoraReporte = True
        End If
    End If
    rs.Close
End Function

'Funcion que verifica si se hace uso del bit de trazabilidad
Public Function fblnrevisaUsoTrazabilidad() As Boolean
    Dim strQry As String
    Dim rs As New ADODB.Recordset
    
    fblnrevisaUsoTrazabilidad = False
    
    strQry = "select vchvalor from siparametro where trim(vchnombre) = 'BITTRAZABILIDAD'"
    Set rs = frsRegresaRs(strQry, adLockOptimistic, adOpenDynamic)
    
    If rs.RecordCount > 0 Then
        If rs!VCHVALOR = "1" Then
            fblnrevisaUsoTrazabilidad = True
        End If
    End If
End Function


